<!DOCTYPE html>
<html lang="en" class="dark" data-theme="matrix">
<head>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Prompt Builder MAX</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        const PREF_KEY = 'promptBuilder_v70_prefs';
		// ==========================================
		//  SECURE SYSTEM ACCESS CONTROL (SHA-256)
		// ==========================================
		const SYSTEM_CONFIG = {
			// PASTE YOUR GENERATED HASH BELOW (This example hash is for 'password')
			passwordHash: "1a01c861ab8f419359d213de09619414ab18d8e3e6f11c7ff8b65d38d70a5292", 
			sessionKey: "pb_max_secure_access_v1"
		};

		// 1. Check on Load
		document.addEventListener("DOMContentLoaded", () => {
			const isUnlocked = sessionStorage.getItem(SYSTEM_CONFIG.sessionKey);
			const lockScreen = document.getElementById('access-lock-screen');
			const pwdInput = document.getElementById('access-pwd-input');
			
			if (isUnlocked === 'true') {
				if(lockScreen) lockScreen.style.display = 'none';
			} else {
				if(lockScreen) lockScreen.classList.remove('hidden');
				if(pwdInput) pwdInput.focus();
			}
		});

		// 2. Secure Verify Function (Async)
		window.checkSystemAccess = async function() {
			const input = document.getElementById('access-pwd-input');
			const screen = document.getElementById('access-lock-screen');
			const errorMsg = document.getElementById('access-error');
			const container = screen.querySelector('.relative.group');

			if (!input.value) return;

			// HASH THE INPUT
			const encoder = new TextEncoder();
			const data = encoder.encode(input.value);
			const hashBuffer = await crypto.subtle.digest('SHA-256', data);
			const hashArray = Array.from(new Uint8Array(hashBuffer));
			const inputHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

			// COMPARE HASHES
			if (inputHash === SYSTEM_CONFIG.passwordHash) {
				// SUCCESS
				sessionStorage.setItem(SYSTEM_CONFIG.sessionKey, 'true');
				
				// Success Animation
				const icon = container.querySelector('svg');
				if(icon) {
					icon.classList.remove('text-theme-500');
					icon.classList.add('text-green-500');
					icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>';
				}

				setTimeout(() => {
					screen.style.transform = "translateY(-100%)";
					setTimeout(() => {
						screen.style.display = 'none';
					}, 500);
				}, 300);
				
			} else {
				// FAIL
				errorMsg.classList.remove('hidden');
				input.value = '';
				input.focus();
				
				container.classList.add('shake-anim');
				setTimeout(() => container.classList.remove('shake-anim'), 500);
			}
		};

		// 3. Lock Function
		window.lockSystem = function() {
			sessionStorage.removeItem(SYSTEM_CONFIG.sessionKey);
			location.reload(); 
		};
        // Immediate Theme Apply to prevent flash
        try {
            const prefsAll = JSON.parse(localStorage.getItem(PREF_KEY) || '{}');
            if(prefsAll && prefsAll.state && prefsAll.state.theme) {
                document.documentElement.setAttribute('data-theme', prefsAll.state.theme);
            }
        } catch(e){}

        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        gray: { 900: '#0f172a', 800: '#1e293b', 700: '#334155' },
                        theme: { 400: 'var(--theme-400)', 500: 'var(--theme-500)', 600: 'var(--theme-600)', 900: 'var(--theme-900)' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'], mono: ['JetBrains Mono', 'monospace'] },
                    animation: { 'fade-in': 'fadeIn 0.5s ease-out' },
                    keyframes: { fadeIn: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' } } }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=JetBrains+Mono:wght@400&display=swap');
        
        :root {
            --glass-bg: rgba(30, 41, 59, 0.4);
            --page-bg: #020617;
            --theme-400: #34d399; --theme-500: #10b981; --theme-600: #059669; --theme-900: #064e3b;
        }

        /* --- THEME DEFINITIONS --- */
        [data-theme="matrix"] { --theme-400: #34d399; --theme-500: #10b981; --theme-600: #059669; --theme-900: #064e3b; --page-bg: #020617; }
        html.nsfw-mode[data-theme="matrix"] { --theme-400: #f87171; --theme-500: #ef4444; --theme-600: #dc2626; --theme-900: #7f1d1d; --page-bg: #1a0505; }

        [data-theme="danger"] { --theme-400: #f87171; --theme-500: #ef4444; --theme-600: #dc2626; --theme-900: #7f1d1d; --page-bg: #1a0505; }
        html.nsfw-mode[data-theme="danger"] { --theme-400: #34d399; --theme-500: #10b981; --theme-600: #059669; --theme-900: #064e3b; --page-bg: #020617; }

        [data-theme="synthwave"] { --theme-400: #e879f9; --theme-500: #d946ef; --theme-600: #c026d3; --theme-900: #701a75; --page-bg: #15021a; }
        html.nsfw-mode[data-theme="synthwave"] { --theme-400: #facc15; --theme-500: #eab308; --theme-600: #ca8a04; --theme-900: #713f12; --page-bg: #1a1002; }

        [data-theme="abyss"] { --theme-400: #38bdf8; --theme-500: #0ea5e9; --theme-600: #0284c7; --theme-900: #0c4a6e; --page-bg: #02091a; }
        html.nsfw-mode[data-theme="abyss"] { --theme-400: #fb923c; --theme-500: #f97316; --theme-600: #ea580c; --theme-900: #7c2d12; --page-bg: #1a0a02; }

        [data-theme="golden"] { --theme-400: #fbbf24; --theme-500: #f59e0b; --theme-600: #d97706; --theme-900: #78350f; --page-bg: #1a1202; }
        html.nsfw-mode[data-theme="golden"] { --theme-400: #22d3ee; --theme-500: #06b6d4; --theme-600: #0891b2; --theme-900: #164e63; --page-bg: #02101a; }
        
        [data-theme="violet"] { --theme-400: #a78bfa; --theme-500: #8b5cf6; --theme-600: #7c3aed; --theme-900: #4c1d95; --page-bg: #1e1b4b; }
        html.nsfw-mode[data-theme="violet"] { --theme-400: #f472b6; --theme-500: #ec4899; --theme-600: #db2777; --theme-900: #831843; --page-bg: #310b1e; }

        [data-theme="yellow"] { --theme-400: #facc15; --theme-500: #eab308; --theme-600: #ca8a04; --theme-900: #713f12; --page-bg: #1a1500; }
        html.nsfw-mode[data-theme="yellow"] { --theme-400: #fbbf24; --theme-500: #f59e0b; --theme-600: #d97706; --theme-900: #451a03; --page-bg: #1a0a00; }

        [data-theme="lime"] { --theme-400: #a3e635; --theme-500: #84cc16; --theme-600: #65a30d; --theme-900: #365314; --page-bg: #0f1a05; }
        html.nsfw-mode[data-theme="lime"] { --theme-400: #fb7185; --theme-500: #f43f5e; --theme-600: #e11d48; --theme-900: #881337; --page-bg: #1a050a; }

        [data-theme="pink"] { --theme-400: #f472b6; --theme-500: #ec4899; --theme-600: #db2777; --theme-900: #831843; --page-bg: #1f0510; }
        html.nsfw-mode[data-theme="pink"] { --theme-400: #c084fc; --theme-500: #a855f7; --theme-600: #9333ea; --theme-900: #581c87; --page-bg: #150520; }

        [data-theme="ocean"] { --theme-400: #2dd4bf; --theme-500: #14b8a6; --theme-600: #0d9488; --theme-900: #134e4a; --page-bg: #042f2e; }
        html.nsfw-mode[data-theme="ocean"] { --theme-400: #f87171; --theme-500: #ef4444; --theme-600: #dc2626; --theme-900: #7f1d1d; --page-bg: #2b0808; }
        
        body { font-family: 'Inter', sans-serif; background-color: var(--page-bg); color: #f8fafc; transition: background-color 0.8s ease; }
        .glass-panel { background: var(--glass-bg); backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.08); transition: background 0.5s ease; }
        
        .glass-clear {
            background-color: rgba(0, 0, 0, 0.2) !important; 
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border-top: 1px solid rgba(255, 255, 255, 0.15) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15) !important;
            box-shadow: none !important;
        }
		/* --- FIX: Disable Native Image Dragging for Gestures --- */
		img, #lb-image, .slide-img {
				-webkit-user-drag: none;
				-khtml-user-drag: none;
				-moz-user-drag: none;
				-o-user-drag: none;
				user-drag: none;
				user-select: none;
				-webkit-user-select: none;
			}
        select, input[type="text"], input[type="password"], input[type="number"], textarea { background-color: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); transition: all 0.2s ease; }
        select:focus, input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus, textarea:focus { border-color: var(--theme-500); box-shadow: 0 0 0 1px var(--theme-500); background-color: rgba(15, 23, 42, 0.9); }
        select { appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml;utf8,<svg fill='%2394a3b8' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>"); background-repeat: no-repeat; background-position: right 12px center; }
        
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] > summary .chevron { transform: rotate(180deg); }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.3); border-radius: 10px; }
        .tap-highlight-none { -webkit-tap-highlight-color: transparent; }
        .theme-dot.active-dot { transform: scale(1.3); border-color: white; box-shadow: 0 0 10px var(--theme-500); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* FIX: Header Click-Through & Positioning */
        #app-header {
            padding-top: env(safe-area-inset-top) !important; 
            padding-bottom: 0.5rem !important;
            height: auto !important;
            z-index: 50;
            pointer-events: none !important; 
        }
        
        #app-header > div {
            pointer-events: auto !important;
        }

        /* --- UPDATED ACTION BAR POSITIONING --- */
        #action-bar { 
            /* Changed from 80px to dynamic calculation to clear the Nav Dock on mobile */
            bottom: calc(5.5rem + env(safe-area-inset-bottom, 20px)) !important; 
            border: none; 
            background: transparent; 
            box-shadow: none; 
            pointer-events: none; 
        }
        #action-bar > div { pointer-events: auto; }
		/* --- CRITICAL LAYOUT FIXES --- */
        .hidden {
            display: none !important;
        }
        
        /* 1. Force Hide Setup if Grid is visible (CSS Override) */
        #gallery-grid-screen:not(.hidden) ~ #setup-screen {
            display: none !important;
        }
        
        /* 2. Ensure Grid View Stacks Correctly */
        #gallery-grid-screen {
            position: relative;
            z-index: 10;
        }
        #main-scroll { padding-bottom: 90px !important; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom, 10px); }
        
        /* Effects */
        .slide-img { position: absolute; max-width: 90%; max-height: 90%; transition: all var(--slide-speed, 0.8s) cubic-bezier(0.4, 0, 0.2, 1); opacity: 0; backface-visibility: hidden; transform-style: preserve-3d; border-radius: 12px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); }
        .fx-fade .slide-img.active { opacity: 1; transform: scale(1); z-index: 20; } .fx-fade .slide-img.exit { opacity: 0; z-index: 10; }
        .fx-slide .slide-img { transform: translateX(100%); opacity: 0; } .fx-slide .slide-img.active { transform: translateX(0); opacity: 1; z-index: 20; } .fx-slide .slide-img.exit { transform: translateX(-100%); opacity: 0; z-index: 10; }
        .fx-zoom .slide-img { transform: scale(0.5); opacity: 0; } .fx-zoom .slide-img.active { transform: scale(1); opacity: 1; z-index: 20; } .fx-zoom .slide-img.exit { transform: scale(1.5); opacity: 0; z-index: 10; }
        .fx-flip .slide-img { transform: perspective(1000px) rotateY(90deg); opacity: 0; } .fx-flip .slide-img.active { transform: perspective(1000px) rotateY(0deg); opacity: 1; z-index: 20; } .fx-flip .slide-img.exit { transform: perspective(1000px) rotateY(-90deg); opacity: 0; z-index: 10; }
        .fx-elastic .slide-img { transform: scale(0.8); opacity: 0; transition-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55); } .fx-elastic .slide-img.active { transform: scale(1); opacity: 1; z-index: 20; } .fx-elastic .slide-img.exit { transform: scale(1.2); opacity: 0; z-index: 10; }
        .fx-elevator .slide-img { transform: translateY(100%); opacity: 0; } .fx-elevator .slide-img.active { transform: translateY(0); opacity: 1; z-index: 20; } .fx-elevator .slide-img.exit { transform: translateY(-100%); opacity: 0; z-index: 10; }
        .fx-cube .slide-img { transform: perspective(1000px) translateX(100%) rotateY(90deg); opacity: 0; } .fx-cube .slide-img.active { transform: perspective(1000px) translateX(0) rotateY(0deg); opacity: 1; z-index: 20; } .fx-cube .slide-img.exit { transform: perspective(1000px) translateX(-100%) rotateY(-90deg); opacity: 0; z-index: 10; }
        .fx-unfold .slide-img { transform: perspective(1000px) rotateX(-90deg); opacity: 0; transform-origin: top; } .fx-unfold .slide-img.active { transform: perspective(1000px) rotateX(0deg); opacity: 1; z-index: 20; } .fx-unfold .slide-img.exit { transform: perspective(1000px) rotateX(90deg); opacity: 0; z-index: 10; transform-origin: bottom; }
        
        @keyframes drift { 0% { transform: translate(0, 0) rotate(0deg); } 33% { transform: translate(40px, -50px) rotate(10deg); } 66% { transform: translate(-30px, 30px) rotate(-5deg); } 100% { transform: translate(0, 0) rotate(0deg); } }
        .animate-drift-slow { animation: drift 25s infinite ease-in-out; }
        .animate-drift-medium { animation: drift 18s infinite ease-in-out reverse; }
        .animate-pulse-slow { animation: pulse 10s infinite ease-in-out; }
        .animation-delay-2000 { animation-delay: 2s; }
        
        #nav-dock { background-color: rgba(0, 0, 0, 0.3) !important; backdrop-filter: saturate(180%) blur(16px) !important; -webkit-backdrop-filter: saturate(180%) blur(16px) !important; box-shadow: none !important; border-top: 1px solid rgba(255, 255, 255, 0.1) !important; }
        #slideshow-screen, #lightbox-overlay, #cat-overlay { touch-action: none; }
        #lb-image { touch-action: none; will-change: transform; transform-origin: center; cursor: zoom-in; transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        #lb-image.dragging { transition: none !important; cursor: grabbing !important; }
		/* --- CUSTOM GLOW ANIMATION --- */
			@keyframes theme-pulse {
				0%, 100% { box-shadow: 0 0 5px var(--theme-500); }
				50% { box-shadow: 0 0 15px var(--theme-500), 0 0 5px var(--theme-400); }
			}

			.btn-active-glow {
				background: linear-gradient(135deg, var(--theme-600), var(--theme-500)) !important;
				color: white !important;
				border-color: var(--theme-400) !important;
				animation: theme-pulse 2s infinite ease-in-out !important;
				font-weight: 800 !important;
			}
			/* --- SLIDER SMOOTHNESS --- */
			#comp-overlay {
				will-change: width;
				backface-visibility: hidden;
				-webkit-backface-visibility: hidden;
			}
			#comp-slider {
				will-change: left;
			}
			/* Ensure comparison layers stay visible when UI fades */
			#compare-container:not(.hidden) {
				display: flex !important;
				opacity: 1 !important;
				pointer-events: auto !important;
			}

			#comp-overlay {
				will-change: width;
				backface-visibility: hidden;
				-webkit-backface-visibility: hidden;
			}

			#comp-slider {
				will-change: left;
			}
			/* --- STAGGERED GRID ANIMATION --- */
			@keyframes fadeInUp {
				from { opacity: 0; transform: translateY(20px); }
				to { opacity: 1; transform: translateY(0); }
			}

			.grid-item-animate {
				opacity: 0; /* Start hidden */
				animation: fadeInUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
			}
			/* Lock Screen Animations */
			@keyframes shake {
				0%, 100% { transform: translateX(0); }
				10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
				20%, 40%, 60%, 80% { transform: translateX(5px); }
			}
			.shake-anim {
				animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
			}
			#lightbox .absolute.top-4.right-4, 
			#lightbox .absolute.top-4.left-4 {
				/* Push buttons down below the notch/dynamic island */
				top: max(16px, env(safe-area-inset-top) + 16px) !important;
			}

			/* Ensure bottom buttons don't hit the home bar */
			#lightbox .absolute.bottom-4 {
				bottom: max(16px, env(safe-area-inset-bottom) + 16px) !important;
			}
    </style>
	<script src="https://js.puter.com/v2/"></script>
</head>
<body class="h-screen flex flex-col overflow-hidden relative bg-gray-900/80">
			<div id="access-lock-screen" class="fixed inset-0 z-[9999] bg-gray-950 flex flex-col items-center justify-center space-y-6 transition-transform duration-500">
				<div class="absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 pointer-events-none"></div>
				
				<div class="relative group">
					<div class="absolute -inset-1 bg-gradient-to-r from-theme-600 to-theme-400 rounded-2xl blur opacity-25 group-hover:opacity-75 transition duration-1000 group-hover:duration-200"></div>
					<div class="relative px-8 py-10 bg-gray-900 ring-1 ring-gray-800 rounded-xl leading-none flex flex-col items-center space-y-6 w-[320px]">
						
						<div class="w-16 h-16 rounded-full bg-gray-800 flex items-center justify-center border border-gray-700 shadow-inner">
							<svg class="w-8 h-8 text-theme-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
						</div>
						
						<div class="text-center space-y-1">
							<h2 class="text-xl font-bold text-white tracking-widest uppercase">System Locked</h2>
							<p class="text-[10px] text-gray-500 font-mono">AUTHORIZED PERSONNEL ONLY</p>
						</div>

						<div class="w-full space-y-3">
							<input type="password" id="access-pwd-input" placeholder="Enter Access Code" 
								class="w-full bg-black/50 border border-gray-700 text-center text-white text-lg tracking-[0.5em] rounded-lg py-3 focus:outline-none focus:border-theme-500 transition-colors font-mono placeholder:tracking-normal placeholder:text-sm placeholder:text-gray-600"
								onkeypress="if(event.key === 'Enter') checkSystemAccess()">
							
							<button onclick="checkSystemAccess()" class="w-full py-3 bg-gradient-to-r from-theme-600 to-theme-500 hover:from-theme-500 hover:to-theme-400 text-white font-bold rounded-lg shadow-lg active:scale-95 transition-all text-xs tracking-widest">
								UNLOCK TERMINAL
							</button>
						</div>

						<div id="access-error" class="hidden text-red-500 text-[10px] font-bold tracking-widest animate-pulse">
							⛔ ACCESS DENIED
						</div>
					</div>
				</div>
				
				<div class="text-[9px] text-gray-600 font-mono fixed bottom-8">
					SECURE CONNECTION ESTABLISHED
				</div>
			</div>
    <div id="aurora-bg" class="fixed inset-0 z-0 pointer-events-none overflow-hidden">
        <div class="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] rounded-full bg-theme-900 opacity-40 blur-[100px] animate-drift-slow mix-blend-screen"></div>
        <div class="absolute bottom-[-10%] right-[-10%] w-[400px] h-[400px] rounded-full bg-theme-600 opacity-30 blur-[80px] animate-drift-medium animation-delay-2000 mix-blend-screen"></div>
        <div class="absolute top-[40%] left-[40%] w-[300px] h-[300px] rounded-full bg-theme-400 opacity-20 blur-[60px] animate-pulse-slow mix-blend-overlay"></div>
    </div>

    <header id="app-header" class="glass-clear fixed top-0 w-full z-50 flex-none px-4 py-2 transition-all duration-300">
        <div class="max-w-3xl mx-auto flex justify-between items-center h-10">
            <div class="flex items-center gap-2 pointer-events-auto">
                <img src="icon2.png" class="w-7 h-7 rounded-lg shadow-md shadow-theme-500/20 object-cover" alt="App Icon">
                <div class="flex flex-col -gap-0.5">
                    <h1 class="text-sm font-bold leading-tight tracking-tight text-white">PROMPTER</h1>
                    <span class="text-[8px] font-mono text-theme-400 tracking-widest uppercase opacity-80">MAX VERSION</span>
                </div>
            </div>
            <div class="flex items-center gap-2 pointer-events-auto"> 
                <div id="status-badge" class="px-2 py-1 rounded-full border flex items-center gap-1.5 transition-all duration-300 backdrop-blur-md shadow-lg text-[9px] font-mono font-bold tracking-wide select-none bg-gray-800/50 border-gray-700 text-gray-500">
                    <span class="w-1.5 h-1.5 rounded-full bg-gray-500"></span>
                    <span>INIT...</span>
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow overflow-y-auto relative scroll-smooth z-0 pt-24 pb-32" id="main-scroll">
        <div class="max-w-3xl mx-auto p-4 pb-40 min-h-full">
		<div id="history-screen" class="hidden space-y-6 animate-fade-in pt-6">
                <div class="glass-panel p-6 rounded-2xl border border-theme-500/30 text-center">
                    <div class="flex justify-between items-center mb-6">
                        <button id="close-hist-btn" class="text-xs font-bold text-gray-400 hover:text-white flex items-center gap-1">BACK</button>
                        <h2 class="text-lg font-bold text-white">Generation History</h2>
                        <div class="w-8"></div>
                    </div>
                    <div id="history-list" class="space-y-3 mb-6 max-h-[60vh] overflow-y-auto scrollbar-thin text-left"></div>
                    <button id="wipe-hist-btn" class="w-full py-3 rounded-xl bg-red-900/30 hover:bg-red-900/50 text-red-400 font-bold border border-red-900/50 text-xs">CLEAR HISTORY</button>
                </div>
            </div>
			
			<div id="gallery-grid-screen" class="hidden space-y-4 animate-fade-in pt-6 z-50 relative">
			<div class="glass-panel p-4 rounded-2xl border border-theme-500/30 min-h-[85vh] flex flex-col bg-gray-900/95 backdrop-blur-xl">
                    <div class="sticky top-0 bg-gray-900/95 backdrop-blur-xl rounded-xl z-20 border border-white/10 shadow-2xl mb-2 pb-2">
                        
                        <div class="flex justify-between items-center p-3 border-b border-white/5">
                            <div class="flex items-center gap-3">
                                <button id="close-grid-btn" class="p-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-white transition-all group active:scale-95">
                                    <svg class="w-4 h-4 text-gray-400 group-hover:text-white transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                                </button>
                                <h2 class="text-xs font-bold text-white flex items-center gap-2 uppercase tracking-widest">
                                    <svg class="w-4 h-4 text-theme-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2z"></path></svg>
                                    Gallery
                                </h2>
                            </div>
                            <span id="grid-total-count" class="text-[9px] font-mono text-theme-400 bg-black/50 px-3 py-1.5 rounded-lg border border-theme-500/30 font-bold">0 ITEMS</span>
                        </div>

                        <div id="grid-filter-bar" class="flex gap-2 overflow-x-auto no-scrollbar p-2 mt-1">
                            </div>
                    </div>
                    
                    <div id="full-gallery-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-1.5 auto-rows-fr pb-4"></div>
                    
                    <button id="grid-load-more-btn" class="hidden w-full py-4 mt-auto rounded-xl bg-gradient-to-r from-gray-800 to-gray-900 hover:from-gray-700 hover:to-gray-800 text-gray-400 font-bold text-[10px] border border-gray-700 transition-all tracking-widest shadow-lg active:scale-95">
                        + MORE
                    </button>
                </div>
            </div>
            <div id="db-screen" class="hidden space-y-6 animate-fade-in pt-6">
                <div class="glass-panel p-6 rounded-2xl border border-theme-500/30 text-center">
                    <h2 class="text-xl font-bold text-white mb-2">Database Manager</h2>
                    <div class="bg-gray-900/50 rounded-lg p-4 mb-6 text-left border border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <p class="text-[10px] font-bold text-gray-500 uppercase">Loaded Files</p>
                            <span id="file-count" class="text-[10px] font-bold text-theme-400">0 FILES</span>
                        </div>
                        <div id="loaded-files-list" class="text-xs font-mono text-gray-300 space-y-1 max-h-24 overflow-y-auto scrollbar-thin"></div>
                    </div>
                    <input type="file" id="file-input" multiple accept=".js, .json" class="hidden">
                    <div class="grid grid-cols-2 gap-3 mb-3">
                        <button id="add-file-btn" class="py-3 rounded-xl bg-gray-700 hover:bg-gray-600 text-white font-bold border border-gray-600 text-[10px]">ADD DATASET</button>
                        <button id="wipe-db-btn" class="py-3 rounded-xl bg-red-900/30 hover:bg-red-900/50 text-red-400 font-bold border border-red-900/50 text-[10px]">WIPE ALL DATA</button>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="backup-db-btn" class="py-3 rounded-xl bg-blue-900/40 hover:bg-blue-600 text-blue-300 hover:text-white font-bold border border-blue-500/30 text-[10px]">BACKUP GALLERY</button>
                        <button id="merge-gallery-btn" onclick="document.getElementById('merge-input').click()" class="py-3 rounded-xl bg-teal-900/40 hover:bg-teal-600 text-teal-300 hover:text-white font-bold border border-teal-500/30 text-[10px]">MERGE BACKUP</button>
                        <input type="file" id="merge-input" accept=".zip" class="hidden">
                        <button id="view-cat-btn" onclick="document.getElementById('zip-cat-input').click()" class="py-3 rounded-xl bg-indigo-900/40 hover:bg-indigo-600 text-indigo-300 hover:text-white font-bold border border-indigo-500/30 text-[10px]">OPEN CATALOGUE</button>
                        <input type="file" id="zip-cat-input" accept=".zip" class="hidden">
                    </div>
                    <button id="launch-gallery-btn" class="w-full py-3 mb-3 rounded-xl bg-theme-900/40 hover:bg-theme-600 text-theme-400 hover:text-white font-bold border border-theme-500/30 transition-all flex items-center justify-center gap-2 text-xs mt-4">PLAY FULL GALLERY</button>

					<button id="reset-puter-btn" class="w-full py-3 mb-3 rounded-xl bg-orange-900/30 hover:bg-orange-700 text-orange-400 hover:text-white font-bold border 	border-orange-500/30 transition-all flex items-center justify-center gap-2 text-[10px]">
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path></svg>
					RESET PUTER AUTH
					</button>

					<button id="done-btn" class="w-full py-4 rounded-xl bg-gradient-to-r from-theme-600 to-theme-500 text-white font-bold shadow-lg hover:shadow-theme-900/40 mt-2">DONE</button>
					</div>
				</div>

            <div id="catalogue-screen" class="hidden space-y-6 animate-fade-in pt-6">
                <div class="glass-panel p-6 rounded-2xl border border-theme-500/30">
                    <div class="flex justify-between items-center mb-6">
                        <button id="close-cat-btn" class="text-xs font-bold text-gray-400 hover:text-white flex items-center gap-1">BACK</button>
                        <button id="cat-slideshow-btn" class="hidden flex items-center gap-2 px-3 py-1.5 bg-theme-900/40 border border-theme-500/30 rounded-lg text-[10px] font-bold text-theme-400 hover:bg-theme-600 hover:text-white">PLAY SLIDESHOW</button>
                    </div>
                    <div id="catalogue-grid" class="grid grid-cols-3 sm:grid-cols-4 gap-3 max-h-[70vh] overflow-y-auto scrollbar-thin p-1 min-h-[100px]"></div>
                </div>
            </div>
			
            <div id="setup-screen" class="hidden space-y-6 animate-fade-in pt-2 relative">
                <button onclick="lockSystem()" class="absolute top-2 right-2 p-2 bg-gray-800/50 hover:bg-red-900/50 text-gray-400 hover:text-red-400 rounded-full transition-colors border border-gray-700 z-10" title="Lock System">
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
				</button>
				<div class="flex justify-center flex-wrap gap-4 py-3 border-t border-gray-800/50 mt-2">
                    <button onclick="changeTheme('matrix')" class="theme-dot w-6 h-6 rounded-full bg-[#10b981] border-2 border-transparent shadow-[0_0_10px_rgba(16,185,129,0.5)] hover:scale-125 transition-all" title="Matrix"></button>
                    <button onclick="changeTheme('danger')" class="theme-dot w-6 h-6 rounded-full bg-[#ef4444] border-2 border-transparent shadow-[0_0_10px_rgba(239,68,68,0.5)] hover:scale-125 transition-all" title="Danger"></button>
                    <button onclick="changeTheme('synthwave')" class="theme-dot w-6 h-6 rounded-full bg-[#d946ef] border-2 border-transparent shadow-[0_0_10px_rgba(217,70,239,0.5)] hover:scale-125 transition-all" title="Synthwave"></button>
                    <button onclick="changeTheme('abyss')" class="theme-dot w-6 h-6 rounded-full bg-[#0ea5e9] border-2 border-transparent shadow-[0_0_10px_rgba(14,165,233,0.5)] hover:scale-125 transition-all" title="Abyss"></button>
                    <button onclick="changeTheme('golden')" class="theme-dot w-6 h-6 rounded-full bg-[#f59e0b] border-2 border-transparent shadow-[0_0_10px_rgba(245,158,11,0.5)] hover:scale-125 transition-all" title="Golden"></button>
                    <button onclick="changeTheme('violet')" class="theme-dot w-6 h-6 rounded-full bg-[#8b5cf6] border-2 border-transparent shadow-[0_0_10px_rgba(139,92,246,0.5)] hover:scale-125 transition-all" title="Violet"></button>
                    <button onclick="changeTheme('yellow')" class="theme-dot w-6 h-6 rounded-full bg-[#eab308] border-2 border-transparent shadow-[0_0_10px_rgba(234,179,8,0.5)] hover:scale-125 transition-all" title="Cyber"></button>
                    <button onclick="changeTheme('lime')" class="theme-dot w-6 h-6 rounded-full bg-[#84cc16] border-2 border-transparent shadow-[0_0_10px_rgba(132,204,22,0.5)] hover:scale-125 transition-all" title="Toxic"></button>
                    <button onclick="changeTheme('pink')" class="theme-dot w-6 h-6 rounded-full bg-[#ec4899] border-2 border-transparent shadow-[0_0_10px_rgba(236,72,153,0.5)] hover:scale-125 transition-all" title="Hot Pink"></button>
                    <button onclick="changeTheme('ocean')" class="theme-dot w-6 h-6 rounded-full bg-[#14b8a6] border-2 border-transparent shadow-[0_0_10px_rgba(20,184,166,0.5)] hover:scale-125 transition-all" title="Ocean"></button>
                </div>
                
                <div class="glass-panel p-3 rounded-2xl border border-gray-700/50 space-y-2">
                    
					<label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-1 ml-1">GENERATOR PROVIDER</label>
                  <div class="grid grid-cols-6 gap-1 p-1 bg-gray-900/50 rounded-xl border border-gray-700/50"> 
                        <button id="prov-gemini" class="py-1.5 px-1 rounded-lg text-[10px] font-bold transition-all bg-theme-600 text-white shadow-lg" onclick="setProvider('gemini')">GEMINI</button>
						<button id="prov-cloudflare" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('cloudflare')">C.FLARE</button>
						<button id="prov-puter" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('puter')">PUTER</button>
						<button id="prov-pollination" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('pollination')">POLL</button>
						<button id="prov-huggingface" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('huggingface')">H.FACE</button>
						<button id="prov-freepik" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('freepik')">FREEPIK</button>
						<button id="prov-horde" class="py-1.5 px-1 rounded-lg text-[10px] font-bold text-gray-400 hover:text-white transition-all" onclick="setProvider('horde')">HORDE</button>
					</div>
                    <div class="flex justify-end">
                        <button id="fetch-models-btn" class="text-[9px] font-bold text-theme-400 hover:text-white border border-theme-500/30 hover:bg-theme-500/20 px-2 py-1 rounded transition-colors flex items-center gap-1">FETCH MODELS</button>
                    </div>

                    <div id="gemini-settings-group" class="space-y-2">
                        <div class="relative w-full">
							<input type="password" id="api-key-input" placeholder="Gemini API Key" class="w-full p-2 pr-10 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 transition-colors">
							<button onclick="togglePasswordVisibility('api-key-input', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
							</button>
						</div>
                        <div class="space-y-2">
                            <select id="model-select" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500"><option value="imagen-3.0-generate-001" selected>Imagen 3.0</option><option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option></select>
                            <div class="grid grid-cols-2 gap-2">
                                <select id="text-model-select" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500"><option value="gemini-2.0-flash-exp">Gemini 2.0 Flash</option></select>
                                <select id="scan-model-select" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500"><option value="gemini-1.5-flash">Gemini 1.5 Flash</option></select>
                            </div>
                        </div>
                    </div>
                    
                    <div id="cloudflare-settings-group" class="hidden space-y-2">
                        <div class="relative w-full">
							<input type="password" id="cf-account-id" placeholder="Account ID" class="w-full p-2 pr-10 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 transition-colors">
							<button onclick="togglePasswordVisibility('cf-account-id', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
							</button>
						</div>

						<div class="relative w-full">
							<input type="password" id="cf-api-token" placeholder="API Token" class="w-full p-2 pr-10 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 transition-colors">
							<button onclick="togglePasswordVisibility('cf-api-token', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
							</button>
						</div>
                        
                        <select id="cf-model-select" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            <option value="@cf/bytedance/stable-diffusion-xl-lightning">SDXL Lightning (Fast)</option>
                            <option value="@cf/stabilityai/stable-diffusion-xl-base-1.0" selected>SDXL Base 1.0</option>
                            <option value="@cf/lykon/dreamshaper-8-lcm">DreamShaper 8 (LCM)</option>
                            <option value="@cf/runwayml/stable-diffusion-v1-5-inpainting">SD 1.5 Inpainting</option>
                            <option value="@cf/stabilityai/stable-diffusion-xl-refiner-1.0">SDXL Refiner</option>
                            <option value="@cf/lykon/dreamshaper-8-lcm">DreamShaper 8 (Artistic)</option>
                            <option value="@cf/leonardo/phoenix-1.0">Leonardo Phoenix 1.0</option>
                            <option value="@cf/leonardo/lucid-origin">Lucid origin</option>
                            <option value="@cf/black-forest-labs/flux-1-schnell">Flux-1 Schnell (New!)</option>
                            <option value="@cf/black-forest-labs/flux-2-dev">Flux.2 [Dev] (Premium/Slow)</option>
                        </select>

                        <div class="grid grid-cols-3 gap-2">
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Steps</label>
                                <input type="number" id="cf-steps" placeholder="20" value="20" min="1" max="50" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Guidance</label>
                                <input type="number" id="cf-guidance" placeholder="7.5" value="7.5" step="0.5" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Seed</label>
                                <input type="text" id="cf-seed" placeholder="Random" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 pt-2 border-t border-gray-700/50">
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Magic Fix Model</label>
                                <select id="cf-text-model" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                                    <option value="@cf/meta/llama-3-8b-instruct" selected>Llama 3 8B (Fast)</option>
                                    <option value="@cf/meta/llama-3.1-8b-instruct">Llama 3.1 8B (Smart)</option>
                                    <option value="@cf/meta/llama-3.2-1b-instruct">Llama 3.2 1B (Turbo)</option>
                                </select>
                            </div>
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Scanner Model</label>
                                <select id="cf-vision-model" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                                    <option value="@cf/unum/uform-gen2-qwen-500m" selected>Qwen 500M (Reliable)</option>
                                    <option value="@cf/meta/llama-3.2-11b-vision-instruct">Llama 3.2 Vision (Unstable)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="puter-repair-box" class="mt-2 hidden bg-gray-900/80 p-2 rounded border border-red-900/50">
                        <label class="text-[10px] text-red-400 font-bold uppercase block mb-1">
                            ⚠️ PWA Auth Fix (Required Once)
                        </label>
                        <div class="flex gap-1">
                            <div class="relative flex-1">
                                <input type="password" id="puter-token-input" placeholder="Paste token here..." 
                                    class="w-full bg-black border border-gray-700 rounded px-2 py-1 pr-8 text-xs text-white focus:border-red-500 outline-none font-mono transition-colors">
                                <button onclick="togglePasswordVisibility('puter-token-input', this)" class="absolute right-1 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-0.5 rounded transition-colors focus:outline-none">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                                </button>
                            </div>
                            <button onclick="savePuterToken()" class="bg-red-900/50 border border-red-700 text-red-200 px-3 py-1 rounded text-xs font-bold hover:bg-red-800">
                                SAVE
                            </button>
                        </div>
                    </div>

                    <div id="puter-settings-group" class="hidden space-y-2">
                        <div id="puter-status-bar" class="flex justify-between items-center px-3 py-2 bg-blue-900/20 border border-blue-500/30 rounded-lg mb-2 hidden transition-all">
                            <div class="flex flex-col">
                                <div class="flex items-center gap-2">
                                    <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                                    <span id="puter-username" class="text-[9px] font-bold text-blue-300 font-mono tracking-wider">LOADING...</span>
                                </div>
                                <div class="text-[8px] text-gray-400 mt-0.5 font-mono">
                                    TOTAL SPEND: <span id="puter-total-cost" class="text-theme-400 font-bold">$0.0000</span>
                                </div>
                            </div>
                            <button onclick="PuterManager.checkStatus()" class="text-[8px] font-bold text-blue-400 hover:text-white border border-blue-500/30 px-2 py-1 rounded hover:bg-blue-500/20 transition-colors">REFRESH</button>
                        </div>

                        <div id="puter-usage-box" class="hidden bg-gray-900/80 p-2 rounded-lg border border-gray-700 mb-2">
                            <div class="flex justify-between items-center mb-1 pb-1 border-b border-gray-700">
                                <span class="text-[8px] font-bold text-gray-500 uppercase">Service Breakdown</span>
                                <span class="text-[8px] text-gray-600 font-mono">Microcents</span>
                            </div>
                            <div id="puter-usage-details" class="space-y-1 text-[9px] font-mono text-gray-400 max-h-24 overflow-y-auto scrollbar-thin pr-1">
                            </div>
                        </div>

                        <div class="space-y-1">
                            <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Select Model</label>
                            <select id="puter-model" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 font-mono">
                                <option value="black-forest-labs/FLUX.1-schnell" selected>FLUX.1 Schnell (Fast)</option>
                                <option value="black-forest-labs/FLUX.1-pro">FLUX.1 Pro (High Quality)</option>
                                <option value="black-forest-labs/FLUX.1.1-pro">FLUX.1.1 Pro (Ultra Detail)</option>
                                <option value="black-forest-labs/FLUX.1-dev">FLUX.1 Dev</option>
                                
                                <option value="google/imagen-4.0-ultra">Imagen 4.0 Ultra (Photorealism)</option>
                                <option value="google/imagen-4.0-fast">Imagen 4.0 Fast</option>
                                <option value="google/imagen-4.0-preview">Imagen 4.0 Preview</option>
                                <option value="gemini-2.5-flash-image-preview">Gemini 2.5 Flash Image</option>
                                <option value="google/flash-image-2.5">Google Flash Image 2.5</option>

                                <option value="dall-e-3">DALL-E 3</option>
                                <option value="gpt-image-1">GPT Image 1.0</option>
                                <option value="gpt-image-1.5">GPT Image 1.5</option>
                                <option value="gpt-image-1-mini">GPT Image 1 Mini</option>

                                <option value="ideogram/ideogram-3.0">Ideogram 3.0 (Best Text)</option>
                                <option value="ByteDance-Seed/Seedream-4.0">Seedream 4.0 (4K Native)</option>
                                
                                <option disabled>──────────────</option>

                                <option value="RunDiffusion/Juggernaut-pro-flux">Juggernaut Pro Flux</option>
                                <option value="Rundiffusion/Juggernaut-Lightning-Flux">Juggernaut Lightning Flux</option>
                                <option value="black-forest-labs/FLUX.1-kontext-max">FLUX.1 Kontext Max</option>
                                <option value="black-forest-labs/FLUX.1-kontext-pro">FLUX.1 Kontext Pro</option>
                                <option value="black-forest-labs/FLUX.1-kontext-dev">FLUX.1 Kontext Dev</option>
                                <option value="black-forest-labs/FLUX.1-Canny-pro">FLUX.1 Canny Pro</option>
                                <option value="black-forest-labs/FLUX.1-dev-lora">FLUX.1 Dev LoRA</option>
                                <option value="black-forest-labs/FLUX.1-krea-dev">FLUX.1 Krea Dev</option>
                                <option value="black-forest-labs/FLUX.1-schnell-Free">FLUX.1 Schnell Free</option>

                                <option value="ByteDance-Seed/Seedream-3.0">Seedream 3.0</option>
                                <option value="HiDream-ai/HiDream-I1-Full">HiDream I1 Full</option>
                                <option value="HiDream-ai/HiDream-I1-Fast">HiDream I1 Fast</option>
                                <option value="HiDream-ai/HiDream-I1-Dev">HiDream I1 Dev</option>
                                <option value="Lykon/DreamShaper">DreamShaper (Lykon)</option>
                                <option value="Qwen/Qwen-Image">Qwen Image</option>
                                <option value="stabilityai/stable-diffusion-3-medium">SD3 Medium</option>
                                <option value="stabilityai/stable-diffusion-xl-base-1.0">SDXL Base 1.0</option>
                                <option value="dall-e-2">DALL-E 2</option>
                            </select>
                        </div>
                    </div>

                    <div id="pollination-settings-group" class="hidden space-y-2">
                        <div class="relative w-full">
                            <input type="password" id="poll-api-key" placeholder="Member Key (Optional)" class="w-full p-2 pr-10 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 transition-colors">
                            <button onclick="togglePasswordVisibility('poll-api-key', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                            </button>
                        </div>
                        
                        <select id="poll-model-select" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            <option value="flux">Flux</option>
                            <option value="flux-realism">Flux Realism</option>
                            <option value="flux-anime">Flux Anime</option>
                            <option value="turbo">Turbo</option>
                        </select>

                        <input type="number" id="poll-seed" placeholder="Random Seed" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">

                        <div class="grid grid-cols-3 gap-2">
                            <label class="flex flex-col items-center justify-center gap-1 p-2 rounded-lg bg-gray-800/50 border border-gray-700 w-full cursor-pointer hover:bg-gray-700/50 transition-colors">
                                <span class="text-[8px] font-bold text-gray-400 uppercase tracking-wider">Enhance</span>
                                <input type="checkbox" id="poll-enhance" class="accent-theme-500 w-4 h-4">
                            </label>
                            
                            <label class="flex flex-col items-center justify-center gap-1 p-2 rounded-lg bg-gray-800/50 border border-gray-700 w-full cursor-pointer hover:bg-gray-700/50 transition-colors">
                                <span class="text-[8px] font-bold text-gray-400 uppercase tracking-wider">No Logo</span>
                                <input type="checkbox" id="poll-nologo" checked class="accent-theme-500 w-4 h-4">
                            </label>
                            
                            <label class="flex flex-col items-center justify-center gap-1 p-2 rounded-lg bg-gray-800/50 border border-gray-700 w-full cursor-pointer hover:bg-gray-700/50 transition-colors">
                                <span class="text-[8px] font-bold text-gray-400 uppercase tracking-wider">Safe</span>
                                <input type="checkbox" id="poll-safe" checked class="accent-theme-500 w-4 h-4">
                            </label>
                        </div>
                    </div>

                    <div id="huggingface-settings-group" class="hidden space-y-2">
                        <div class="relative w-full">
                            <input type="password" id="hf-token" placeholder="Hugging Face Access Token (Required)" class="w-full p-2 pr-10 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 font-mono transition-colors">
                            <button onclick="togglePasswordVisibility('hf-token', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                            </button>
                        </div>
                        
                        <div class="space-y-1">
                            <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Model Selection</label>
                            <select id="hf-preset-select" onchange="document.getElementById('hf-model-input').value = this.value; savePrefs();" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 font-mono">
                                <option value="" disabled selected>-- Choose a Preset --</option>
                                <option value="black-forest-labs/FLUX.1-dev">FLUX.1 Dev (Best Quality)</option>
                                <option value="black-forest-labs/FLUX.1-schnell">FLUX.1 Schnell (Fast)</option>
                                <option value="stabilityai/stable-diffusion-3.5-large">SD 3.5 Large</option>
                                <option value="stabilityai/stable-diffusion-xl-base-1.0">SDXL Base 1.0</option>
                                <option value="runwayml/stable-diffusion-v1-5">SD 1.5 (Classic)</option>
                                <option value="prompthero/openjourney-v4">OpenJourney v4</option>
                                <option value="openskyml/dalle-3-xl">DALL-E 3 XL (Community)</option>
                            </select>
            
                            <input type="text" id="hf-model-input" placeholder="or paste repo/model_id" class="w-full p-2 rounded-lg bg-gray-900/50 text-theme-400 border border-gray-700 text-xs outline-none focus:border-theme-500 font-mono placeholder-gray-600">
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2">
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Guidance</label>
                                <input type="number" id="hf-guidance" placeholder="7.5" value="7.5" step="0.5" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Steps</label>
                                <input type="number" id="hf-steps" placeholder="25" value="25" min="1" max="50" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                            <div class="space-y-1">
                                <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Seed</label>
                                <input type="text" id="hf-seed" placeholder="Random" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500">
                            </div>
                        </div>
                    </div>

                    <div id="freepik-settings-group" class="hidden space-y-4 p-3 bg-gray-800/60 rounded-2xl border border-gray-700/50 shadow-inner">
                        <div class="space-y-2">
                            <label class="text-[10px] font-bold text-theme-400 uppercase tracking-widest ml-1">Freepik API Access</label>
                            <div class="relative w-full">
                                <input type="password" id="freepik-api-key" placeholder="x-freepik-api-key" class="w-full p-2.5 pr-10 rounded-xl bg-gray-900 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 font-mono shadow-sm transition-colors">
                                <button onclick="togglePasswordVisibility('freepik-api-key', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-2 mt-2">
                            <div class="space-y-1">
                                <label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Core Model</label>
                                <select id="freepik-model-select" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-theme-500 cursor-pointer">
                                    <option value="flux-pro-v1-1">Flux 1.1 Pro</option>
                                    <option value="mystic">Mystic (4K)</option>
                                    <option value="flux-dev">Flux Dev</option>
                                    <option value="classic-fast">Classic Fast</option>
                                </select>
                            </div>
                            <div class="space-y-1">
                                <label class="text-[9px] font-bold text-gray-400 uppercase ml-1">Mystic Resolution</label>
                                <select id="freepik-resolution-select" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-theme-500">
                                    <option value="1k">1K (Standard)</option>
                                    <option value="2k" selected>2K (High Detail)</option>
                                    <option value="4k">4K (Ultra HD)</option>
                                </select>
                            </div>
                            <div class="space-y-1">
                                <label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Safety Filter</label>
                                <select id="freepik-safety-select" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-theme-500">
                                    <option value="1">Strict (1)</option>
                                    <option value="3">Moderate (3)</option>
                                    <option value="6" selected>None (6)</option>
                                    <option value="5">Relaxed (5)</option>
                                </select>
                            </div>
                        </div>

                        <div class="border-t border-gray-700/50 pt-3 space-y-2">
                            <div class="flex justify-between items-center mb-1">
                                <label class="text-[10px] font-bold text-gray-400 uppercase tracking-widest ml-1">Generation Tuning</label>
                                <label class="flex items-center gap-1.5 cursor-pointer bg-gray-900/50 px-2 py-1 rounded-md border border-gray-700">
                                    <input type="checkbox" id="freepik-upsampling" class="w-3 h-3 accent-theme-500">
                                    <span class="text-[8px] font-extrabold text-gray-300 uppercase">AI Prompt Enhance</span>
                                </label>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-2">
                                <div class="space-y-1">
                                    <label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Styling Mode (Fast)</label>
                                    <select id="freepik-style-select" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-theme-500">
                                        <option value="">Auto</option>
                                        <option value="photo">Photorealistic</option>
                                        <option value="digital-art">Digital Art</option>
                                        <option value="3d">3D Render</option>
                                        <option value="painting">Painting</option>
                                        <option value="low-poly">Low Poly</option>
                                        <option value="pixel-art">Pixel Art</option>
                                        <option value="anime">Anime</option>
                                        <option value="cyberpunk">Cyberpunk</option>
                                        <option value="comic">Comic Book</option>
                                        <option value="vintage">Vintage</option>
                                        <option value="cartoon">Cartoon</option>
                                        <option value="vector">Vector</option>
                                        <option value="studio-shot">Studio Shot</option>
                                        <option value="dark">Dark / Moody</option>
                                        <option value="sketch">Sketch</option>
                                        <option value="mockup">Mockup</option>
                                        <option value="2000s-phone">2000s Phone</option>
                                        <option value="70s-vibe">70s Vibe</option>
                                        <option value="watercolor">Watercolor</option>
                                        <option value="art-nouveau">Art Nouveau</option>
                                        <option value="origami">Origami</option>
                                        <option value="surreal">Surreal</option>
                                        <option value="fantasy">Fantasy</option>
                                        <option value="traditional-japan">Traditional Japan</option>
                                    </select>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Guidance (0-2)</label>
                                    <input type="number" id="freepik-guidance" value="1.0" min="0" max="2" step="0.1" class="w-full p-2 rounded-lg bg-gray-900 text-xs border border-gray-700 text-theme-400 font-mono">
                                </div>
                            </div>
                        </div>

                        <div class="border-t border-purple-500/30 pt-3 space-y-2 bg-purple-900/5 p-2 rounded-xl border border-purple-900/20">
                            <label class="text-[10px] font-bold text-purple-400 uppercase tracking-widest block mb-1">Magnific Upscale Mode</label>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <div class="space-y-1">
                                    <label class="text-[8px] font-bold text-gray-500 uppercase ml-1">Optimized For</label>
                                    <select id="upscale-opt" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-[10px]">
                                        <option value="standard">Standard</option>
                                        <option value="films_n_photography" selected>Film & Photo</option>
                                        <option value="hard_portraits">Hard Portraits</option>
                                        <option value="nature_n_landscapes">Landscapes</option>
                                        <option value="3d_renders">3D Renders</option>
                                    </select>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[8px] font-bold text-gray-500 uppercase ml-1">Engine</label>
                                    <select id="upscale-engine" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-[10px]">
                                        <option value="automatic">Automatic</option>
                                        <option value="magnific_sharpy">Sharpy (Crisp)</option>
                                        <option value="magnific_illusio">Illusio (Smooth)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="grid grid-cols-4 gap-2">
                                <div class="space-y-1">
                                    <label class="text-[7px] text-center font-bold text-gray-500 uppercase block">Creativity</label>
                                    <input type="number" id="upscale-creativity" value="0" min="-10" max="10" class="w-full p-1.5 bg-black border border-gray-800 rounded text-center text-[10px] text-purple-400 font-mono">
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[7px] text-center font-bold text-gray-500 uppercase block">Resemblance</label>
                                    <input type="number" id="upscale-resemblance" value="10" min="-10" max="10" class="w-full p-1.5 bg-black border border-gray-800 rounded text-center text-[10px] text-purple-400 font-mono">
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[7px] text-center font-bold text-gray-500 uppercase block">HDR</label>
                                    <input type="number" id="upscale-hdr" value="2" min="-10" max="10" class="w-full p-1.5 bg-black border border-gray-800 rounded text-center text-[10px] text-purple-400 font-mono">
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[7px] text-center font-bold text-gray-500 uppercase block">Fractality</label>
                                    <input type="number" id="upscale-fractality" value="0" min="-10" max="10" class="w-full p-1.5 bg-black border border-gray-800 rounded text-center text-[10px] text-purple-400 font-mono">
                                </div>
                            </div>
                        </div>
                    </div>
					
					<div id="horde-settings-group" class="hidden space-y-4 p-3 bg-yellow-900/10 rounded-2xl border border-yellow-700/30 shadow-inner">
							<div class="flex justify-between items-center w-full border-b border-yellow-500/10 pb-2">
								<label class="text-[10px] font-bold text-yellow-500 uppercase tracking-widest ml-1">AI Horde Access</label>
								<span id="horde-kudos-label" class="text-[9px] text-gray-600 font-mono cursor-pointer hover:text-yellow-400 transition-colors" title="Click to refresh" onclick="checkHordeKudos()">Checking...</span>
							</div>
							
							<div class="relative w-full">
								<input type="password" id="horde-api-key" placeholder="API Key (Default: 0000000000)" 
									   class="w-full p-2.5 pr-10 rounded-xl bg-gray-900 text-gray-200 border border-gray-700 text-xs outline-none focus:border-yellow-500 font-mono shadow-sm transition-colors"
									   onchange="checkHordeKudos()"> <button onclick="togglePasswordVisibility('horde-api-key', this)" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-white p-1 rounded-md transition-colors focus:outline-none">
									<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
								</button>
							</div>
							<p class="text-[9px] text-gray-500 ml-1 flex justify-between">
								<span>Use '0000000000' for anonymous mode.</span>
								<a href="https://stablehorde.net/register" target="_blank" class="text-yellow-600 hover:text-yellow-400 underline">Register</a>
							</p>
							
							<div class="space-y-1">
								<div class="flex justify-between">
									<label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Model Selection</label>
									<span class="text-[9px] text-yellow-600 cursor-pointer hover:underline" onclick="updateHordeModels()">Refresh List ↻</span>
								</div>
								<select id="horde-model-select" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-yellow-500 cursor-pointer scrollbar-thin">
									<option value="AlbedoBase XL (SDXL)">AlbedoBase XL (Default)</option>
									<option value="ICBINP - I Can't Believe It's Not Photography">ICBINP (Photo)</option>
								</select>
							</div>

							<div class="grid grid-cols-2 gap-2">
								<div class="space-y-1">
									<label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Steps (Max 50)</label>
									<input type="number" id="horde-steps" value="30" min="1" max="50" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-yellow-500">
								</div>
								<div class="space-y-1">
									<label class="text-[9px] font-bold text-gray-500 uppercase ml-1">Guidance (CFG)</label>
									<input type="number" id="horde-cfg" value="7" step="0.5" min="1" max="20" class="w-full p-2 rounded-lg bg-gray-900 text-white border border-gray-700 text-xs outline-none focus:border-yellow-500">
								</div>
							</div>
						</div>
                    <label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-1 ml-1">SCAN AND FIX PROVIDER</label>
                    
                    <div class="grid grid-cols-3 gap-1 p-1 bg-gray-900/50 rounded-xl border border-gray-700/50 mb-3">
                        <button id="help-auto" class="py-1.5 px-2 rounded-lg text-xs font-bold transition-all bg-theme-600 text-white shadow-lg" onclick="setHelper('auto')">AUTO</button>
                        <button id="help-gemini" class="py-1.5 px-2 rounded-lg text-xs font-bold text-gray-400 hover:text-white transition-all" onclick="setHelper('gemini')">GEMINI</button>
                        <button id="help-cloudflare" class="py-1.5 px-2 rounded-lg text-xs font-bold text-gray-400 hover:text-white transition-all" onclick="setHelper('cloudflare')">C.FLARE</button>
                    </div> 
                    <label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-1 ml-1 mt-1">SCAN & FIX STYLE</label>
						<select id="scan-style-final" class="w-full p-2 rounded-lg bg-gray-900/50 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 mb-2 font-mono">
							<option value="frontal" selected>👁️ FRONTAL REALISM (Level X)</option>
							<option value="realistic" selected>✨ REALISTIC (Photo/Raw)</option>
							<option value="lexica">🎨 LEXICA (Cool/Render)</option>
							<option value="leonardo">🖌️ LEONARDO (Artistic/Painted)</option>
							<option value="seaart">♾️ seaart (Infinity/ Best View)</option>
							<option value="pixar">🧸 PIXAR (Disney/3D)</option>
							<option value="rev_animated">🌟 REV ANIMATED (2.5D/Fantasy)</option> 
							<option value="style_clone">🧬 STYLE CLONER (Copy Aesthetics)</option>
							<option value="digital">🖥️ Digital Art</option> 
						</select>
                    <label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-0 ml-1 mt-1 leading-none">SAFETY LEVEL</label>
                    <div class="grid grid-cols-2 gap-1 p-0.5 bg-gray-900/50 rounded-lg border border-gray-700/50 mb-1">
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="nsfw" data-value="false">SFW MODE</button>
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="nsfw" data-value="true">NSFW MODE</button>
                    </div>

                    <label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-0 ml-1 leading-none">GENERATION MODE</label>
                    <div class="grid grid-cols-2 gap-1 p-0.5 bg-gray-900/50 rounded-lg border border-gray-700/50 mb-1">
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="mode" data-value="manual">MANUAL</button>
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="mode" data-value="random">RANDOM</button>
                    </div>

                    <label class="block text-[10px] font-bold text-theme-400 uppercase tracking-widest mb-0 ml-1 leading-none">SUBJECT IDENTITY</label>
                    <div class="grid grid-cols-3 gap-1 p-0.5 bg-gray-900/50 rounded-lg border border-gray-700/50 mb-2">
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="subject" data-value="female">FEMALE</button>
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="subject" data-value="male">MALE</button>
                        <button class="config-btn py-1 rounded-md text-[10px] font-bold transition-all" data-type="subject" data-value="scenery">SCENERY</button>
                    </div>

                    <button id="start-btn" class="w-full py-3 rounded-xl bg-gradient-to-r from-theme-600 to-theme-400 text-white font-extrabold text-sm shadow-lg shadow-theme-500/40 hover:shadow-theme-500/60 transform active:scale-95 transition-all mt-2 border-t border-white/20">
                        START GENERATOR
                    </button>
                    
                    <div id="setup-gallery-container" class="hidden mt-4 mb-1 transition-all duration-300">
                        <div class="flex justify-between items-center mb-2 px-1 cursor-pointer select-none hover:bg-white/5 rounded-lg p-1 transition-colors" onclick="GalleryToggle.toggle('setup')">
                            <div class="flex items-center gap-2">
                                <svg id="gal-chevron-setup" class="w-3 h-3 text-gray-500 transition-transform duration-300 -rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                <div class="text-[10px] font-bold text-gray-500 uppercase">Recent Generations</div>
                            </div>
                            <div class="flex gap-3" onclick="event.stopPropagation()">
                                <button id="setup-view-gallery-btn" class="text-[10px] font-bold text-theme-400 hover:text-white flex items-center gap-1">VIEW ALL</button>
                                <button id="setup-clear-gallery-btn" class="text-[10px] text-red-400 hover:text-red-300">CLEAR</button>
                            </div>
                        </div>
                        <div id="gal-content-setup" class="hidden overflow-hidden transition-all duration-300">
                            <div id="setup-gallery-strip" class="flex gap-2 overflow-x-auto no-scrollbar pb-2 min-h-[70px]"></div>
                        </div>
                    </div>
                </div> 
            </div> 
				<div id="app-screen" class="hidden space-y-6 animate-fade-in">
                <button id="back-btn" class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-gray-800/50 border border-gray-700 text-xs font-bold text-gray-400 hover:text-white hover:bg-gray-700 transition-colors">CONFIG</button>
                <div id="global-settings" class="glass-panel rounded-xl p-3 border border-gray-700/50"></div>
                <div id="visualizer-container" class="mt-4 animate-fade-in relative group">
    
					<div id="img-loading" class="hidden p-12 text-center">
						<div class="w-12 h-12 border-4 border-theme-900 border-t-theme-400 rounded-full animate-spin mx-auto mb-4"></div>
						<p class="text-xs font-mono text-theme-400 animate-pulse">GENERATING VISUAL...</p>
					</div>
					
					<img id="generated-image" class="hidden w-full h-auto rounded-xl shadow-2xl border border-white/10 relative z-10" src="" alt="Generated Visual">

					<div id="click-hint" class="hidden md:flex absolute inset-0 items-center justify-center bg-black/20 backdrop-blur-[2px] opacity-0 group-hover:opacity-100 transition-all duration-300 pointer-events-none z-20">
						<span class="px-5 py-2.5 bg-black/60 backdrop-blur-md rounded-full text-white text-[10px] font-bold border border-white/20 shadow-2xl tracking-widest uppercase flex items-center gap-2 transform translate-y-4 group-hover:translate-y-0 transition-transform duration-300">
							<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
							Click for Options
						</span>
					</div>

					<div class="md:hidden absolute bottom-3 left-0 right-0 flex justify-center pointer-events-none z-20">
						<span class="px-3 py-1.5 bg-black/60 backdrop-blur-md rounded-full text-white/80 text-[9px] font-bold border border-white/10 shadow-lg tracking-widest uppercase">
							Tap for Options
						</span>
					</div>

				</div>
                <div id="gallery-container" class="hidden mt-2 mb-3 transition-all duration-300">
                    <div class="flex justify-between items-center mb-2 px-1 cursor-pointer select-none hover:bg-white/5 rounded-lg p-1 transition-colors" onclick="GalleryToggle.toggle('main')">
                        <div class="flex items-center gap-2">
                            <svg id="gal-chevron-main" class="w-3 h-3 text-gray-500 transition-transform duration-300 -rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            <div class="text-[10px] font-bold text-gray-500 uppercase">Persistent Gallery</div>
                        </div>
                        <div class="flex gap-3" onclick="event.stopPropagation()">
                            <button id="view-gallery-btn" class="text-[10px] font-bold text-theme-400 hover:text-white flex items-center gap-1">VIEW GALLERY</button>
                            <button id="clear-gallery-btn" class="text-[10px] text-red-400 hover:text-red-300">CLEAR ALL</button>
                        </div>
                    </div>
                    <div id="gal-content-main" class="hidden overflow-hidden transition-all duration-300">
                        <div id="gallery-strip" class="flex gap-2 overflow-x-auto no-scrollbar pb-2 min-h-[70px]"></div>
                    </div>
					<input type="file" id="img-scan-input" accept="image/*" class="hidden"> <input type="file" id="img2img-upload" accept="image/*" class="hidden">
					<div id="action-grid" class="grid grid-cols-4 gap-1.5 mt-4">
    
							<button onclick="openGeminiWeb()" class="h-10 rounded-xl bg-blue-600/20 hover:bg-blue-600/40 border border-blue-500/30 text-blue-200 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Open Gemini Web">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg>
								<span>GEM-WEB</span>
							</button>

							<button id="gemini-import-btn" class="h-10 rounded-xl bg-green-600/20 hover:bg-green-600/40 border border-green-500/30 text-green-200 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Import from Gemini">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
								<span>GEM-IMP</span>
							</button>

							<button onclick="openGrokWeb()" class="h-10 rounded-xl bg-gray-600/20 hover:bg-gray-600/40 border border-gray-500/30 text-gray-200 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Open Grok Web">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
								<span>GROK-WEB</span>
							</button>

							<button id="grok-import-btn" class="h-10 rounded-xl bg-gray-700/30 hover:bg-gray-600 border border-gray-500/30 text-gray-300 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Import from Grok">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
								<span>GROK-IMP</span>
							</button>

							<button onclick="openChatGPTWeb()" class="h-10 rounded-xl bg-teal-600/20 hover:bg-teal-600/40 border border-teal-500/30 text-teal-200 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Open ChatGPT">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
								<span>GPT-WEB</span>
							</button>

							<button id="chatgpt-import-btn" class="h-10 rounded-xl bg-teal-700/30 hover:bg-teal-600 border border-teal-500/30 text-teal-300 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all active:scale-95" title="Import from ChatGPT">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
								<span>GPT-IMP</span>
							</button>

							<button id="paste-btn" class="h-10 rounded-xl bg-white/5 hover:bg-white/10 border border-white/10 text-gray-400 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg>
								<span>PASTE</span>
							</button>

							<button id="copy-btn" class="h-10 rounded-xl bg-white/5 hover:bg-white/10 border border-white/10 text-gray-400 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg>
								<span>COPY</span>
							</button>

							<button id="scan-btn" class="col-span-2 h-10 rounded-xl bg-blue-500/10 hover:bg-blue-500/20 border border-blue-500/20 text-blue-400 hover:text-white flex items-center justify-center gap-1 text-[9px] font-bold transition-all">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
								<span>SCAN IMAGE</span>
							</button>

							<button id="enhance-btn" class="col-span-2 h-10 rounded-xl bg-purple-900/40 border border-purple-500/30 text-purple-300 hover:bg-purple-900/60 transition-all text-[10px] font-bold flex items-center justify-center gap-2">
								<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
								MAGIC FIX
							</button>

							<button id="img2img-btn" class="col-span-4 h-11 rounded-xl bg-emerald-900/40 border border-emerald-500/30 text-emerald-300 hover:bg-emerald-900/60 transition-all text-[11px] font-bold tracking-wider shadow-lg flex items-center justify-center gap-2">
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
								GENERATE (IMG 2 IMG)
							</button>
						</div>
                </div>
                <div id="manual-container" class="space-y-3"></div>
                <div id="random-message" class="hidden glass-panel rounded-2xl p-12 text-center border-dashed border-2 border-gray-700"><h3 class="text-xl font-bold text-white mb-2">Generator Active</h3></div>
                <div id="result-area" class="hidden animate-fade-in pt-4 pb-10">
                     <div class="flex items-center gap-2 text-xs font-bold text-gray-500 uppercase tracking-widest ml-1 mb-3"><span>Generated Output</span><div class="h-px flex-grow bg-gray-800"></div></div>
                    <div class="relative group"><textarea id="output-text" class="w-full min-h-[8rem] p-4 bg-gray-900/95 rounded-xl border border-gray-700 text-sm text-gray-300 font-mono focus:outline-none focus:border-theme-500 transition-colors resize-none leading-relaxed overflow-hidden" placeholder="Prompt will appear here..."></textarea></div>

                    <div class="mt-2">
                        <details class="group" > <summary class="flex items-center gap-2 cursor-pointer p-2 rounded-lg hover:bg-gray-800/50 transition-colors list-none text-[10px] font-bold text-gray-500 uppercase tracking-widest">
                                <svg class="w-4 h-4 transition-transform group-open:rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                                <span>Negative Prompt</span>
                            </summary>
                            <textarea id="negative-prompt" class="w-full mt-2 p-3 bg-red-900/10 rounded-lg border border-red-900/30 text-xs text-red-200 font-mono focus:outline-none focus:border-red-500/50 resize-none h-16 transition-all">text, watermark:1.4),beard, (deformed, distorted, disfigured:1.3),  mutated face, face out of proportion, incomplete face, pixellated face, distorted eyes, pixellated eyes, poorly drawn, bad anatomy, wrong anatomy, extra limb, missing limb, floating limbs, (mutated hands and fingers:1.4), disconnected limbs, mutation, mutated, ugly, disgusting, blurry, amputation, smooth, more than one body , more than one face,, (stacked torso:1.5), (stacked bodies:1.5), more than 2 arms, more than 4 fingers\u00a0in\u00a0each\u00a0hand, dull, blurred, desaturated, distorted face, blurred face, anime, cloths, bra, top, blond, elongated body, bad proportions, Extra fingers, Bad hands, Bad anatomy, Missing limbs, Poorly drawn hands, Deformed, Mutated, Too many fingers, Extra limbs, Mutant, Body horror, white hair. blonde hair, nude, elongated neck, asymmetrical eyes, ugly eyes, eyes out of proportion, elongated neck, face closeup, unsymmetrical eyes,criplped fingers, more than 1girl, more than 1person,more than 2arms, beard, moustache</textarea>
                        </details>
                    </div>

                    
						
                    </div>
                <div id="paste-preview-area" class="hidden mt-4 flex justify-center animate-fade-in">
                        <div class="relative p-1.5 bg-gray-800/60 rounded-xl border border-theme-500/30 shadow-2xl backdrop-blur-md group">
                            <div class="absolute -top-3 left-1/2 -translate-x-1/2 bg-theme-900/80 text-theme-400 text-[9px] font-bold px-3 py-0.5 rounded-full border border-theme-500/30 shadow-lg tracking-widest uppercase pointer-events-none">
                                Input Image
                            </div>
                            
                            <img id="paste-preview-img" class="h-24 w-auto object-contain rounded-lg border border-white/5 cursor-pointer hover:opacity-80 transition-opacity" title="Click to View Fullscreen">
                            
                            <button onclick="document.getElementById('paste-preview-area').classList.add('hidden')" class="absolute -top-2 -right-2 bg-gray-900 text-gray-400 hover:text-white rounded-full p-1 border border-gray-700 shadow-md transition-colors">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                        </div>
                    </div>
					
				</div>
				
            <details id="raw-data-container" class="mt-3 group hidden">
                        <summary class="list-none cursor-pointer flex items-center gap-2 text-[10px] font-bold tracking-widest text-gray-600 hover:text-purple-400 transition-colors select-none">
                            <div class="w-4 h-4 rounded bg-white/5 flex items-center justify-center transition-transform group-open:rotate-90">
                                <svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7"></path></svg>
                            </div>
                            <span>FULL GENERATION DATA</span>
                            <span class="ml-auto text-[9px] opacity-50 font-normal" id="raw-data-source">SOURCE: UNKNOWN</span>
                        </summary>
                        
                        <div class="mt-2 relative">
                            <textarea id="raw-metadata-box" class="w-full h-40 bg-black/40 border border-white/10 rounded-xl p-3 text-[9px] leading-relaxed font-mono text-green-400/80 focus:outline-none focus:border-purple-500/50 resize-y scrollbar-hide" readonly placeholder="Raw metadata..."></textarea>
                            
                            <button onclick="navigator.clipboard.writeText(document.getElementById('raw-metadata-box').value); showToast('Raw Data Copied!', 'success')" class="absolute top-2 right-2 p-1.5 rounded-lg bg-white/10 hover:bg-white/20 text-white transition-all backdrop-blur-md">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                            </button>
                        </div>
                    </details>
			</div>
        </div>
		
    </main>
    <div id="slideshow-screen" class="fixed inset-0 bg-black z-[100] hidden flex-col">
        <div class="absolute inset-0 flex items-center justify-center bg-black transition-colors duration-500" id="slide-stage">
            <div id="slide-container" class="w-full h-full flex items-center justify-center relative"></div>
        </div>
        <div id="slide-top-bar" class="absolute top-0 left-0 right-0 p-4 z-50 flex justify-between items-start transition-opacity duration-500 bg-gradient-to-b from-black/80 to-transparent">
            <div id="slide-provider-badge" class="px-3 py-1.5 bg-gray-900/60 backdrop-blur-md rounded-full border border-white/10 text-[10px] font-bold text-gray-300 cursor-pointer flex items-center gap-2 hover:bg-gray-800/80 transition-all shadow-lg"><span class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></span><span id="slide-prov-text">UNKNOWN</span></div>
            <div class="flex gap-2">
                <button onclick="toggleFullScreen()" class="p-2 bg-gray-900/60 backdrop-blur-md rounded-full text-white/70 hover:text-white border border-white/10 transition-all shadow-lg"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg></button>
                <button id="close-slideshow-btn" class="p-2 bg-red-900/60 backdrop-blur-md rounded-full text-red-200 hover:text-white border border-red-500/20 transition-all shadow-lg hover:bg-red-600"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
            </div>
        </div>
        
        <button id="prev-slide-btn" class="absolute left-4 top-1/2 -translate-y-1/2 p-4 rounded-full bg-black/30 hover:bg-black/50 text-white backdrop-blur-md border border-white/10 transition-all z-40 shadow-lg group">
            <svg class="w-8 h-8 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
        </button>
        
        <button id="next-slide-btn" class="absolute right-4 top-1/2 -translate-y-1/2 p-4 rounded-full bg-black/30 hover:bg-black/50 text-white backdrop-blur-md border border-white/10 transition-all z-40 shadow-lg group">
            <svg class="w-8 h-8 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
        </button>

        <div id="slide-bottom-bar" class="absolute bottom-0 left-0 right-0 p-4 pb-8 bg-gradient-to-t from-black/90 via-black/60 to-transparent z-50 transition-opacity duration-500 flex flex-col gap-3">
            <div class="flex justify-between items-center">
                <div class="flex gap-2">
                    <button id="slide-copy-btn" class="px-3 py-2 bg-white/10 hover:bg-white/20 backdrop-blur-md rounded-lg border border-white/10 text-[10px] font-bold text-white flex items-center gap-1 transition-colors shadow-lg">COPY</button>
                    <button id="slide-share-btn" class="px-3 py-2 bg-theme-600 hover:bg-theme-500 backdrop-blur-md rounded-lg border border-white/10 text-[10px] font-bold text-white flex items-center gap-1 transition-colors shadow-lg">SHARE</button>
                    <button id="slide-save-btn" class="px-3 py-2 bg-white/10 hover:bg-white/20 backdrop-blur-md rounded-lg border border-white/10 text-[10px] font-bold text-white flex items-center gap-1 transition-colors shadow-lg">SAVE</button>
                </div>
                
                <button id="play-pause-btn" class="w-10 h-10 rounded-full bg-white text-black flex items-center justify-center shadow-[0_0_20px_rgba(255,255,255,0.3)] hover:scale-105 transition-all">
                    <svg id="play-icon" class="w-4 h-4 ml-0.5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="pause-icon" class="w-4 h-4 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                </button>
            </div>

            <div class="grid grid-cols-3 gap-2">
                <div class="space-y-1">
                    <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Effect</label>
                    <select id="slide-effect" class="w-full bg-gray-900/80 text-white/90 text-[10px] border border-white/10 rounded-lg px-2 py-2 outline-none focus:border-theme-500 backdrop-blur-md">
                        <option value="fx-fade">Fade</option><option value="fx-slide">Slide</option><option value="fx-elevator">Elevator</option><option value="fx-zoom">Zoom</option><option value="fx-elastic">Elastic</option><option value="fx-flip">Flip</option><option value="fx-cube">Cube</option><option value="fx-unfold">Unfold</option>
                    </select>
                </div>

                <div class="space-y-1">
                    <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Speed</label>
                    <select id="slide-speed-select" class="w-full bg-gray-900/80 text-white/90 text-[10px] border border-white/10 rounded-lg px-2 py-2 outline-none focus:border-theme-500 backdrop-blur-md">
                        <option value="0.3s">Fast</option>
                        <option value="0.8s" selected>Normal</option>
                        <option value="1.5s">Slow</option>
                        <option value="2.5s">Cinematic</option>
                    </select>
                </div>

                <div class="space-y-1">
                    <label class="text-[8px] font-bold text-gray-400 uppercase ml-1">Duration</label>
                    <select id="slide-duration-select" class="w-full bg-gray-900/80 text-white/90 text-[10px] border border-white/10 rounded-lg px-2 py-2 outline-none focus:border-theme-500 backdrop-blur-md">
                        <option value="2000">Fast (2s)</option>
                        <option value="3000" selected>Normal (3s)</option>
                        <option value="5000">Slow (5s)</option>
                        <option value="8000">Long (8s)</option>
                    </select>
                </div>
            </div>
        </div>
        <div id="slide-prompt-overlay" class="absolute inset-0 z-[110] hidden flex items-center justify-center p-6 bg-black/95 backdrop-blur-md animate-fade-in">
            <div class="w-full max-w-lg space-y-4">
                <div class="flex justify-between items-center text-theme-400 text-xs font-bold tracking-widest uppercase"><span>Prompt Data</span><button onclick="document.getElementById('slide-prompt-overlay').classList.add('hidden')" class="text-white hover:text-red-400">CLOSE</button></div>
                <p id="slide-prompt-text" class="text-gray-300 font-mono text-sm leading-relaxed max-h-[60vh] overflow-y-auto select-text"></p>
                <button onclick="navigator.clipboard.writeText(document.getElementById('slide-prompt-text').innerText); showToast('COPIED')" class="w-full py-3 bg-white/10 hover:bg-white/20 rounded-xl text-white font-bold text-xs border border-white/10">COPY TEXT</button>
            </div>
        </div>
    </div>

    <footer id="action-bar" class="fixed bottom-0 w-full z-50 hidden pointer-events-none">
        <div class="max-w-3xl mx-auto flex justify-center items-center gap-4">
            <button id="generate-btn" class="w-auto px-8 py-3 rounded-full bg-gradient-to-r from-theme-600 to-theme-500 text-white font-bold text-xs shadow-lg flex items-center justify-center gap-2 pointer-events-auto">GENERATE</button>
            <button id="visualize-btn" class="hidden w-auto px-8 py-3 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-bold text-xs shadow-lg flex items-center justify-center gap-2 pointer-events-auto">VISUALIZE</button>
        </div>
    </footer>
			<div id="lightbox-overlay" class="fixed inset-0 z-[100] hidden flex flex-col items-center justify-center bg-black/95 backdrop-blur-xl transition-opacity duration-300">
					
					<div id="lb-prompt-overlay" class="absolute inset-0 z-[80] hidden flex items-center justify-center p-6 bg-black/95 backdrop-blur-md animate-fade-in">
						<div class="w-full max-w-lg space-y-4">
							<div class="flex justify-between items-center text-theme-400 text-xs font-bold tracking-widest uppercase">
								<span>Prompt Data</span>
								<button id="close-lb-prompt" class="text-white hover:text-red-400 transition-colors">CLOSE</button>
							</div>
							<p id="lb-prompt-text" class="text-gray-300 font-mono text-sm leading-relaxed max-h-[60vh] overflow-y-auto select-text p-4 border border-white/10 rounded-xl bg-white/5"></p>
							<button onclick="navigator.clipboard.writeText(document.getElementById('lb-prompt-text').innerText); showToast('COPIED', 'success')" class="w-full py-3 bg-white/10 hover:bg-white/20 rounded-xl text-white font-bold text-xs border border-white/10 transition-all">
								COPY TEXT
							</button>
						</div>
					</div>

					<div id="lb-provider-badge" class="absolute top-14 left-4 px-4 py-2 rounded-full bg-black/30 border border-white/10 backdrop-blur-md text-[10px] font-bold text-theme-400 tracking-widest shadow-lg z-[70] pointer-events-auto cursor-pointer hover:bg-black/50 transition-all opacity-0">
						UNKNOWN
					</div>

					<button id="lb-compare-btn" class="hidden absolute top-4 left-1/2 -translate-x-1/2 px-6 py-2 bg-purple-600/80 hover:bg-purple-500 text-white rounded-xl font-bold shadow-lg backdrop-blur-md border border-white/20 flex items-center gap-2 transition-all z-[70]">
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7M5 12h14"></path></svg>
						<span>COMPARE</span>
					</button>

					<button id="lb-delete-btn" class="absolute top-4 right-16 p-3 bg-red-500/20 hover:bg-red-500/50 text-red-200 rounded-full backdrop-blur-md transition-all group z-[70]" title="Delete Image">
						<svg class="w-6 h-6 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
						</svg>
					</button>

					<button id="lb-close-btn" class="absolute top-4 right-4 p-3 rounded-full bg-black/30 hover:bg-black/50 text-white backdrop-blur-md border border-white/10 transition-all z-[70] shadow-lg">
						<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
					</button>

					<img id="lb-image" class="block m-auto max-w-full max-h-[80vh] rounded-lg shadow-2xl cursor-zoom-in transition-all duration-500 ease-in-out transform" alt="Generated Result">

					<div id="compare-container" class="hidden absolute inset-0 z-30 flex items-center justify-center bg-black/95">
						<div id="compare-wrapper" class="relative w-full h-full max-w-screen max-h-screen flex items-center justify-center overflow-hidden select-none touch-none">
							<img id="comp-after" class="absolute inset-0 w-full h-full object-contain pointer-events-none select-none">
							<img id="comp-before" class="absolute inset-0 w-full h-full object-contain pointer-events-none select-none z-10">
							<div id="comp-slider" class="absolute top-0 bottom-0 w-0.5 bg-white/50 z-40 cursor-ew-resize flex items-center justify-center shadow-[0_0_10px_rgba(0,0,0,0.5)]" style="left: 50%;">
								<div class="w-8 h-8 bg-white rounded-full shadow-2xl flex items-center justify-center text-gray-900 ring-4 ring-black/20 backdrop-blur-sm transform hover:scale-110 transition-transform">
									<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M8 9h8M8 15h8M12 7v10"></path></svg>
								</div>
							</div>
							<div id="comp-label-left" class="absolute top-6 left-6 bg-black/50 text-white text-[10px] font-bold px-3 py-1.5 rounded-full backdrop-blur border border-white/10 z-50 tracking-widest pointer-events-none">ORIGINAL</div>
                            <div id="comp-label-right" class="absolute top-6 right-6 bg-gradient-to-r from-theme-600 to-theme-500 text-white text-[10px] font-bold px-3 py-1.5 rounded-full shadow-lg z-50 tracking-widest pointer-events-none">MAGNIFIC 4X</div>
						</div>
						<button id="close-comp-btn" class="absolute bottom-32 bg-gray-900/90 text-white px-8 py-3 rounded-full border border-gray-700 shadow-2xl hover:bg-gray-800 active:scale-95 transition-all z-50 font-bold text-xs tracking-widest backdrop-blur pointer-events-auto">
							EXIT COMPARISON
						</button>
					</div>
					<div id="lb-details" class="absolute top-20 left-4 z-[60] pointer-events-none transition-opacity duration-300"></div>
					<div id="lb-actions-bar" class="fixed bottom-8 left-0 right-0 flex flex-wrap justify-center gap-2 w-full max-w-2xl mx-auto px-4 z-[70] pointer-events-auto transition-transform duration-500">
						<button id="lb-save-jpg" class="px-4 py-2.5 rounded-xl bg-black/40 hover:bg-white/10 text-gray-300 hover:text-white backdrop-blur-md border border-white/10 shadow-lg transition-all active:scale-95 flex items-center gap-2 group">
							<svg class="w-4 h-4 opacity-70 group-hover:opacity-100" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
							<span class="text-[10px] font-bold tracking-wider">JPG</span>
						</button>
						
						<button id="lb-save-png" class="px-4 py-2.5 rounded-xl bg-black/40 hover:bg-white/10 text-blue-200 hover:text-white backdrop-blur-md border border-white/10 shadow-lg transition-all active:scale-95 flex items-center gap-2 group">
							<svg class="w-4 h-4 opacity-70 group-hover:opacity-100" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
							<span class="text-[10px] font-bold tracking-wider">PNG</span>
						</button>

						<button id="lb-share-btn" class="px-5 py-2.5 rounded-xl bg-theme-900/40 hover:bg-theme-600 text-theme-100 hover:text-white backdrop-blur-md border border-theme-500/30 shadow-lg transition-all active:scale-95 flex items-center gap-2 group">
							<svg class="w-4 h-4 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path></svg>
							<span class="text-[10px] font-bold tracking-wider">SHARE</span>
						</button>

						<button id="lb-play-slideshow" class="px-4 py-2.5 rounded-xl bg-black/40 hover:bg-white/10 text-gray-300 hover:text-white backdrop-blur-md border border-white/10 shadow-lg transition-all active:scale-95 flex items-center gap-2 group">
							<svg class="w-4 h-4 opacity-70 group-hover:opacity-100" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path></svg>
							<span class="text-[10px] font-bold tracking-wider">PLAY</span>
						</button>

						<button id="lb-upscale-trigger" class="px-5 py-2.5 rounded-xl bg-gradient-to-r from-purple-900/60 to-pink-900/60 hover:from-purple-600 hover:to-pink-600 text-purple-200 hover:text-white backdrop-blur-md border border-purple-500/30 shadow-[0_0_15px_rgba(168,85,247,0.2)] transition-all active:scale-95 flex items-center gap-2 group">
							<svg class="w-4 h-4 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
							<span class="text-[10px] font-bold tracking-wider">UPSCALE</span>
						</button>
					</div>
				</div>

	<div id="cat-overlay" class="fixed inset-0 z-[9999] bg-black hidden flex flex-col animate-fade-in">
        <div class="absolute top-0 left-0 right-0 p-6 z-[10000] flex justify-between items-start bg-gradient-to-b from-black/90 to-transparent pointer-events-none">
            <div class="px-4 py-2 bg-gray-900/80 backdrop-blur-xl rounded-full border border-white/20 text-[10px] font-bold text-gray-200 shadow-2xl pointer-events-auto"><span id="cat-provider">PROVIDER</span></div>
            <button id="close-cat-overlay-btn" class="p-3 rounded-full bg-black/30 hover:bg-red-900/60 text-white backdrop-blur-md border border-white/10 shadow-lg transition-all pointer-events-auto">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="flex-1 w-full h-full flex items-center justify-center p-0 overflow-hidden relative bg-black"><img id="cat-img" class="max-w-full max-h-full object-contain shadow-2xl" src=""></div>
        <div class="grid grid-cols-3 gap-4 pb-8 px-6 absolute bottom-0 left-0 right-0 z-[10001] bg-gradient-to-t from-black/90 to-transparent pt-12"> 
            <button id="cat-use-btn" class="py-4 rounded-xl bg-black/40 hover:bg-theme-600/60 text-white backdrop-blur-md border border-white/10 font-bold text-xs shadow-lg flex items-center justify-center gap-2 transition-all">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg> USE
            </button>
            <button id="cat-share-btn" class="py-4 rounded-xl bg-black/40 hover:bg-indigo-600/60 text-white backdrop-blur-md border border-white/10 font-bold text-xs shadow-lg flex items-center justify-center gap-2 transition-all">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path></svg> SHARE
            </button>
            <button id="cat-restore-btn" class="py-4 rounded-xl bg-black/40 hover:bg-gray-600/60 text-white backdrop-blur-md border border-white/10 font-bold text-xs shadow-lg flex items-center justify-center gap-2 transition-all">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg> SAVE
            </button>
        </div>
    </div>

    <nav id="nav-dock" class="fixed bottom-0 left-0 right-0 z-[90] pb-safe pt-1 px-2 flex justify-between items-center transition-transform duration-300 backdrop-blur-md bg-black/20 border-t border-white/5">
        <button id="nav-home" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-theme-400 opacity-100 transition-all active:scale-95" onclick="switchTab('home')">
            <div class="w-7 h-7 rounded-lg bg-theme-500/10 flex items-center justify-center group-[.active]:bg-theme-500 group-[.active]:text-white transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></div><span class="text-[8px] font-bold tracking-widest opacity-60 group-[.active]:opacity-100">CREATE</span>
        </button>
        
        <button id="nav-setup" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-gray-400 opacity-60 hover:text-white transition-all active:scale-95" onclick="switchTab('setup')">
            <div class="w-7 h-7 rounded-lg flex items-center justify-center group-[.active]:bg-theme-500 group-[.active]:text-white transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg></div><span class="text-[8px] font-bold tracking-widest">SET-UP</span>
        </button>
        
        <button id="nav-slideshow" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-gray-400 opacity-60 hover:text-white transition-all active:scale-95">
            <div class="w-7 h-7 rounded-lg flex items-center justify-center group-[.active]:bg-theme-500 group-[.active]:text-white transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div><span class="text-[8px] font-bold tracking-widest">PLAY</span>
        </button>
			<button id="nav-grid" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-gray-400 opacity-60 hover:text-white transition-all active:scale-95" onclick="switchTab('grid')">
				<div class="w-7 h-7 rounded-lg flex items-center justify-center group-[.active]:bg-theme-500 group-[.active]:text-white transition-colors">
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
				</div>
				<span class="text-[8px] font-bold tracking-widest">GRID</span>
			</button>
        <button id="nav-png-info" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-purple-400 opacity-80 hover:text-white transition-all active:scale-95">
            <div class="w-7 h-7 rounded-lg bg-purple-900/30 border border-purple-500/30 flex items-center justify-center group-hover:bg-purple-600 group-hover:text-white transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </div>
            <span class="text-[8px] font-bold tracking-widest">INFO</span>
        </button>
		<button id="nav-upscale" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-pink-400 opacity-80 hover:text-white transition-all active:scale-95">
            <div class="w-7 h-7 rounded-lg bg-pink-900/30 border border-pink-500/30 flex items-center justify-center group-hover:bg-pink-600 group-hover:text-white transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" /></svg>
            </div>
            <span class="text-[8px] font-bold tracking-widest">UPSCALE</span>
        </button>
        <button id="nav-catalogue" class="hidden nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-indigo-400 opacity-100 transition-all active:scale-95" onclick="switchTab('catalogue')">
            <div class="w-7 h-7 rounded-lg bg-indigo-900/30 border border-indigo-500/30 flex items-center justify-center group-[.active]:bg-indigo-500 group-[.active]:text-white transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"></path></svg></div><span class="text-[8px] font-bold tracking-widest">ARCHIVE</span>
        </button>
        
        <button id="nav-history" class="nav-item group flex flex-col items-center gap-0.5 p-1 min-w-[3.5rem] text-gray-400 opacity-60 hover:text-white transition-all active:scale-95" onclick="switchTab('history')">
            <div class="w-7 h-7 rounded-lg flex items-center justify-center group-[.active]:bg-theme-500 group-[.active]:text-white transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div><span class="text-[8px] font-bold tracking-widest">HISTORY</span>
        </button>
    </nav>
	<input type="file" id="upscale-file-input" accept="image/*" class="hidden">
    <input type="file" id="png-info-input" accept="image/png" class="hidden">
	<div id="retry-overlay" class="fixed inset-0 z-[200] bg-black/90 hidden flex items-center justify-center p-6 animate-fade-in backdrop-blur-sm">
        <div class="glass-panel w-full max-w-lg rounded-2xl p-6 border border-gray-700/50 space-y-4 shadow-2xl">
            <div class="flex justify-between items-center text-theme-400 text-xs font-bold tracking-widest uppercase">
                <span>Original Input (Editable)</span>
                <button id="cancel-retry-btn" class="text-gray-400 hover:text-white transition-colors">CANCEL</button>
            </div>
            <p class="text-[10px] text-gray-500">Edit this original prompt if needed, then hit Retry to run Magic Fix again.</p>
            <div class="relative group">
                <textarea id="retry-text-input" class="w-full h-32 bg-gray-900/50 rounded-xl border border-gray-700 p-4 text-sm font-mono text-gray-300 focus:outline-none focus:border-theme-500 resize-none leading-relaxed"></textarea>
            </div>
            <button id="confirm-retry-btn" class="w-full py-4 rounded-xl bg-gradient-to-r from-pink-600 to-rose-600 text-white font-bold text-xs shadow-lg hover:shadow-pink-900/40 flex items-center justify-center gap-2 transition-all">
                <svg class="animate-spin w-4 h-4 hidden" id="retry-spinner" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                <span>RUN MAGIC FIX AGAIN</span>
            </button>
        </div>
    </div>
				<div id="horde-log-window" class="hidden fixed inset-0 bg-black/60 flex flex-col items-center justify-center p-6 text-left z-[200] backdrop-blur-sm transition-opacity duration-300">
					<div class="w-full max-w-md space-y-3 font-mono border border-yellow-500/20 p-4 rounded-xl bg-gray-900 shadow-2xl relative ring-1 ring-white/10">
						
						<button onclick="document.getElementById('horde-log-window').classList.add('hidden')" class="absolute -top-3 -right-3 p-2 bg-gray-800 rounded-full text-gray-400 hover:text-white border border-gray-700 shadow-lg z-50">
							<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
						</button>

						<div class="flex justify-between items-end border-b border-yellow-500/30 pb-2 mb-2">
							<span class="text-yellow-500 font-bold text-xs tracking-widest flex items-center gap-2">
								<span class="w-2 h-2 bg-yellow-500 rounded-full animate-pulse"></span>
								HORDE TERMINAL
							</span>
							<span id="horde-timer" class="text-[10px] text-gray-500 font-mono">00:00</span>
						</div>
						
						<div id="horde-log-content" class="text-[10px] text-green-400 space-y-1 font-mono h-40 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-700 pr-2">
							</div>

						<div class="space-y-1 pt-2">
							<div class="flex justify-between text-[10px] text-gray-400">
								<span id="horde-status-text">Initializing...</span>
								<span id="horde-percent">0%</span>
							</div>
							<div class="w-full bg-gray-800 h-1.5 rounded-full overflow-hidden border border-gray-700">
								<div id="horde-progress-bar" class="bg-gradient-to-r from-yellow-600 to-yellow-400 h-full w-0 transition-all duration-300 ease-out"></div>
							</div>
						</div>
					</div>
				</div>	
				

<script>
			
        // --- CORE MANAGERS ---
        // --- CORE MANAGERS ---
		let currentLightboxIndex = 0; // Tracks the currently open image
				const GalleryManager = {
					catalogueCache: null,

					// 1. INITIALIZE (Connects to 'PB_Gallery_DB')
					async init() {
						console.log("Initializing Gallery Manager...");
						return new Promise((resolve, reject) => {
							// USE YOUR EXACT CONSTANTS
							const req = indexedDB.open(DB_NAME, DB_VERSION);

							req.onupgradeneeded = (e) => {
								const database = e.target.result;
								if (!database.objectStoreNames.contains(STORE_NAME)) {
									database.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
								}
							};

							req.onsuccess = (e) => {
								// CRITICAL: Update the global 'db' variable your app relies on
								db = e.target.result; 
								window.db = db; // Safety backup
								
								console.log("Gallery Database Connected:", db.name);
								this.loadGallery();
								resolve(db);
							};

							req.onerror = (e) => {
								console.error("DB Connection Failed:", e);
								reject(e);
							};
						});
					},

					// 2. SAVE IMAGE (With Metadata Fix)
					async saveImage(base64, prompt, provider, originalBase64 = null, negativePrompt = "", customMeta = null) {
						if (!base64 || !base64.startsWith('data:')) return;
						const blob = base64ToBlob(base64, 'image/jpeg');
						if (!blob) return;

						let originalBlob = null;
						if (originalBase64 && originalBase64.startsWith('data:')) {
							originalBlob = base64ToBlob(originalBase64, 'image/jpeg');
						}

						// --- CONTEXT-AWARE METADATA SCRAPING ---
						let meta = customMeta;
						if (!meta) {
							// Default: Scrape UI
							const currentProv = (typeof state !== 'undefined' && state.generator) ? state.generator : (provider || "unknown").toLowerCase();
							let activeModel = "Default";
							
							// Try to find active model value
							if(currentProv.includes('gemini')) activeModel = document.getElementById('model-select')?.value || "Gemini";
							else if(currentProv.includes('cloudflare')) activeModel = document.getElementById('cf-model-select')?.value || "SDXL";
							else if(currentProv.includes('pollination')) activeModel = document.getElementById('poll-model-select')?.value || "Pollinations";
							else {
								 // Fallback scraper
								 const generic = document.querySelector(`select[id*="model"]`);
								 if(generic) activeModel = generic.value;
							}

							meta = {
								provider_key: currentProv,
								model: activeModel,
								style: document.getElementById('scan-style-final')?.value || "Standard",
								steps: document.getElementById('cf-steps')?.value || "N/A",
								guidance: document.getElementById('cf-guidance')?.value || "N/A",
								seed: "Random", // If you have a seed variable, use it here
								width: document.getElementById('width')?.value || "N/A",
								height: document.getElementById('height')?.value || "N/A"
							};
						}

						// Use global 'db' and 'STORE_NAME'
						if(!db) { console.error("DB Disconnected"); return; }

						const tx = db.transaction(STORE_NAME, 'readwrite');
						const store = tx.objectStore(STORE_NAME);

						const entry = {
							blob: blob,
							prompt: prompt,
							negativePrompt: negativePrompt || "",
							provider: provider || 'UNKNOWN',
							date: Date.now(),
							metadata: meta, // NEW DATA
							isUpscaled: !!originalBlob
						};

						if (originalBlob) entry.originalBlob = originalBlob;

						store.add(entry);
						tx.oncomplete = () => this.loadGallery();
					},

					// 3. LOAD GALLERY (Populates 'slideshowItems' & Renders)
					async loadGallery() {
						return new Promise((resolve) => {
							// Clear Strips
							['gallery-strip', 'setup-gallery-strip'].forEach(id => {
								const el = document.getElementById(id);
								if(el) el.innerHTML = '';
							});

							if (!db) {
								console.warn("DB not ready, retrying init...");
								this.init(); // Auto-recover
								return;
							}

							const tx = db.transaction(STORE_NAME, 'readonly');
							const req = tx.objectStore(STORE_NAME).getAll();

							req.onsuccess = () => {
								// UPDATE GLOBAL VARIABLE
								slideshowItems = req.result.reverse();
								
								// Reset Page
								galleryPage = 0;
								
								// CALL RENDERER
								if(typeof renderGalleryBatch === 'function') {
									renderGalleryBatch();
								} else {
									console.error("renderGalleryBatch() function is missing.");
								}
								resolve();
							};
							req.onerror = () => resolve();
						});
					},

					// 4. CLEAR
					async clearAll() {
						if(!confirm("Delete all saved images?")) return;
						const tx = db.transaction(STORE_NAME, 'readwrite');
						tx.objectStore(STORE_NAME).clear();
						tx.oncomplete = () => this.loadGallery();
					},

					// --- 5. EXPORT ZIP (PATCHED, LOSSLESS) ---
						async exportZip() {
							const btn = document.getElementById('backup-db-btn');
							const originalText = btn ? btn.innerHTML : "BACKUP";
							if (btn) { btn.innerHTML = `ZIPPING...`; btn.disabled = true; }

							try {
								if (!window.db) throw new Error("DB Disconnected");

								const tx = window.db.transaction('images', 'readonly');
								const req = tx.objectStore('images').getAll();

								req.onsuccess = async () => {
									const items = req.result;
									if (items.length === 0) {
										showToast("Database is empty!", "error");
										if (btn) { btn.innerHTML = originalText; btn.disabled = false; }
										return;
									}

									const zip = new JSZip();
									const folder = zip.folder("prompt_builder_gallery");
									const manifest = [];

									items.forEach((item, index) => {
										// 1. Main Image
										const ext = (item.blob.type === 'image/png') ? 'png' : 'jpg';
										const filename = `image_${index}_${item.provider || 'AI'}.${ext}`;
										folder.file(filename, item.blob);

										// 2. Original Image (IMG2IMG SOURCE)
										let originalFilename = null;
										if (item.originalBlob) {
											const origExt = (item.originalBlob.type === 'image/png') ? 'png' : 'jpg';
											originalFilename = `image_${index}_ORIGINAL.${origExt}`;
											folder.file(originalFilename, item.originalBlob);
										}

										// 3. Manifest Entry (🔥 CRITICAL ADDITIONS)
										manifest.push({
											file: filename,
											originalFile: originalFilename,
											compare: !!item.originalBlob,          // ✅ explicit
											generationMode: item.originalBlob ? "img2img" : "txt2img",
											prompt: item.prompt,
											negativePrompt: item.negativePrompt,
											provider: item.provider,
											date: new Date(item.date).toISOString(),
											metadata: item.metadata || {}
										});
									});

									folder.file("metadata.json", JSON.stringify(manifest, null, 2));

									const content = await zip.generateAsync({ type: "blob" });

									const link = document.createElement('a');
									link.href = URL.createObjectURL(content);
									link.download = `PromptGallery_Backup_${Date.now()}.zip`;
									link.click();

									showToast(`Saved ${items.length} images`, "success");
									if (btn) { btn.innerHTML = originalText; btn.disabled = false; }
								};
							} catch (e) {
								console.error(e);
								showToast("Backup Failed", "error");
								if (btn) { btn.innerHTML = originalText; btn.disabled = false; }
							}
						},

//Merge Backup Zip -----------------------------------------
					async mergeBackup(file) {
						const btn = document.getElementById('merge-gallery-btn');
						const origText = btn ? btn.innerHTML : "MERGE";
						if (btn) { btn.innerHTML = `PROCESSING...`; btn.disabled = true; }

						try {
							if (!window.db) throw new Error("DB Disconnected");

							const zip = new JSZip();
							const zipData = await zip.loadAsync(file);

							let metaFile = null;
							let rootPath = "";

							zipData.forEach((path, entry) => {
								if (path.endsWith('metadata.json')) {
									metaFile = entry;
									rootPath = path.replace('metadata.json', '');
								}
							});

							if (!metaFile) throw new Error("Invalid Backup.");

							const manifest = JSON.parse(await metaFile.async("string"));
							const items = [];

							for (const m of manifest) {
								// --- MAIN IMAGE ---
								const imgFile =
									zipData.file(rootPath + m.file) ||
									zipData.file(m.file);

								if (!imgFile) continue;

								const blob = await imgFile.async("blob");
								const imageUrl = URL.createObjectURL(blob);

								// --- ORIGINAL (IMG2IMG SOURCE) ---
								let originalBlob = null;
								let originalImageUrl = null;

								if (m.originalFile) {
									const origFile =
										zipData.file(rootPath + m.originalFile) ||
										zipData.file(m.originalFile);

									if (origFile) {
										originalBlob = await origFile.async("blob");
										originalImageUrl = URL.createObjectURL(originalBlob);
									}
								}

								const item = {
									// stored
									blob,
									originalBlob,

									// 🔥 RUNTIME (CRITICAL)
									imageUrl,
									originalImageUrl,
									compareEnabled: !!originalImageUrl,
									generationMode: originalImageUrl ? "img2img" : "txt2img",

									// metadata
									prompt: m.prompt,
									negativePrompt: m.negativePrompt || "",
									provider: m.provider || "IMPORTED",
									date: m.date ? new Date(m.date).getTime() : Date.now(),
									metadata: m.metadata || {},

									// legacy flag (keep if used elsewhere)
									isUpscaled: !!originalBlob
								};

								items.push(item);
							}

							if (items.length === 0) throw new Error("No images found.");

							const tx = window.db.transaction('images', 'readwrite');
							const store = tx.objectStore('images');
							items.forEach(i => store.add(i));

							tx.oncomplete = () => {
								this.loadGallery();
								showToast(`Merged ${items.length} items.`, "success");
								if (btn) { btn.innerHTML = origText; btn.disabled = false; }
							};

						} catch (e) {
							console.error(e);
							showToast("Merge Failed: " + e.message, "error");
							if (btn) { btn.innerHTML = origText; btn.disabled = false; }
						}
					},


  

  							async openCatalogue(file) {
								const btn = document.getElementById('view-cat-btn'); 
								const originalText = btn ? btn.innerHTML : "OPEN";
								if(btn) { btn.innerHTML = `OPENING...`; btn.disabled = true; }

								try {
									const zip = new JSZip(); 
									const zipData = await zip.loadAsync(file);
									let metaFile = null, rootPath = "";
									zipData.forEach((path, entry) => { if(path.endsWith('metadata.json')) { metaFile = entry; rootPath = path.replace('metadata.json',''); } });
									
									if (!metaFile) throw new Error("No metadata.json");
									
									const metaStr = await metaFile.async("string"); 
									const manifest = JSON.parse(metaStr);
									
									this.catalogueCache = { zipData, manifest, rootPath };
									
									if(typeof safeClass === 'function') {
										safeClass('nav-catalogue', 'remove', 'hidden'); 
										safeClass('cat-slideshow-btn', 'remove', 'hidden');
									}
									
									await this.renderCatalogueGrid();
									
									if(typeof switchTab === 'function') switchTab('catalogue');
									
									if(btn) { btn.innerHTML = originalText; btn.disabled = false; }
								} catch (e) { 
									showToast("Read Failed", "error"); 
									if(btn) { btn.innerHTML = originalText; btn.disabled = false; }
								}
							},

							async reopenLastCatalogue() {
								if (!this.catalogueCache) return;
								await this.renderCatalogueGrid();
								if(typeof safeClass === 'function') safeClass('nav-catalogue', 'remove', 'hidden'); 
								if(typeof switchTab === 'function') switchTab('catalogue');
							},

							async renderCatalogueGrid() {
								if (!this.catalogueCache) return;
								const { zipData, manifest, rootPath } = this.catalogueCache;
								const grid = document.getElementById('catalogue-grid'); 
								if(!grid) return;
								
								grid.innerHTML = ''; 
								const frag = document.createDocumentFragment();
								
								for (let i = 0; i < manifest.length; i++) {
									const item = manifest[i];
									const imgPath = rootPath + item.file; 
									const imgFile = zipData.file(imgPath) || zipData.file(item.file);
									
									if (imgFile) {
										const blob = await imgFile.async("blob"); 
										const url = URL.createObjectURL(blob);
										const div = document.createElement('div');
										div.className = "relative aspect-square cursor-pointer group rounded-lg overflow-hidden bg-gray-800 border border-transparent hover:border-theme-400 transition-all";
										div.innerHTML = `<img src="${url}" class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"><div class="absolute bottom-0 inset-x-0 bg-black/60 p-1 text-[8px] text-center font-bold text-gray-300 truncate">${item.provider || 'AI'}</div>`;
										
										// Assuming NavManager exists
										if(typeof NavManager !== 'undefined') {
											div.onclick = () => NavManager.openCatalogue(i); 
										}
										frag.appendChild(div);
									}
								}
								grid.appendChild(frag);
							},

							async playCatalogueSlideshow() {
								if (!this.catalogueCache) return;
								const { zipData, manifest, rootPath } = this.catalogueCache;
								showToast("Preparing Slideshow...", "success");
								const slideData = [];
								for (const item of manifest) {
									const imgPath = rootPath + item.file; 
									const imgFile = zipData.file(imgPath) || zipData.file(item.file);
									if(imgFile) {
										const blob = await imgFile.async("blob");
										// Pass metadata to slideshow if supported
										slideData.push({ 
											blob: blob, 
											prompt: item.prompt, 
											provider: item.provider,
											metadata: item.metadata || {} 
										});
									}
								}
								if (slideData.length === 0) { showToast("No images found.", "error"); return; }
								
								if(typeof slideshowItems !== 'undefined') slideshowItems = slideData; 
								if(typeof startSlideshow === 'function') startSlideshow(0);
							},

							showCatalogueItem(url, meta, blob) {
								const doc = document.documentElement;
								if (doc.requestFullscreen) doc.requestFullscreen().catch(e => console.log("FS Blocked", e));
								
								if(typeof safeClass === 'function') safeClass('app-header', 'add', 'hidden');
								
								const imgEl = document.getElementById('cat-img'); if(imgEl) imgEl.src = url;
								const provEl = document.getElementById('cat-provider'); if(provEl) provEl.textContent = (meta.provider || 'UNKNOWN').toUpperCase();
								
								const closeBtn = document.getElementById('close-cat-overlay-btn');
								if(closeBtn) {
									const newClose = closeBtn.cloneNode(true); closeBtn.parentNode.replaceChild(newClose, closeBtn);
									newClose.onclick = () => {
										if(typeof safeClass === 'function') {
											safeClass('cat-overlay', 'add', 'hidden'); 
											safeClass('app-header', 'remove', 'hidden'); 
										}
										if (document.exitFullscreen) document.exitFullscreen().catch(e=>{});
									};
								}
								
								const useBtn = document.getElementById('cat-use-btn');
								if(useBtn) {
									const newUse = useBtn.cloneNode(true); useBtn.parentNode.replaceChild(newUse, useBtn);
									newUse.onclick = () => {
										const out = document.getElementById('output-text'); 
										if(out) {
											out.value = meta.prompt; 
											if(typeof autoResize === 'function') autoResize(out);
										}
										if(typeof safeClass === 'function') {
											safeClass('cat-overlay', 'add', 'hidden'); 
											safeClass('catalogue-screen', 'add', 'hidden');
										}
										if(typeof switchTab === 'function') switchTab('home'); 
										if (document.exitFullscreen) document.exitFullscreen().catch(e=>{});
										showToast("Prompt Loaded!", "success");
									};
								}
								
								const shareBtn = document.getElementById('cat-share-btn');
								if(shareBtn) {
									const newShare = shareBtn.cloneNode(true); shareBtn.parentNode.replaceChild(newShare, shareBtn);
									newShare.onclick = () => {
										if(typeof nativeShare === 'function') nativeShare(url, newShare, meta.prompt);
									};
								}
								
								// RESTORE TO GALLERY BUTTON
								const resBtn = document.getElementById('cat-restore-btn');
								if(resBtn) {
									const newRes = resBtn.cloneNode(true); resBtn.parentNode.replaceChild(newRes, resBtn);
									newRes.onclick = () => {
										const tx = this.db.transaction(this.storeName, 'readwrite');
										tx.objectStore(this.storeName).add({ 
											blob: blob, 
											prompt: meta.prompt, 
											negativePrompt: meta.negativePrompt || "", // Added Support
											provider: meta.provider, 
											date: Date.now(),
											metadata: meta.metadata || {} // Added Support
										});
										tx.oncomplete = () => { this.loadGallery(); showToast("Restored", "success"); };
									};
								}
								if(typeof safeClass === 'function') safeClass('cat-overlay', 'remove', 'hidden');
							},
							
							async loadAndShowAtIndex(index) {
								if (!this.catalogueCache) return;
								const { zipData, manifest, rootPath } = this.catalogueCache; const item = manifest[index];
								const imgEl = document.getElementById('cat-img'); if(imgEl) imgEl.style.opacity = '0.5';
								try {
									const imgPath = rootPath + item.file; const imgFile = zipData.file(imgPath) || zipData.file(item.file);
									if (imgFile) {
										const blob = await imgFile.async("blob"); const url = URL.createObjectURL(blob);
										this.showCatalogueItem(url, item, blob); 
										if(imgEl) setTimeout(() => imgEl.style.opacity = '1', 150);
									}
								} catch(e) { showToast("Error loading image", "error"); }
							}
						};
setTimeout(() => GalleryManager.init(), 500);
// --- RENDER GALLERY FUNCTION (MOVED OUTSIDE) ---
					window.renderGalleryBatch = function() {
					const targets = [
						{ stripId: 'gallery-strip', containerId: 'gallery-container', loadId: 'gallery-load-more' },
						{ stripId: 'setup-gallery-strip', containerId: 'setup-gallery-container', loadId: 'setup-gallery-load-more' }
					];

					const start = galleryPage * GALLERY_BATCH_SIZE;
					const end = start + GALLERY_BATCH_SIZE;
					const batch = slideshowItems.slice(start, end);

					targets.forEach(t => {
						const strip = document.getElementById(t.stripId);
						const container = document.getElementById(t.containerId);
						if(!strip || !container) return;

						const oldBtn = document.getElementById(t.loadId);
						if(oldBtn) oldBtn.remove();

						if (batch.length === 0 && galleryPage === 0) { 
							container.classList.add('hidden'); 
							return; 
						}
						container.classList.remove('hidden');

						const batchHTML = batch.map((item, localIndex) => {
							const globalIndex = start + localIndex; 
							const url = URL.createObjectURL(item.blob); 
							// Handle missing provider gracefully
							const provider = item.provider ? item.provider.replace(/'/g, "\\'") : 'UNKNOWN';
							const badgeTxt = provider.substring(0, 4).toUpperCase();
							const safePrompt = item.prompt.replace(/`/g, '').replace(/\$/g, '');

							return `<div class="relative flex-none group cursor-pointer w-16 h-16 animate-fade-in" onclick="NavManager.openGallery(${globalIndex})">
								<img src="${url}" class="w-full h-full object-cover rounded-xl border-2 border-transparent hover:border-theme-400 transition-all bg-gray-800">
								<div class="absolute bottom-0 right-0 left-0 bg-black/60 text-[8px] text-center text-white font-mono rounded-b-lg backdrop-blur-sm truncate">${badgeTxt}</div>
							</div>`;
						}).join('');
						
						strip.insertAdjacentHTML('beforeend', batchHTML);

						if (end < slideshowItems.length) { 
							const remaining = slideshowItems.length - end; 
							strip.insertAdjacentHTML('beforeend', `<button id="${t.loadId}" onclick="galleryPage++; renderGalleryBatch();" class="flex-none w-16 h-16 rounded-xl border border-gray-700 bg-gray-800/50 hover:bg-theme-600 hover:text-white text-gray-400 flex flex-col items-center justify-center gap-1 transition-all"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg><span class="text-[8px] font-bold">+${remaining}</span></button>`); 
						}
					});
				};
				
        // --- GLOBAL HELPERS & SANITIZATION ---
		// --- MANUAL PUTER TOKEN FIX ---
        
        // 1. Show/Hide the input field based on provider selection
        function togglePuterAuthInput(provider) {
            const div = document.getElementById('puter-manual-auth');
            if(div) {
                if(provider === 'puter') div.classList.remove('hidden');
                else div.classList.add('hidden');
            }
        }

        
        function base64ToBlob(base64, mimeType = 'image/jpeg') {
            try {
                if (base64.startsWith('data:')) {
                    const parts = base64.split(',');
                    const data = parts[1];
                    mimeType = parts[0].match(/:(.*?);/)?.[1] || mimeType; 
                    base64 = data;
                }
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) byteNumbers[i] = byteCharacters.charCodeAt(i);
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], {type: mimeType}); 
            } catch(e) { console.error("Base64 Error:", e); return null; }
        }
        function getSafeFilename(prompt) {
            if (!prompt) return `visual-${Date.now()}`;
            return prompt.substring(0, 40).replace(/[^a-z0-9 ]/gi, '').trim().replace(/\s+/g, '_') || `visual-${Date.now()}`;
        }

        function sanitizePrompt(text) {
            if (!text) return "";
            const replacements = [
                { regex: /\b(cleavage|bust|breasts|boobs|chest)\b/gi, sub: "sculpted bodice detail" },
                { regex: /\b(nipples?|areola)\b/gi, sub: "detailed fabric tension" },
                { regex: /\b(vagina|pussy|cameltoe)\b/gi, sub: "fitted lower silhouette" },
                { regex: /\b(nude|naked|undressed)\b/gi, sub: "natural skin tone, artistic figure study" },
                { regex: /\b(see-through|transparent|sheer)\b/gi, sub: "translucent layered fabric, ethereal texture" },
                { regex: /\b(tight|straining|bursting)\b/gi, sub: "form-fitting, tailored" },
                { regex: /\b(wet)\b/gi, sub: "glistening, hydro-dynamic lighting" },
                { regex: /\b(lingerie|underwear|panties|bra)\b/gi, sub: "intricate lace garment" },
                { regex: /\b(spread|open legs)\b/gi, sub: "dynamic wide stance" },
                { regex: /\b(doggystyle|bent over)\b/gi, sub: "athletic forward lean" },
                { regex: /\b(sexy|hot|erotic|lewd|porn)\b/gi, sub: "cinematic, captivating, alluring" }
            ];
            let clean = text;
            replacements.forEach(r => { clean = clean.replace(r.regex, r.sub); });
            return clean;
        }
		// --- NEW HELPER: Only get Negative Prompt if the dropdown is OPEN ---
        function getActiveNegativePrompt() {
            const el = document.getElementById('negative-prompt');
            if (!el) return "";
            
            // Check if the parent <details> tag is open
            const details = el.closest('details');
            if (details && !details.open) {
                return ""; // It is hidden, so we treat it as empty!
            }
            
            return el.value.trim();
        }
        async function nativeShare(imgUrl, buttonEl, promptText) {
            if (!imgUrl) return;
            
            // FIX: Check for navigator.share ONLY. canShare is optional/newer.
            if (!navigator.share) { 
                showToast("Sharing not supported on this device.", "error"); 
                return; 
            }

            let originalContent = "";
            if (buttonEl) { 
                originalContent = buttonEl.innerHTML; 
                // Keep the icon but spin it
                buttonEl.innerHTML = `<svg class="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`; 
                buttonEl.disabled = true; 
            }

            try {
                const fname = getSafeFilename(promptText);
                const response = await fetch(imgUrl);
                const blob = await response.blob();
                const ext = blob.type === 'image/png' ? 'png' : 'jpg';
                const file = new File([blob], `${fname}.${ext}`, { type: blob.type });
                
                const shareData = { 
                    files: [file], 
                    title: 'AI Art', 
                    text: promptText || 'Created with Prompt Builder MAX' 
                };

                // FIX: Only validate if canShare exists
                if (navigator.canShare && !navigator.canShare({ files: [file] })) {
                    throw new Error("System blocked file sharing.");
                }

                await navigator.share(shareData);
                
            } catch (e) { 
                if (e.name !== 'AbortError') showToast("Share Failed: " + e.message, "error"); 
            } finally { 
                if (buttonEl) { 
                    buttonEl.innerHTML = originalContent; 
                    buttonEl.disabled = false; 
                } 
            }
        }

        function switchTab(tab) {
            // 1. Map internal states to Navigation Buttons
            let navId = tab;
            if (tab === 'config') navId = 'home';
            
            // 2. Update Navigation Buttons Visuals
            document.querySelectorAll('.nav-item').forEach(btn => {
                btn.classList.remove('text-theme-400', 'text-indigo-400', 'opacity-100');
                btn.classList.add('text-gray-400', 'opacity-60');
                const div = btn.querySelector('div');
                if (div) div.classList.remove('bg-theme-500', 'bg-theme-500/10', 'bg-indigo-500', 'text-white');
            });

            const activeBtn = document.getElementById(`nav-${navId}`);
            if(activeBtn) {
                activeBtn.classList.remove('text-gray-400', 'opacity-60');
                const div = activeBtn.querySelector('div');
                if (tab === 'catalogue') {
                    activeBtn.classList.add('text-indigo-400', 'opacity-100');
                    if (div) div.classList.add('bg-indigo-500', 'text-white'); 
                } else {
                    activeBtn.classList.add('text-theme-400', 'opacity-100');
                    if (div) div.classList.add('bg-theme-500/10'); 
                }
            }

            // 3. HARD HIDE ALL SCREENS
            const allScreens = ['db-screen', 'history-screen', 'catalogue-screen', 'setup-screen', 'app-screen', 'gallery-grid-screen'];
            allScreens.forEach(id => {
                const el = document.getElementById(id);
                if(el) {
                    el.classList.add('hidden');
                    el.style.display = 'none'; // Force hide
                }
            });
            
            const actionBar = document.getElementById('action-bar');
            if(actionBar) {
                actionBar.classList.add('hidden');
                actionBar.style.display = 'none';
            }

            // 4. SHOW TARGET SCREEN
            const show = (id) => {
                const el = document.getElementById(id);
                if(el) {
                    el.classList.remove('hidden');
                    el.style.display = 'block'; // Force show
                }
            };

            // 5. ROUTING LOGIC
            if (tab === 'home') {
                const outBox = document.getElementById('output-text');
                const hasOutput = outBox && outBox.value.trim().length > 0;

                if(hasOutput) {
                    show('app-screen');
                    if(actionBar) {
                        actionBar.classList.remove('hidden');
                        actionBar.style.display = 'block';
                    }
                } else {
                    show('setup-screen');
                }
            } 
            else if (tab === 'config') {
                show('setup-screen');
            }
            else if (tab === 'setup') { show('db-screen'); } 
            else if (tab === 'catalogue') { 
                if(typeof GalleryManager !== 'undefined' && GalleryManager.catalogueCache) { GalleryManager.renderCatalogueGrid(); } 
                show('catalogue-screen'); 
            }
            else if (tab === 'history') { 
                show('history-screen'); 
                if(typeof renderHistory === 'function') renderHistory(); 
            }
            // *** GRID VIEW LOGIC ***
            else if (tab === 'grid') {
                show('gallery-grid-screen');
                
                // Double check Setup is hidden
                const setup = document.getElementById('setup-screen');
                if(setup) setup.style.display = 'none';

                if (typeof slideshowItems !== 'undefined') {
                    if (slideshowItems.length === 0) {
                        GalleryManager.loadGallery().then(() => renderFullGrid(true));
                    } else {
                        renderFullGrid(true); 
                    }
                }
            }

            // 6. HISTORY STATE
            if (tab === 'setup' || tab === 'config' || tab === 'grid') {
                history.pushState({ view: tab }, document.title);
            } else {
                history.replaceState({ view: tab }, document.title);
            }
        }

		function getCurrentTab() {
			// 1. Check Database Screen (Mapped to 'setup' tab)
			if (!document.getElementById('db-screen').classList.contains('hidden')) return 'setup';
			
			// 2. Check History & Catalogue
			if (!document.getElementById('history-screen').classList.contains('hidden')) return 'history';
			if (!document.getElementById('catalogue-screen').classList.contains('hidden')) return 'catalogue';
			
			// 3. Distinguish 'Home' sub-states
			// If Setup Screen is visible, we are in 'config' mode
			if (!document.getElementById('setup-screen').classList.contains('hidden')) return 'config'; 
			
			// Otherwise, we are in standard 'home' (Results) mode
			return 'home';
		}
		function getPixelDimensions(arValue) {
            let w = 1024, h = 1024;
            if (arValue.includes("16:9"))      { w = 1408; h = 768; } else if (arValue.includes("3:2")) { w = 1248; h = 832; }
            else if (arValue.includes("4:3"))  { w = 1280; h = 896; } else if (arValue.includes("5:4")) { w = 1120; h = 896; }
            else if (arValue.includes("1.85:1")) { w = 1352; h = 728; } else if (arValue.includes("2:1")) { w = 1440; h = 720; }
            else if (arValue.includes("2.39:1")) { w = 1568; h = 656; } else if (arValue.includes("21:9")) { w = 1536; h = 640; }
            else if (arValue.includes("3:1"))  { w = 1728; h = 576; } else if (arValue.includes("4:1")) { w = 2048; h = 512; }
            else if (arValue.includes("9:16")) { w = 768; h = 1408; } else if (arValue.includes("2:3")) { w = 832; h = 1248; }
            else if (arValue.includes("3:4"))  { w = 896; h = 1280; } else if (arValue.includes("4:5")) { w = 896; h = 1120; }
            else if (arValue.includes("3:5"))  { w = 768; h = 1280; } else if (arValue.includes("1:1.85")) { w = 728; h = 1352; }
            else if (arValue.includes("1:2")) { w = 640; h = 1536; } else if (arValue.includes("1:2.39")) { w = 656; h = 1568; } 
            else if (arValue.includes("1:4"))  { w = 512; h = 2048; }
            return { width: w, height: h };
        }

        function getGeminiRatio(arValue) {
            let param = "1:1", desc = "square 1:1 aspect ratio";
            if (arValue.includes("16:9") || arValue.includes("1.85:1") || arValue.includes("2:1") || arValue.includes("21:9")) { param = "16:9"; desc = "wide cinematic 16:9 aspect ratio"; }
            else if (arValue.includes("3:2") || arValue.includes("4:3") || arValue.includes("5:4")) { param = "4:3"; desc = "landscape 4:3 aspect ratio"; }
            else if (arValue.includes("9:16") || arValue.includes("1:1.85") || arValue.includes("1:2") || arValue.includes("1:2.39")) { param = "9:16"; desc = "tall vertical 9:16 aspect ratio"; }
            else if (arValue.includes("2:3") || arValue.includes("3:4") || arValue.includes("4:5")) { param = "3:4"; desc = "portrait 3:4 aspect ratio"; }
            return { param, desc };
        }

        function escapeHTML(str) {
            if (!str) return "";
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function dismissKeyboard() {
            if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT')) { document.activeElement.blur(); }
        }

        function showToast(message, type = 'success') {
            let toast = document.getElementById('toast-notification');
            if (!toast) { toast = document.createElement('div'); toast.id = 'toast-notification'; document.body.appendChild(toast); }
            const baseClasses = "fixed bottom-24 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-xl shadow-2xl z-[150] transition-all duration-300 font-bold text-xs tracking-widest flex items-center gap-2 backdrop-blur-xl border pointer-events-none";
            const themeClasses = type === 'error' ? "bg-red-900/90 text-red-200 border-red-500/50 shadow-red-900/50" : "bg-emerald-900/90 text-emerald-200 border-emerald-500/50 shadow-emerald-900/50";
            toast.className = `${baseClasses} ${themeClasses} opacity-0 translate-y-4 scale-95`;
            const icon = type === 'error' ? `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>` : `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
            toast.innerHTML = `${icon}<span>${message}</span>`;
            requestAnimationFrame(() => { toast.classList.remove('opacity-0', 'translate-y-4', 'scale-95'); });
            if (window.toastTimeout) clearTimeout(window.toastTimeout);
            window.toastTimeout = setTimeout(() => { toast.classList.add('opacity-0', 'translate-y-4', 'scale-95'); }, 2000);
        }

			// ==========================================
			//  PASSWORD VISIBILITY TOGGLE
			// ==========================================
			window.togglePasswordVisibility = function(inputId, btn) {
				const input = document.getElementById(inputId);
				if (!input) return;

				const isPassword = input.type === 'password';
				input.type = isPassword ? 'text' : 'password';

				// Update Icon
				if (isPassword) {
					// Show "Eye Open" (Visible)
					btn.innerHTML = `<svg class="w-4 h-4 text-theme-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`;
				} else {
					// Show "Eye Closed" (Hidden)
					btn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>`;
				}
			};
        function safeClass(idOrElement, action, ...classes) {
            let el = (typeof idOrElement === 'string') ? document.getElementById(idOrElement) : idOrElement;
            if (el && el.classList) {
                if (action === 'add') el.classList.add(...classes);
                else if (action === 'remove') el.classList.remove(...classes);
                else if (action === 'toggle') el.classList.toggle(...classes);
                else if (action === 'replace') el.classList.replace(classes[0], classes[1]);
            }
        }
        function safeListen(id, event, fn) { const el = document.getElementById(id); if (el) el.addEventListener(event, fn); }
        function autoResize(el) { 
				if(!el) return; 
				// Reset to auto first to allow shrinking if text was deleted
				el.style.height = 'auto'; 
				// Set to scrollHeight + small buffer for borders
				el.style.height = (el.scrollHeight + 2) + 'px'; 
			}
		// --- STATE & STORAGE ---
        const state = { nsfw: false, mode: 'manual', subject: 'female', theme: 'matrix', generator: 'gemini', helper: 'auto' }; 
        const DATA_KEY = 'promptBuilder_v70_data';
        const FILE_KEY = 'promptBuilder_v70_filenames';
        const HIST_KEY = 'promptBuilder_v70_history';
        const DB_NAME = 'PB_Gallery_DB';
        const DB_VERSION = 1;
        const STORE_NAME = 'images';
        window.lastRawPrompt = "";
        let db; 
        let slideshowItems = [];
        let slideIndex = 0;
        let galleryPage = 0;
        const GALLERY_BATCH_SIZE = 20;
        let slideTimer = null;
        let isRestoring = false;

		// ==========================================
        //  UNIFIED HISTORY & EXIT GUARD MANAGERS
        // ==========================================
        
        const HistoryManager = {
            init() {
                // Ensure we have a root state
                if (!history.state) {
                    history.replaceState({ view: 'home' }, document.title);
                }
            },

            pushModal(name) {
                // Do not push if we are already in this state (prevents duplicate stacking)
                if (history.state && history.state.modal === name) return;
                history.pushState({ view: 'home', modal: name }, `Modal - ${name}`);
            },

            closeModal() {
                // If the current history state says we are in a modal, go back.
                // This triggers 'popstate', which runs the UI closing logic.
                if (history.state && history.state.modal) {
                    history.back();
                } else {
                    // Fallback: If history is lost/mismatch, force close UI directly
                    closeLightboxUI();
                    if(typeof stopSlideshow === 'function') stopSlideshow(false);
                }
            }
        };

        const ExitGuard = {
            init() {
                // Browser Tab/App Close Protection
                window.addEventListener('beforeunload', (e) => {
                    if (this.isSetupOpen()) {
                        e.preventDefault(); 
                        e.returnValue = "You have unsaved settings. Exit?"; 
                        return e.returnValue;
                    }
                });
            },

            isSetupOpen() {
                const setup = document.getElementById('setup-screen');
                return setup && !setup.classList.contains('hidden');
            }
        };

        // Initialize immediately
        HistoryManager.init();
        ExitGuard.init();
		
        // --- GLOBAL LOGIC ---
        function renderGalleryBatch() {
            const strip = document.getElementById('gallery-strip');
            const container = document.getElementById('gallery-container');
            const oldBtn = document.getElementById('gallery-load-more');
            if(oldBtn) oldBtn.remove();

            const start = galleryPage * GALLERY_BATCH_SIZE;
            const end = start + GALLERY_BATCH_SIZE;
            const batch = slideshowItems.slice(start, end);
            
            if (batch.length === 0 && galleryPage === 0) { safeClass(container, 'add', 'hidden'); return; }
            safeClass(container, 'remove', 'hidden');

            const batchHTML = batch.map(item => {
                const url = URL.createObjectURL(item.blob);
                const badgeTxt = (item.provider || 'UNK').substring(0, 4).toUpperCase();
                return `<div class="relative flex-none group cursor-pointer w-16 h-16 animate-fade-in" onclick="restoreGalleryItem('${url}', \`${item.prompt.replace(/`/g, '')}\`, '${item.provider}')">
                    <img src="${url}" class="w-full h-full object-cover rounded-xl border-2 border-transparent hover:border-theme-400 transition-all bg-gray-800">
                    <div class="absolute bottom-0 right-0 left-0 bg-black/60 text-[8px] text-center text-white font-mono rounded-b-lg backdrop-blur-sm truncate">${badgeTxt}</div>
                </div>`;
            }).join('');
            strip.insertAdjacentHTML('beforeend', batchHTML);

            if (end < slideshowItems.length) {
                const remaining = slideshowItems.length - end;
                strip.insertAdjacentHTML('beforeend', `<button id="gallery-load-more" onclick="galleryPage++; renderGalleryBatch();" class="flex-none w-16 h-16 rounded-xl border border-gray-700 bg-gray-800/50 hover:bg-theme-600 hover:text-white text-gray-400 flex flex-col items-center justify-center gap-1 transition-all"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg><span class="text-[8px] font-bold">+${remaining}</span></button>`);
            }
        }

        // -------------SET PROVIDER ----------------
			window.setProvider = function(provider) {
					state.generator = provider;
					// UPDATED LIST including 'horde'
					const provs = ['gemini', 'cloudflare', 'puter', 'pollination', 'huggingface', 'freepik', 'horde'];
					
					provs.forEach(p => {
						const btn = document.getElementById(`prov-${p}`);
						const settings = document.getElementById(`${p}-settings-group`);
						
						if(btn) { 
							// Reset to inactive state
							btn.classList.remove('btn-active-glow'); 
							btn.classList.add('text-gray-400', 'bg-transparent'); 
							btn.classList.remove('text-white', 'shadow-lg'); 
						}
						if(settings) safeClass(settings, 'add', 'hidden');
					});

					const activeBtn = document.getElementById(`prov-${provider}`);
					const activeSettings = document.getElementById(`${provider}-settings-group`);
					
					if(activeBtn) { 
						// Apply custom glow
						activeBtn.classList.remove('text-gray-400', 'bg-transparent');
						activeBtn.classList.add('btn-active-glow'); 
					}
					if(activeSettings) safeClass(activeSettings, 'remove', 'hidden');
					
					if(typeof togglePuterAuthInput === 'function') togglePuterAuthInput(provider);
					
					savePrefs();
				};

        // *** FIX: ADDED MISSING THEME FUNCTION ***
        window.changeTheme = function(themeName) {
            state.theme = themeName;
            document.documentElement.setAttribute('data-theme', themeName);
            
            // Visual feedback for selected theme button
            document.querySelectorAll('.theme-dot').forEach(btn => {
                if(btn.getAttribute('onclick').includes(themeName)) {
                    btn.classList.add('active-dot');
                } else {
                    btn.classList.remove('active-dot');
                }
            });
            savePrefs();
        };
		
        function savePrefs() {
				if (isRestoring) return;

				// 1. Capture all <select> elements automatically
				let selects = {};
				try {
					const oldData = JSON.parse(localStorage.getItem(PREF_KEY) || '{}');
					if (oldData.selects) selects = { ...oldData.selects };
				} catch(e) {}

				document.querySelectorAll('select').forEach(sel => {
					if(sel.id) selects[sel.id] = sel.value;
				});

				// 2. Helper functions for different input types
				const getVal = (id) => document.getElementById(id)?.value || "";
				const getNum = (id) => document.getElementById(id)?.value || "0";
				const getCheck = (id) => document.getElementById(id)?.checked || false;

				// 3. Construct the comprehensive preferences object
				
					const prefs = { 
						state: state, 
						selects: selects, 
						apiKey: getVal('api-key-input'), 
						cloudflare: { 
							account: getVal('cf-account-id'), 
							token: getVal('cf-api-token'), 
							steps: getVal('cf-steps'), 
							guidance: getVal('cf-guidance'), 
							seed: getVal('cf-seed') 
						}, 
						pollSettings: { 
							seed: getVal('poll-seed'), 
							enhance: getCheck('poll-enhance'), 
							nologo: getCheck('poll-nologo'), 
							safe: getCheck('poll-safe'), 
							apiKey: getVal('poll-api-key')
						},
						huggingface: { 
							token: getVal('hf-token'), 
							model: getVal('hf-model-input'), 
							steps: getVal('hf-steps'), 
							guidance: getVal('hf-guidance'), 
							seed: getVal('hf-seed') 
						},
						freepik: { 
							key: document.getElementById('freepik-api-key')?.value || "",
							model: document.getElementById('freepik-model-select')?.value || "flux-pro-v1-1",
							resolution: document.getElementById('freepik-resolution-select')?.value || "2k",
							safety: document.getElementById('freepik-safety-select')?.value || "6",
							upsampling: document.getElementById('freepik-upsampling')?.checked || false,
							style: document.getElementById('freepik-style-select')?.value || "",
							guidance: document.getElementById('freepik-guidance')?.value || "1.0"
						},
						// NEW HORDE SETTINGS
						horde: {
							key: getVal('horde-api-key'),
							model: getVal('horde-model-select'),
							steps: getVal('horde-steps'),
							cfg: getVal('horde-cfg')
						},
						magnific: {
							opt: getVal('upscale-opt'),
							engine: getVal('upscale-engine'),
							creativity: getNum('upscale-creativity'),
							resemblance: getNum('upscale-resemblance'),
							hdr: getNum('upscale-hdr'),
							fractality: getNum('upscale-fractality')
						}
					};

				localStorage.setItem(PREF_KEY, JSON.stringify(prefs));
			}
        function updateConfigButtons() {
				document.querySelectorAll('.config-btn').forEach(btn => {
					const type = btn.dataset.type;
					const val = btn.dataset.value;
					
					const isActive = (type === 'nsfw' && String(state.nsfw) === val) || 
									 (type === 'mode' && state.mode === val) || 
									 (type === 'subject' && state.subject === val);
					
					// Reset
					btn.classList.remove('btn-active-glow', 'text-white', 'shadow-lg');
					btn.classList.add('text-gray-400', 'bg-transparent');
					
					if (isActive) {
						// Apply custom glow
						btn.classList.remove('text-gray-400', 'bg-transparent');
						btn.classList.add('btn-active-glow');
					} 
				});
			}

        function setTheme(isNSFW) {
            isNSFW ? document.documentElement.classList.add('nsfw-mode') : document.documentElement.classList.remove('nsfw-mode');
            if(isNSFW) { safeClass('visualize-btn', 'add', 'hidden'); safeClass('visualizer-container', 'add', 'hidden'); safeClass('gallery-container', 'add', 'hidden'); }
        }

        function getActiveLists() {
            const isFemale = state.subject === 'female', isMale = state.subject === 'male', isNSFW = state.nsfw;
            const combine = (base, nsfwArr) => (isNSFW && nsfwArr && nsfwArr.length > 0) ? [...base, "-NSFW_SEPARATOR-", ...nsfwArr] : [...base];
            return {
                activeSubjectList: isFemale ? combine(femaleSubjects, nsfwSubjects) : (isMale ? maleSubjects : ["-None-"]),
                activeGenderList: isFemale ? femaleGenderList : (isMale ? maleGenderList : ["-None-"]),
                activeLookalikeList: combine(lookalikeList, lookalikeListNSFW),
                activeActivityList: isFemale ? combine(femaleActivityList, nsfwActivityList) : (isMale ? maleActivityList : ["-None-"]),
                activeExpressionList: isFemale ? combine(femaleExpressionList, nsfwExpressionList) : (isMale ? maleExpressionList : ["-None-"]),
                activeBodyTypeList: isFemale ? combine(femaleBodyTypeList, nsfwBodyTypeList) : (isMale ? maleBodyTypeList : ["-None-"]),
                activeHairStyleList: isFemale ? femaleHairStyleList : (isMale ? maleHairStyleList : ["-None-"]),
                activePelvisList: isFemale ? femalePelvisList : (isMale ? malePelvisList : ["-None-"]),
                activeUpperBodyList: isFemale ? combine(femaleUpperBody, femaleUpperBodyNSFW) : (isMale ? maleUpperBody : ["-None-"]),
                activeLowerBodyList: isFemale ? combine(femaleLowerBody, femaleLowerBodyNSFW) : (isMale ? maleLowerBody : ["-None-"]),
                activeFootwearList: isFemale ? femaleFootwearList : (isMale ? maleFootwearList : ["-None-"]),
                activeBreastList: (!isMale) ? combine(breastTypeList, nsfwBreastList) : [],
                activeNippleList: (isNSFW && !isMale) ? nippleTypeList : [],
                activeNippleShapeList: (isNSFW && !isMale) ? nippleShapeList : [],
                activeVaginaList: (isNSFW && !isMale) ? vaginaTypeList : [],
                activeVaginaShapeList: (isNSFW && !isMale) ? vaginaShapeList : [],
                activeEffectList: combine(effectList, nsfwEffectList),
                activeHeadJewelry: headJewelleryList, activeEarJewelry: earJewelleryList, activeNeckJewellery: neckJewelleryList, activeArmJewellery: armJewelleryList, activeHandJewellery: handJewelleryList
            };
        }

        function createSelect(container, label, list, id, savedValues) {
            if (!list || !container) return;
            const wrapper = document.createElement('div'); wrapper.className = "mb-3";
            const labelEl = document.createElement('label'); labelEl.className = "block text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1 ml-1"; labelEl.textContent = label;
            const select = document.createElement('select'); select.id = id; select.className = "block w-full py-2 px-3 rounded-lg bg-gray-900/80 text-gray-200 border border-gray-700 text-xs outline-none focus:border-theme-500 focus:ring-1 focus:ring-theme-500";
            list.forEach(item => {
                const opt = document.createElement('option');
                if(item === "-Finish-") { opt.disabled = true; opt.textContent = "----------"; }
                else if (item === "-NSFW_SEPARATOR-") { opt.disabled = true; opt.textContent = "--- NSFW ITEMS ---"; opt.style.textAlign = "center"; opt.style.fontStyle = "italic"; opt.style.opacity = "0.5"; if(state.nsfw) opt.style.color = "#ef4444"; }
                else { opt.value = item; opt.textContent = item; }
                select.appendChild(opt);
            });
            if(savedValues && savedValues[id]) select.value = savedValues[id];
            select.addEventListener('change', savePrefs);
            const input = document.createElement('input'); input.id = id + "_custom"; input.type = "text"; input.placeholder = "Custom..."; input.className = "mt-1 w-full bg-transparent text-[10px] text-gray-400 border-b border-gray-800 focus:border-theme-500 outline-none py-1";
            wrapper.appendChild(labelEl); wrapper.appendChild(select); wrapper.appendChild(input); container.appendChild(wrapper);
        }

        function createAccordion(title, isOpen, buildFn) {
            const details = document.createElement('details'); if(isOpen) details.open = true;
            details.className = "glass-panel rounded-xl overflow-hidden mb-3 border border-gray-700/50";
            const summary = document.createElement('summary'); summary.className = "px-4 py-3 bg-gray-800/30 flex justify-between items-center hover:bg-gray-800/50 transition-colors";
            summary.innerHTML = `<span class="text-xs font-bold text-theme-400 tracking-widest uppercase">${title}</span><svg class="chevron w-4 h-4 text-gray-500 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>`;
            const content = document.createElement('div'); content.className = "p-4 pt-2 space-y-1";
            buildFn(content); details.appendChild(summary); details.appendChild(content); return details;
        }
		window.restoreHistory = function(index) {
            const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
            if(hist[index]) {
                const item = hist[index]; const text = (typeof item === 'string') ? item : item.text;
                safeClass('history-screen', 'add', 'hidden'); safeClass('app-screen', 'remove', 'hidden'); safeClass('action-bar', 'remove', 'hidden');
                updateOutput(text);
            }
        };

        window.deleteHistory = function(index) {
            let hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]"); hist.splice(index, 1);
            localStorage.setItem(HIST_KEY, JSON.stringify(hist)); renderHistory();
        };

        window.restoreGalleryItem = function(url, prompt, provider) {
				// 1. Restore Prompt Text
				if(prompt) { 
					const out = document.getElementById('output-text'); 
					if(out) { out.value = prompt; autoResize(out); } 
				}
				
				// 2. Update Main Display Image
				const imgTag = document.getElementById('generated-image');
				if(imgTag) {
					imgTag.onload = null; 
					imgTag.onerror = null;

					imgTag.src = url; 
					safeClass('generated-image', 'remove', 'hidden'); 
					safeClass('img-actions', 'remove', 'hidden');
					
					// Update inline save buttons
					const inlineJpg = document.getElementById('save-jpg-inline'); 
					const inlinePng = document.getElementById('save-png-inline');
					if(inlineJpg) inlineJpg.onclick = () => downloadImage(url, 'jpg', prompt);
					if(inlinePng) inlinePng.onclick = () => downloadImage(url, 'png', prompt);
					
					// Update main image click behavior
					// Update main image click behavior
					imgTag.onclick = () => {
						openLightbox(url, prompt, provider);
						// FIX: Re-bind buttons in case they were changed by navigation elsewhere
						if (typeof NavManager !== 'undefined') {
							NavManager.bindLightboxButtons(url, prompt);
						}
					};
				}

				// 3. Open Lightbox
				openLightbox(url, prompt, provider);

				// *** THE FIX: BIND THE LIGHTBOX BUTTONS TO THIS NEW IMAGE ***
				// This ensures the Save PNG/JPG buttons know about the *current* url
				if (typeof NavManager !== 'undefined') {
					NavManager.bindLightboxButtons(url, prompt);
				}
			};

       // --- SLIDESHOW CONTROLS MANAGER (Global) ---
				let controlsTimer = null;
				const slideControlsList = ['slide-top-bar', 'slide-bottom-bar', 'prev-slide-btn', 'next-slide-btn'];

				function hideControls() { 
					if(document.activeElement && document.activeElement.tagName === 'SELECT') return; 
					slideControlsList.forEach(id => { 
						const el = document.getElementById(id); 
						if(el) { 
							el.classList.remove('opacity-100'); 
							el.classList.add('opacity-0', 'pointer-events-none'); 
						} 
					}); 
				}

				function resetControlsTimer() { 
					if(controlsTimer) clearTimeout(controlsTimer); 
					controlsTimer = setTimeout(hideControls, 3000); // 3 Seconds
				}

				function showControls() { 
					slideControlsList.forEach(id => { 
						const el = document.getElementById(id); 
						if(el) { 
							el.classList.remove('opacity-0', 'pointer-events-none'); 
							el.classList.add('opacity-100'); 
						} 
					}); 
					resetControlsTimer(); 
				}
        function startSlideshow(index = 0) {
				if (slideshowItems.length === 0) return;
				
				// 1. SAVE CURRENT LOCATION ACCURATELY
				// This will now capture 'config', 'setup' (db), 'home' (results), etc.
				const currentView = getCurrentTab();
				history.replaceState({ view: currentView }, null, ''); 
				
				// 2. Open Gallery State
				history.pushState({ view: currentView, modal: 'gallery' }, 'Gallery', '#gallery');
				
				slideIndex = index;
				renderSlide();
				
				// Hide UI
				safeClass('app-screen', 'add', 'hidden'); 
				safeClass('setup-screen', 'add', 'hidden'); // Ensure this is hidden too
				safeClass('action-bar', 'add', 'hidden');
				safeClass('slideshow-screen', 'remove', 'hidden'); 
				safeClass('slideshow-screen', 'add', 'flex');
				
				if (!document.fullscreenElement) { 
					document.documentElement.requestFullscreen().catch(err => console.log("Fullscreen blocked:", err)); 
				}
				if(typeof showControls === 'function') showControls();
			}
        function stopSlideshow(goBack = true) {
            clearInterval(slideTimer); slideTimer = null;
            safeClass('slideshow-screen', 'add', 'hidden'); safeClass('slideshow-screen', 'remove', 'flex');
            safeClass('play-icon', 'remove', 'hidden'); safeClass('pause-icon', 'add', 'hidden');
            if(goBack) history.back();
        }
        function renderSlide() {
            const container = document.getElementById('slide-container'); 
            const item = slideshowItems[slideIndex];
            if (!item || !container) return;
            
            const badgeText = document.getElementById('slide-prov-text');
            if(badgeText) badgeText.textContent = (item.provider || 'UNKNOWN').toUpperCase();
            
            const effectSelect = document.getElementById('slide-effect');
            const effect = effectSelect ? effectSelect.value : 'fx-fade';
            
            // Apply class to container
            container.className = `w-full h-full flex items-center justify-center relative ${effect}`;
            
            // Create & Append
            const url = URL.createObjectURL(item.blob); 
            const img = document.createElement('img'); 
            img.src = url; 
            img.className = 'slide-img'; 
            img.ondblclick = () => stopSlideshow(true);
            
            img.onload = () => {
                const oldImg = container.querySelector('.slide-img.active'); 
                container.appendChild(img); 
                void img.offsetWidth; // Force Reflow
                
                requestAnimationFrame(() => { 
                    img.classList.add('active'); 
                    if (oldImg) { 
                        oldImg.classList.remove('active'); 
                        oldImg.classList.add('exit'); 
                        setTimeout(() => { if(oldImg.parentNode) oldImg.remove(); }, 800); 
                    } 
                });
            };
        }
                
        function nextSlide() { slideIndex = (slideIndex + 1) % slideshowItems.length; renderSlide(); }
        function prevSlide() { slideIndex = (slideIndex - 1 + slideshowItems.length) % slideshowItems.length; renderSlide(); }

        // --- UPDATED SLIDESHOW LOGIC ---
        // 1. Speed Listener
        const speedSel = document.getElementById('slide-speed-select');
        if (speedSel) {
            speedSel.addEventListener('change', (e) => {
                document.documentElement.style.setProperty('--slide-speed', e.target.value);
            });
        }

        // 2. Duration Listener
        const durSel = document.getElementById('slide-duration-select');
        if (durSel) {
            durSel.addEventListener('change', () => {
                if (window.slideTimer) {
                    clearInterval(window.slideTimer);
                    const dur = parseInt(durSel.value);
                    window.slideTimer = setInterval(nextSlide, dur);
                }
            });
        }

        // 3. Toggle Play Function
        function togglePlay() {
            if (window.slideTimer) {
                clearInterval(window.slideTimer);
                window.slideTimer = null;
                safeClass('play-icon', 'remove', 'hidden');
                safeClass('pause-icon', 'add', 'hidden');
            } else {
                const durInput = document.getElementById('slide-duration-select');
                const dur = durInput ? parseInt(durInput.value) : 3000;
                window.slideTimer = setInterval(nextSlide, dur);
                safeClass('play-icon', 'add', 'hidden');
                safeClass('pause-icon', 'remove', 'hidden');
                nextSlide();
            }
        }
        
        // --- UNIVERSAL FULLSCREEN MANAGER ---
        function toggleFullScreen() {
            const doc = window.document;
            const docEl = doc.documentElement;
            const isiPhone = /iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            if (isiPhone) { showToast("Fullscreen not supported on iPhone", "error"); return; }

            const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
            const isFullScreen = doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;

            if (!isFullScreen) {
                if (requestFullScreen) requestFullScreen.call(docEl).catch(err => { showToast("Fullscreen Blocked", "error"); });
            } else {
                if (cancelFullScreen) cancelFullScreen.call(doc);
            }
        }
        
        function loadPrefs() {
				const saved = localStorage.getItem(PREF_KEY);
				if (saved) {
					isRestoring = true; 
					try {
						const prefs = JSON.parse(saved);
						
						// 1. Restore Core Application State
						if (prefs.state) {
							state.nsfw = prefs.state.nsfw || false; 
							state.mode = prefs.state.mode || 'manual';
							state.subject = prefs.state.subject || 'female';
							state.generator = prefs.state.generator || 'gemini'; 
							state.helper = prefs.state.helper || 'auto';
							
							if (typeof setProvider === 'function') setProvider(state.generator); 
							if (prefs.state.theme && typeof changeTheme === 'function') changeTheme(prefs.state.theme);
							if (typeof updateConfigButtons === 'function') updateConfigButtons(); 
							if (typeof setTheme === 'function') setTheme(state.nsfw);
						}

						// Helpers
						const setInp = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined) el.value = val; };
						const setChk = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined) el.checked = val; };

						// 2. Restore Generic Selects
						if (prefs.selects) {
							Object.entries(prefs.selects).forEach(([id, val]) => setInp(id, val));
						}

						// 3. Restore Provider Settings (CORRECTED MAPPING)
						setInp('api-key-input', prefs.apiKey);
						
						if (prefs.cloudflare) {
							setInp('cf-account-id', prefs.cloudflare.account); // Fixed ID
							setInp('cf-api-token', prefs.cloudflare.token);     // Fixed ID
							setInp('cf-steps', prefs.cloudflare.steps);
							setInp('cf-guidance', prefs.cloudflare.guidance);
							setInp('cf-seed', prefs.cloudflare.seed);
						}

						if (prefs.pollSettings) {
							setInp('poll-api-key', prefs.pollSettings.apiKey); // Fixed ID
							setInp('poll-seed', prefs.pollSettings.seed);
							setChk('poll-enhance', prefs.pollSettings.enhance);
							setChk('poll-nologo', prefs.pollSettings.nologo);
							setChk('poll-safe', prefs.pollSettings.safe);
						}

						if (prefs.freepik) {
							setInp('freepik-api-key', prefs.freepik.key);
							setInp('freepik-model-select', prefs.freepik.model);
							setInp('freepik-resolution-select', prefs.freepik.resolution);
							setInp('freepik-safety-select', prefs.freepik.safety);
							setChk('freepik-upsampling', prefs.freepik.upsampling);
							setInp('freepik-style-select', prefs.freepik.style);
							setInp('freepik-guidance', prefs.freepik.guidance);
						}

						if (prefs.magnific) {
							setInp('upscale-opt', prefs.magnific.opt);
							setInp('upscale-engine', prefs.magnific.engine);
							setInp('upscale-creativity', prefs.magnific.creativity);
							setInp('upscale-resemblance', prefs.magnific.resemblance);
							setInp('upscale-hdr', prefs.magnific.hdr);
							setInp('upscale-fractality', prefs.magnific.fractality);
						}
						
						if (prefs.huggingface) {
							setInp('hf-token', prefs.huggingface.token);
							setInp('hf-model-input', prefs.huggingface.model);
							setInp('hf-steps', prefs.huggingface.steps);
							setInp('hf-guidance', prefs.huggingface.guidance);
							setInp('hf-seed', prefs.huggingface.seed);
						}

						isRestoring = false; 
						return prefs.selects || {};
					} catch (e) { 
						console.error("Pref Load Error:", e); 
						isRestoring = false;
					}
				}
				return {};
			}
        function downloadImage(imgUrl, format, promptText) {
            const link = document.createElement('a'); 
            const fname = getSafeFilename(promptText);
            
            const img = new Image(); 
            img.src = imgUrl; 
            img.crossOrigin = "anonymous"; 
            
            img.onload = () => {
                const canvas = document.createElement('canvas'); 
                canvas.width = img.width; 
                canvas.height = img.height;
                const ctx = canvas.getContext('2d'); 
                
                // Draw the image cleanly
                ctx.drawImage(img, 0, 0);
                
                if (format === 'png') {
                    // *** FORCE REAL PNG (Lossless) ***
                    // explicitly asking for image/png ensures the browser converts it
                    const pngUrl = canvas.toDataURL('image/png'); 
                    link.href = pngUrl; 
                    link.download = `${fname}.png`; 
                } 
                else {
                    // JPG (High Quality 95%)
                    const jpgUrl = canvas.toDataURL('image/jpeg', 0.95); 
                    link.href = jpgUrl; 
                    link.download = `${fname}.jpg`; 
                }
                
                link.click();
            };
        }
        
        // NEW CONSTANT FOR CACHE
        const MODEL_KEY = 'promptBuilder_v70_model_cache';

        async function fetchModels() {
            const btn = document.getElementById('fetch-models-btn'); 
            const originalText = btn.innerHTML;
            btn.innerHTML = "FETCHING..."; 
            btn.disabled = true; 
            updateAppStatus('busy', 'FETCHING MODELS...');
            
            const PROXY_BASE = "https://pol-pass.nswlko.workers.dev"; 
            
            // Prepare Cache Object
            let modelCache = JSON.parse(localStorage.getItem(MODEL_KEY) || '{}');

            try {
                // --- GEMINI FETCH ---
                if (state.generator === 'gemini') {
                    const apiKey = document.getElementById('api-key-input')?.value.trim();
                    if(!apiKey) throw new Error("No Key");
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                    if(!response.ok) throw new Error("Gemini API Error: " + response.status);
                    
                    const data = await response.json();
                    
                    // Save to Cache
                    modelCache.gemini = data.models;
                    localStorage.setItem(MODEL_KEY, JSON.stringify(modelCache));
                    
                    // Update UI
                    populateGeminiUI(data.models);
                    showToast(`Loaded ${data.models.length} Gemini models.`);
                } 
                
                // --- POLLINATIONS FETCH ---
                else if (state.generator === 'pollination') {
                    const targetUrl = "https://gen.pollinations.ai/image/models";
                    const proxyUrl = `${PROXY_BASE}?url=${encodeURIComponent(targetUrl)}`;
                    
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error("Failed to fetch model list");
                    
                    const models = await response.json();
                    
                    // Save to Cache
                    modelCache.pollination = models;
                    localStorage.setItem(MODEL_KEY, JSON.stringify(modelCache));
                    
                    // Update UI
                    populatePollinationUI(models);
                    showToast(`Loaded ${models.length} Pollinations models.`);
                } 
                
               // --- PUTER HANDLER (No fetch needed) ---
				else if (state.generator === 'puter') showToast("Puter optimizes models automatically (Flux/SD).", "success");
                else if (state.generator === 'cloudflare') showToast("Cloudflare models are managed manually.", "success");
                
                // Save the selection state immediately after updating lists
                savePrefs();

            } catch (e) {
                console.warn("Fetch Error:", e);
                showToast("Fetch Failed: " + e.message, "error");
                updateAppStatus('error');
            } finally { 
                btn.innerHTML = originalText; 
                btn.disabled = false; 
                setTimeout(() => updateAppStatus('idle'), 2000); 
            }
        }

        // --- UI POPULATION HELPERS (Used by Fetch AND Cache Restore) ---
		window.setHelper = function(helper) {
				state.helper = helper;
				const helpers = ['auto', 'gemini', 'cloudflare'];
				
				helpers.forEach(h => {
					const btn = document.getElementById(`help-${h}`);
					if(btn) {
						btn.classList.remove('btn-active-glow');
						btn.classList.add('text-gray-400', 'bg-transparent');
					}
				});

				const active = document.getElementById(`help-${helper}`);
				if(active) {
					active.classList.remove('text-gray-400', 'bg-transparent');
					active.classList.add('btn-active-glow');
				}
				savePrefs();
			};
        function populateGeminiUI(models) {
            const txtSelect = document.getElementById('text-model-select'); 
            const imgSelect = document.getElementById('model-select'); 
            const scanSelect = document.getElementById('scan-model-select');
            
            if(txtSelect) txtSelect.innerHTML = ""; 
            if(imgSelect) imgSelect.innerHTML = ""; 
            if(scanSelect) scanSelect.innerHTML = "";
            
            const sortedModels = models.sort((a, b) => {
                const nameA = a.name.toLowerCase(), nameB = b.name.toLowerCase();
                const getScore = (n) => { if (n.includes('flash')) return 3; if (n.includes('pro')) return 2; return 1; };
                return getScore(nameB) - getScore(nameA); 
            });

            sortedModels.forEach(m => {
                const name = m.name.replace('models/', '');
                const isImageGen = m.supportedGenerationMethods.includes('predict') || name.includes('image');
                const isText = m.supportedGenerationMethods.includes('generateContent');
                
                if (isImageGen && imgSelect) imgSelect.add(new Option(m.displayName || name, name));
                if (isText && txtSelect) txtSelect.add(new Option(m.displayName || name, name));
                if (isText && scanSelect) scanSelect.add(new Option(m.displayName || name, name));
            });
        }

        function populatePollinationUI(models) {
            const pollSelect = document.getElementById('poll-model-select'); 
            if(!pollSelect) return;
            pollSelect.innerHTML = "";
            
            const knownModels = new Set(['flux', 'flux-realism', 'flux-anime', 'turbo']);
            if (Array.isArray(models)) { 
                models.forEach(m => { 
                    const val = (typeof m === 'string') ? m : m.name; 
                    if(val) knownModels.add(val); 
                }); 
            }
            
            Array.from(knownModels).sort().forEach(m => { 
                pollSelect.add(new Option(m.charAt(0).toUpperCase() + m.slice(1), m)); 
            });
        }
		
		function restoreModelCache() {
            try {
                const cache = JSON.parse(localStorage.getItem(MODEL_KEY) || '{}');
                
                // Restore Gemini Models
                if (cache.gemini && Array.isArray(cache.gemini)) {
                    populateGeminiUI(cache.gemini);
                    console.log("Restored cached Gemini models");
                }
                
                // Restore Pollination Models
                if (cache.pollination && Array.isArray(cache.pollination)) {
                    populatePollinationUI(cache.pollination);
                    console.log("Restored cached Pollination models");
                }
            } catch(e) {
                console.error("Error restoring model cache", e);
            }
        }
		function buildUI() {
            const container = document.getElementById('manual-container');
            const globalSettings = document.getElementById('global-settings');
            
            // 1. Populate Global Settings (Top Bar)
            if(globalSettings) { 
                globalSettings.innerHTML = ''; 
                const savedValues = loadPrefs(); 
                // Safety check for aspectRatioList
                const arList = (typeof aspectRatioList !== 'undefined') ? aspectRatioList : ["1:1 (Square)"];
                createSelect(globalSettings, "Output Format (Aspect Ratio)", arList, "ar", savedValues); 
            }

            // 2. Prepare Lists & State
            const savedValues = loadPrefs(); 
            const isScenery = state.subject === 'scenery';
            
            // Safely get lists or default to empty
            let lists = {};
            try { lists = getActiveLists(); } catch(e) { console.warn("List error:", e); }

            safeClass('action-bar', 'remove', 'hidden', 'translate-y-full');

            // 3. Build Manual Controls
            if (state.mode === 'manual' && container) {
                container.innerHTML = ''; // Clear previous
                safeClass('random-message', 'add', 'hidden'); 
                safeClass(container, 'remove', 'hidden');

                try {
                    container.appendChild(createAccordion("Identity & Type", true, (c) => {
                        createSelect(c, "LoRA Trigger", ["-None-", "Custom"], "lora", savedValues); 
                        createSelect(c, "Image Type", (typeof subjectTypeList !== 'undefined' ? subjectTypeList : []), "type", savedValues);
                        if(!isScenery) { 
                            createSelect(c, "Subject", lists.activeSubjectList, "subject", savedValues); 
                            createSelect(c, "Gender", lists.activeGenderList, "gender", savedValues); 
                            createSelect(c, "Lookalike", lists.activeLookalikeList, "lookalike", savedValues); 
                        }
                    }));

                    if(!isScenery) {
                        container.appendChild(createAccordion("Appearance & Anatomy", false, (c) => {
                            createSelect(c, "Physique", lists.activeBodyTypeList, "body", savedValues); 
                            createSelect(c, "Hips/Pelvis", lists.activePelvisList, "pelvis", savedValues);
                            createSelect(c, "Face Shape", (typeof faceTypeList !== 'undefined' ? faceTypeList : []), "face", savedValues); 
                            createSelect(c, "Eye Color", (typeof eyeColorList !== 'undefined' ? eyeColorList : []), "eyes", savedValues);
                            createSelect(c, "Hair Style", lists.activeHairStyleList, "hair", savedValues); 
                            createSelect(c, "Breasts", lists.activeBreastList, "breasts", savedValues);
                            createSelect(c, "Nipples", lists.activeNippleList, "nipples", savedValues); 
                            createSelect(c, "Nipple Shape", lists.activeNippleShapeList, "nippleShape", savedValues);
                            createSelect(c, "Vagina", lists.activeVaginaList, "vagina", savedValues); 
                            createSelect(c, "Vagina Shape", lists.activeVaginaShapeList, "vaginaShape", savedValues);
                        }));
                        
                        container.appendChild(createAccordion("Wardrobe", false, (c) => { 
                            createSelect(c, "Upper Body", lists.activeUpperBodyList, "upper", savedValues); 
                            createSelect(c, "Lower Body", lists.activeLowerBodyList, "lower", savedValues); 
                            createSelect(c, "Footwear", lists.activeFootwearList, "feet", savedValues); 
                        }));
                        
                        container.appendChild(createAccordion("Accessories", false, (c) => { 
                            createSelect(c, "Head Jewelry", lists.activeHeadJewelry, "jewel_head", savedValues); 
                            createSelect(c, "Ear Jewelry", lists.activeEarJewelry, "jewel_ear", savedValues); 
                            createSelect(c, "Neck Jewelry", lists.activeNeckJewellery, "jewel_neck", savedValues); 
                            createSelect(c, "Arm Jewelry", lists.activeArmJewellery, "jewel_arm", savedValues); 
                            createSelect(c, "Hand Jewelry", lists.activeHandJewellery, "jewel_hand", savedValues); 
                        }));
                    }

                    container.appendChild(createAccordion("Scene & Action", false, (c) => {
                        if(!isScenery) { createSelect(c, "Pose / Position", (typeof subjectPositionList !== 'undefined' ? subjectPositionList : []), "pos", savedValues); }
                        createSelect(c, "Background", (typeof backgrounds !== 'undefined' ? backgrounds : []), "bg", savedValues); 
                        createSelect(c, "Lighting", (typeof lightingList !== 'undefined' ? lightingList : []), "light", savedValues);
                        if(!isScenery) { 
                            createSelect(c, "Activity", lists.activeActivityList, "activity", savedValues); 
                            createSelect(c, "Hand Action", (typeof handPositionList !== 'undefined' ? handPositionList : []), "hands", savedValues); 
                            createSelect(c, "Expression", lists.activeExpressionList, "expression", savedValues); 
                        }
                    }));

                    container.appendChild(createAccordion("Tech & Style", false, (c) => { 
                        createSelect(c, "Camera Shot", (typeof shotList !== 'undefined' ? shotList : []), "shot", savedValues); 
                        createSelect(c, "Camera Lens", (typeof cameraLensList !== 'undefined' ? cameraLensList : []), "lens", savedValues); 
                        createSelect(c, "Art Style", (typeof styleList !== 'undefined' ? styleList : []), "style", savedValues); 
                        createSelect(c, "Visual Effects", lists.activeEffectList, "fx", savedValues); 
                        createSelect(c, "Quality Tags", (typeof qualityList !== 'undefined' ? qualityList : []), "quality", savedValues); 
                    }));

                } catch(e) { console.error("UI Build Error:", e); }
            } else { 
                if(container) safeClass(container, 'add', 'hidden'); 
                safeClass('random-message', 'remove', 'hidden'); 
            }
        }

        function cleanAndFormat(str) {
            if(!str) return "";
            let s = str.replace(/\s+,/g, ',').replace(/\s+\./g, '.').replace(/\.{2,}/g, '.').replace(/,\s*,/g, ',');
            s = s.replace(/,([^\s])/g, ', $1').replace(/\.([^\s])/g, '. $1').trim();
            return s.charAt(0).toUpperCase() + s.slice(1);
        }

        function updateAppStatus(mode, msg) {
            const badge = document.getElementById('status-badge');
            if(!badge) return;
            const base = "px-3 py-1.5 rounded-full border flex items-center gap-2 transition-all duration-300 backdrop-blur-md shadow-lg text-[10px] font-mono font-bold tracking-wide select-none";
            if (mode === 'busy') { badge.className = `${base} bg-yellow-900/20 border-yellow-500/50 text-yellow-400 shadow-yellow-500/20`; badge.innerHTML = `<svg class="animate-spin w-3 h-3 text-yellow-400" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>${msg || "PROCESSING..."}</span>`; } 
            else if (mode === 'error') { badge.className = `${base} bg-red-900/20 border-red-500/50 text-red-400 shadow-red-500/20`; badge.innerHTML = `<svg class="w-3 h-3 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>ERROR</span>`; } 
            else {
                let count = 0; try { count = JSON.parse(localStorage.getItem(FILE_KEY) || "[]").length; } catch(e){}
                // Change 'Puter AI' to 'puter'
				const provMap = { 
								'gemini': 'GEMINI', 
								'cloudflare': 'CLOUDFLARE', 
								'puter': 'PUTER AI', 
								'pollination': 'POLLINATIONS',
								'freepik': 'FREEPIK',
								'huggingface': 'HUGGING FACE' // <-- Added
							};
                const currentProv = provMap[state.generator] || 'UNKNOWN';
                badge.className = `${base} bg-theme-900/20 border-theme-500/30 text-theme-400 shadow-theme-500/10 group hover:shadow-theme-500/30 hover:border-theme-500/60`;
                badge.innerHTML = `<span class="relative flex h-2 w-2"><span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-theme-400 opacity-75"></span><span class="relative inline-flex rounded-full h-2 w-2 bg-theme-500"></span></span><span>${currentProv} • ${count} FILES</span>`;
            }
        }

        function updateOutput(text) {
				// 1. Unhide the container
				safeClass('result-area', 'remove', 'hidden');
				
				const out = document.getElementById('output-text');
				const safeText = text || "No prompt generated.";
				
				if(out) { 
					out.value = safeText; 
					
					// 2. CRITICAL: Wait for the browser to render the 'unhidden' state
					// requestAnimationFrame runs right before the next repaint
					requestAnimationFrame(() => {
						// Trigger the listener we fixed in Step 2
						out.dispatchEvent(new Event('input', { bubbles: true }));
						
						// Double-check just in case of animation lag (CSS fade-in)
						setTimeout(() => {
							out.dispatchEvent(new Event('input', { bubbles: true }));
						}, 100);
					});
				}

				// ... (rest of your button visibility logic remains the same) ...
				// Explicitly handle Visualize Button Visibility (Safety Net)
				const btn = document.getElementById('visualize-btn');
				if(state.nsfw && state.generator === 'gemini') { 
					if(btn) safeClass(btn, 'add', 'hidden'); 
				} else { 
					if(btn) { 
						btn.classList.remove('hidden'); 
						btn.style.display = 'inline-flex'; 
					} 
				}

				document.getElementById('scan-btn').disabled = false;
				document.getElementById('enhance-btn').disabled = false;
				
				const scroll = document.getElementById('main-scroll');
				if(scroll) {
					setTimeout(() => {
						scroll.scrollTo({ top: scroll.scrollHeight, behavior: 'smooth' });
					}, 200);
				}
			}

        function addToHistory(text, provider) {
            if(!text) return;
            let hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
            const newItem = { text: text, provider: provider || 'UNKNOWN', date: Date.now() };
            hist.unshift(newItem);
            if(hist.length > 50) hist.pop();
            localStorage.setItem(HIST_KEY, JSON.stringify(hist));
        }

        function renderHistory() {
            const list = document.getElementById('history-list');
            if(!list) return;
            const hist = JSON.parse(localStorage.getItem(HIST_KEY) || "[]");
            if(hist.length === 0) list.innerHTML = '<p class="text-center text-gray-500 text-xs italic py-10">No history yet.</p>';
            else {
                list.innerHTML = hist.map((item, index) => {
                    const text = (typeof item === 'string') ? item : item.text;
                    const prov = (typeof item === 'string') ? 'UNKNOWN' : item.provider;
                    return `<div class="bg-gray-800/50 p-3 rounded-lg border border-gray-700 hover:border-theme-500 transition-all group"><div class="flex justify-between items-center mb-1"><span class="text-[10px] font-bold text-theme-400 bg-theme-900/30 px-1.5 rounded border border-theme-500/20">${prov}</span><span class="text-[9px] text-gray-600">ID: ${index}</span></div><p class="text-xs text-gray-300 font-mono line-clamp-3 mb-2">${text}</p><div class="flex gap-2"><button onclick="restoreHistory(${index})" class="px-2 py-1 bg-theme-900/40 text-theme-400 rounded text-[10px] font-bold border border-theme-500/30 hover:bg-theme-600 hover:text-white transition-colors">RESTORE</button><button onclick="deleteHistory(${index})" class="px-2 py-1 bg-red-900/20 text-red-400 rounded text-[10px] font-bold border border-red-900/30 hover:bg-red-900/50 transition-colors">DEL</button></div></div>`;
                }).join('');
            }
        }
        
			// --- GENERATORS ---
			
			// ==========================================
            //  MAIN GENERATOR ROUTER (REQUIRED)
            // ==========================================
            async function generateImage(prompt, negative, inputImg = null) {
                // 1. Check Limits & Auth (If you have this system)
                if (typeof checkGenerations === 'function') {
                    if (!checkGenerations()) return;
                }

                showLoadingState();
                
                // 2. Generate a Random Seed
                const seed = Math.floor(Math.random() * 1000000000);

                console.group("🚀 Generator Router");
                console.log("Provider:", state.generator.toUpperCase());
                console.log("Input Image Present?", !!inputImg);
                
                try {
                    // 3. ROUTE TO THE CORRECT PROVIDER
                    if (state.generator === 'pollination') {
                        // Calls the Pollinations function we just fixed
                        await generatePollination(prompt, negative, seed, inputImg);
                    } 
                    else if (state.generator === 'flux') {
                        // Flux usually maps to Pollinations in your setup
                        await generatePollination(prompt, negative, seed, inputImg);
                    }
                    else if (state.generator === 'huggingface') {
                        // If you have a HuggingFace function
                        if (typeof generateHuggingFace === 'function') {
                            await generateHuggingFace(prompt, negative, seed, inputImg);
                        } else {
                            throw new Error("HuggingFace function is missing.");
                        }
                    }
                    else if (state.generator === 'gemini') {
                        // Gemini is strictly text-to-image (no img2img support in standard setup)
                        if (typeof generateGemini === 'function') {
                            await generateGemini(prompt, negative, seed);
                        } else {
                             throw new Error("Gemini function is missing.");
                        }
                    }
                    else {
                        // Default Fallback -> Pollinations
                        console.warn("Unknown provider, defaulting to Pollination");
                        await generatePollination(prompt, negative, seed, inputImg);
                    }

                } catch (e) {
                    console.error("Router Critical Error:", e);
                    if (typeof showToast === 'function') showToast(e.message, "error");
                    hideLoadingState();
                } finally {
                    console.groupEnd();
                }
            }
			// --- GEMINI LAUNCHER (Synced with Generator Logic) ---
				function openGeminiWeb() {
					// 1. Capture Prompt
					const promptBox = document.getElementById('output-text');
					const prompt = (promptBox && promptBox.value) ? promptBox.value : "";
					const neg = document.getElementById('negative-prompt')?.value || "";

					if (!prompt) {
						showToast("Generate a prompt first!", "warning");
						return;
					}

					// 2. Resolve Aspect Ratio (Mirroring GeneratePollination logic)
					let finalAr = "1:1";
					
					// A. Check Custom Input First (Priority)
					const customInput = document.getElementById('ar_custom');
					if (customInput && customInput.value.trim()) {
						finalAr = customInput.value.trim();
					} 
					// B. Check Dropdown Second (Fallback)
					else {
						const arSelect = document.getElementById('ar');
						if (arSelect && arSelect.value) {
							finalAr = arSelect.value;
						}
					}

					// 3. Construct Gemini-Friendly Command
					// Gemini handles natural language best, so we map common ratios or pass custom ones directly
					let arCommand = "";
					
					// Normalize string (remove descriptions like " (Square)")
					let cleanAr = finalAr.split('(')[0].trim(); 

					if (cleanAr !== "1:1") {
						const map = {
							"16:9": "Wide 16:9 Cinematic",
							"9:16": "Tall 9:16 Portrait",
							"4:3": "Landscape 4:3",
							"3:4": "Vertical 3:4",
							"21:9": "Ultra-Wide 21:9",
							"2:3": "Classic Portrait 2:3",
							"3:2": "Classic Landscape 3:2",
							"1:1": "Square 1:1"
						};
						// Use mapped value OR raw value (e.g. if user typed "1024x768")
						const arDesc = map[cleanAr] || `Custom Aspect Ratio (${cleanAr})`;
						arCommand = `[Generate a ${arDesc} image]`;
					}

					// 4. Build Payload
					let finalPayload = "";
					
					// Prefix AR Command (Priority)
					if (arCommand) finalPayload += `${arCommand}\n\n`;
					
					// Prompt
					finalPayload += prompt;

					// Negatives
					if (neg && neg.length > 2) {
						finalPayload += `\n\n[IMPORTANT - AVOID THE FOLLOWING]: ${neg}`;
					}

					// 5. Copy & Launch
					navigator.clipboard.writeText(finalPayload).then(() => {
						showToast(`Copied! (${cleanAr}) Opening Gemini...`, "success");
						window.open('https://gemini.google.com/app', '_blank');
					}).catch(err => {
						console.error("Clipboard failed:", err);
						window.open('https://gemini.google.com/app', '_blank');
					});
				}
				
					// --- GEMINI IMPORT LISTENER (Fixes Ghosts, iPhone & Duplicates) ---
					const importBtn = document.getElementById('gemini-import-btn');

					if (importBtn) {
						// FIX 2: Use .onclick to ensure only ONE listener exists
						importBtn.onclick = async () => {
							try {
								// FIX 3: KILL THE GHOST (Critical)
								// The Visualize button leaves a "save on load" trigger active. 
								// We must kill it before loading the imported image.
								const img = document.getElementById('generated-image');
								if (img) img.onload = null; 

								// 1. Cancel any background states
								if (typeof state !== 'undefined') state.isGenerating = false;

								// 2. Read Clipboard (iPhone/Safari Compatible)
								// We must read 'types' to support iOS stricter privacy model
								const clipboardItems = await navigator.clipboard.read();
								let foundImage = false;

								for (const item of clipboardItems) {
									// Check for image types safely
									const imageType = item.types.find(t => t.includes('image'));
									
									if (imageType) {
										const blob = await item.getType(imageType);
										const url = URL.createObjectURL(blob);
										
										// 3. Display Image
										if (img) {
											img.src = url;
											img.classList.remove('hidden');
											
											// Clean UI
											document.getElementById('img-loading')?.classList.add('hidden');
											document.getElementById('img-actions')?.classList.remove('hidden');
											document.getElementById('visualizer-container')?.classList.remove('hidden');
										}

										// 4. Save to Persistent Gallery
										const reader = new FileReader();
										reader.onloadend = function() {
											const base64data = reader.result;
											
											// Grab Prompt from Output Box (or fallback to Input)
											const outBox = document.getElementById('output-text');
											const finalPrompt = (outBox && outBox.value) ? outBox.value : "Imported from Gemini";
											
											// Check for Negative Prompt
											let neg = "";
											if (typeof getActiveNegativePrompt === 'function') {
												neg = getActiveNegativePrompt();
											}

											// Save to Database
											if (typeof GalleryManager !== 'undefined') {
												// Pass 'GEM-WEB' as the provider tag
												GalleryManager.saveImage(base64data, finalPrompt, 'GEM-WEB', null, neg);
												showToast("Image Imported & Saved", "success");
											}
										};
										reader.readAsDataURL(blob);

										foundImage = true;
										break; // Stop after first image
									}
								}

								if (!foundImage) {
									showToast("No image in clipboard. Copy image first!", "warning");
								}

							} catch (err) {
								console.error("Import Error:", err);
								if (err.name === 'NotAllowedError') {
									showToast("Privacy Block: Please click 'Paste' on the popup.", "error");
								} else {
									showToast("Import failed. Try copying the image again.", "error");
								}
							}
						};
					}
					
					// =================================================================
//  GROK WEB HANDLER (Synced with Generator Logic)
// =================================================================
function openGrokWeb() {
    // 1. Capture Prompt
    const promptBox = document.getElementById('output-text');
    const prompt = (promptBox && promptBox.value) ? promptBox.value : "";
    const neg = document.getElementById('negative-prompt')?.value || "";

    if (!prompt) {
        showToast("Generate a prompt first!", "warning");
        return;
    }

    // 2. Resolve Aspect Ratio
    let finalAr = "1:1";
    const customInput = document.getElementById('ar_custom');
    if (customInput && customInput.value.trim()) {
        finalAr = customInput.value.trim();
    } else {
        const arSelect = document.getElementById('ar');
        if (arSelect && arSelect.value) {
            finalAr = arSelect.value;
        }
    }

    // 3. Construct Command
    let arCommand = "";
    let cleanAr = finalAr.split('(')[0].trim(); 

    if (cleanAr !== "1:1") {
        const map = {
            "16:9": "Wide 16:9 Cinematic",
            "9:16": "Tall 9:16 Portrait",
            "4:3": "Landscape 4:3",
            "3:4": "Vertical 3:4",
            "21:9": "Ultra-Wide 21:9",
            "2:3": "Classic Portrait 2:3",
            "3:2": "Classic Landscape 3:2",
            "1:1": "Square 1:1"
        };
        const arDesc = map[cleanAr] || `Custom Aspect Ratio (${cleanAr})`;
        arCommand = `[Generate a ${arDesc} image]`;
    }

    // 4. Build Payload
    let finalPayload = "";
    if (arCommand) finalPayload += `${arCommand}\n\n`;
    finalPayload += prompt;
    if (neg && neg.length > 2) {
        finalPayload += `\n\n[IMPORTANT - AVOID THE FOLLOWING]: ${neg}`;
    }

    // 5. Copy & Launch
    navigator.clipboard.writeText(finalPayload).then(() => {
        showToast(`Copied! (${cleanAr}) Opening Grok...`, "success");
        window.open('https://grok.com', '_blank');
    }).catch(err => {
        console.error("Clipboard failed:", err);
        window.open('https://grok.com', '_blank');
    });
}

// --- GROK IMPORT LISTENER ---
// (Synced with your "Ghost Killer" logic)
const grokImportBtn = document.getElementById('grok-import-btn');
if (grokImportBtn) {
    grokImportBtn.onclick = async () => {
        try {
            // KILL THE GHOST (Stop Visualizer Loading)
            const img = document.getElementById('generated-image');
            if (img) img.onload = null; 

            // Cancel background states
            if (typeof state !== 'undefined') state.isGenerating = false;

            // Read Clipboard (iOS Compatible)
            const clipboardItems = await navigator.clipboard.read();
            let foundImage = false;

            for (const item of clipboardItems) {
                const imageType = item.types.find(t => t.includes('image'));
                
                if (imageType) {
                    const blob = await item.getType(imageType);
                    const url = URL.createObjectURL(blob);
                    
                    // Display Image
                    if (img) {
                        img.src = url;
                        img.classList.remove('hidden');
                        document.getElementById('img-loading')?.classList.add('hidden');
                        document.getElementById('img-actions')?.classList.remove('hidden');
                        document.getElementById('visualizer-container')?.classList.remove('hidden');
                    }

                    // Save to Persistent Gallery
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        const base64data = reader.result;
                        const outBox = document.getElementById('output-text');
                        const finalPrompt = (outBox && outBox.value) ? outBox.value : "Imported from Grok";
                        
                        let neg = "";
                        if (typeof getActiveNegativePrompt === 'function') {
                            neg = getActiveNegativePrompt();
                        }

                        // SAVE with 'GROK-WEB' tag
                        if (typeof GalleryManager !== 'undefined') {
                            GalleryManager.saveImage(base64data, finalPrompt, 'GROK-WEB', null, neg);
                            showToast("Image Imported (Grok)", "success");
                        }
                    };
                    reader.readAsDataURL(blob);

                    foundImage = true;
                    break;
                }
            }

            if (!foundImage) {
                showToast("No image in clipboard.", "warning");
            }

        } catch (err) {
            console.error("Import Error:", err);
            if (err.name === 'NotAllowedError') {
                showToast("Privacy Block: Click 'Paste' on the popup.", "error");
            } else {
                showToast("Import failed.", "error");
            }
        }
    };
}


				// =================================================================
				//  CHATGPT WEB HANDLER (Synced with Generator Logic)
				// =================================================================
				function openChatGPTWeb() {
					// 1. Capture Prompt
					const promptBox = document.getElementById('output-text');
					const prompt = (promptBox && promptBox.value) ? promptBox.value : "";
					const neg = document.getElementById('negative-prompt')?.value || "";

					if (!prompt) {
						showToast("Generate a prompt first!", "warning");
						return;
					}

					// 2. Resolve Aspect Ratio
					let finalAr = "1:1";
					const customInput = document.getElementById('ar_custom');
					if (customInput && customInput.value.trim()) {
						finalAr = customInput.value.trim();
					} else {
						const arSelect = document.getElementById('ar');
						if (arSelect && arSelect.value) {
							finalAr = arSelect.value;
						}
					}

					// 3. Construct Command
					let arCommand = "";
					let cleanAr = finalAr.split('(')[0].trim(); 

					if (cleanAr !== "1:1") {
						const map = {
							"16:9": "Wide 16:9 Cinematic",
							"9:16": "Tall 9:16 Portrait",
							"4:3": "Landscape 4:3",
							"3:4": "Vertical 3:4",
							"21:9": "Ultra-Wide 21:9",
							"2:3": "Classic Portrait 2:3",
							"3:2": "Classic Landscape 3:2",
							"1:1": "Square 1:1"
						};
						const arDesc = map[cleanAr] || `Custom Aspect Ratio (${cleanAr})`;
						arCommand = `[Generate a ${arDesc} image]`;
					}

					// 4. Build Payload
					let finalPayload = "";
					if (arCommand) finalPayload += `${arCommand}\n\n`;
					finalPayload += prompt;
					if (neg && neg.length > 2) {
						finalPayload += `\n\n[IMPORTANT - AVOID THE FOLLOWING]: ${neg}`;
					}

					// 5. Copy & Launch
					navigator.clipboard.writeText(finalPayload).then(() => {
						showToast(`Copied! (${cleanAr}) Opening ChatGPT...`, "success");
						window.open('https://chatgpt.com', '_blank');
					}).catch(err => {
						console.error("Clipboard failed:", err);
						window.open('https://chatgpt.com', '_blank');
					});
				}

				// --- CHATGPT IMPORT LISTENER ---
				// (Synced with your "Ghost Killer" logic)
				const gptImportBtn = document.getElementById('chatgpt-import-btn');
				if (gptImportBtn) {
					gptImportBtn.onclick = async () => {
						try {
							// KILL THE GHOST (Stop Visualizer Loading)
							const img = document.getElementById('generated-image');
							if (img) img.onload = null; 

							// Cancel background states
							if (typeof state !== 'undefined') state.isGenerating = false;

							// Read Clipboard (iOS Compatible)
							const clipboardItems = await navigator.clipboard.read();
							let foundImage = false;

							for (const item of clipboardItems) {
								const imageType = item.types.find(t => t.includes('image'));
								
								if (imageType) {
									const blob = await item.getType(imageType);
									const url = URL.createObjectURL(blob);
									
									// Display Image
									if (img) {
										img.src = url;
										img.classList.remove('hidden');
										document.getElementById('img-loading')?.classList.add('hidden');
										document.getElementById('img-actions')?.classList.remove('hidden');
										document.getElementById('visualizer-container')?.classList.remove('hidden');
									}

									// Save to Persistent Gallery
									const reader = new FileReader();
									reader.onloadend = function() {
										const base64data = reader.result;
										const outBox = document.getElementById('output-text');
										const finalPrompt = (outBox && outBox.value) ? outBox.value : "Imported from ChatGPT";
										
										let neg = "";
										if (typeof getActiveNegativePrompt === 'function') {
											neg = getActiveNegativePrompt();
										}

										// SAVE with 'GPT-WEB' tag
										if (typeof GalleryManager !== 'undefined') {
											GalleryManager.saveImage(base64data, finalPrompt, 'GPT-WEB', null, neg);
											showToast("Image Imported (ChatGPT)", "success");
										}
									};
									reader.readAsDataURL(blob);

									foundImage = true;
									break;
								}
							}

							if (!foundImage) {
								showToast("No image in clipboard.", "warning");
							}

						} catch (err) {
							console.error("Import Error:", err);
							if (err.name === 'NotAllowedError') {
								showToast("Privacy Block: Click 'Paste' on the popup.", "error");
							} else {
								showToast("Import failed.", "error");
							}
						}
					};
				}
					
			// ==========================================
//  POLLINATIONS GENERATOR (FINAL: URL FIX + LOG WINDOW)
// ==========================================
async function generatePollination(prompt, negOrAr, seed, inputB64 = null) {
    
    console.group("🚀 POLLINATIONS DEBUG START");
    console.log("1. Raw Inputs:", { prompt, negOrAr, seed, hasInputImage: !!inputB64 });

    // 1. SAFETY: WAIT FOR UI
    const modelEl = await waitForDOM('poll-model-select').catch(e => null);
    const selectedModel = (modelEl && modelEl.value) ? modelEl.value : 'flux'; 
    console.log("2. Selected Model:", selectedModel);
    
    // 2. DIMENSION LOGIC
    let width = 768; 
    let height = 1344;
    
    // Resolve Args
    let negative = "";
    let arValue = "1:1";

    // 1. Determine Aspect Ratio & Negative Prompt Source
    if (negOrAr && (negOrAr.includes(':') || negOrAr === "1:1")) {
        // Scenario A: Argument is Aspect Ratio
        arValue = negOrAr;
        negative = document.getElementById('negative-prompt')?.value || ""; 
    } else {
        // Scenario B: Argument is Negative Prompt (or empty)
        // Check if argument is valid and NOT the string "undefined"
        if (negOrAr && negOrAr !== "undefined") {
            negative = negOrAr;
        } else {
            negative = document.getElementById('negative-prompt')?.value || "";
        }
        
        const arEl = document.getElementById('ar');
        if (arEl) arValue = arEl.value;
    }

    // CRITICAL FIX: Final Sanitization
    // Prevents sending the text "undefined" or "null" to the AI
    if (!negative || negative === "undefined" || negative === "null") {
        negative = "";
    }

    // Custom Dimensions
    const customInput = document.getElementById('ar_custom');
    const customVal = customInput ? customInput.value.trim() : "";
    const customMatch = customVal.match(/(\d+)[\sx:,]+(\d+)/);

    if (customMatch) {
        width = parseInt(customMatch[1]);
        height = parseInt(customMatch[2]);
    } else {
        const dims = getPixelDimensions(arValue);
        width = dims.width;
        height = dims.height;
    }

    // 3. PROMPT DECODING
    const decoder = document.createElement('textarea'); 
    decoder.innerHTML = prompt;
    const cleanPrompt = decoder.value;
    
    // 4. HANDLE IMG2IMG
    let imgUrlParam = null;
    if (inputB64) {
        console.log("5. Img2Img Detected. Uploading...");
        updateAppStatus('busy', 'UPLOADING SOURCE...');
        
        // We trust uploadToTempHost handles the upload. 
        // If it fails, it returns null, and we throw error below.
        const publicUrl = await uploadToTempHost(inputB64);
        if (publicUrl && publicUrl.startsWith('http')) {
            imgUrlParam = publicUrl;
            console.log("✅ Img2Img Upload Success:", publicUrl);
        } else {
            throw new Error("Source image upload failed. Please try again.");
        }
    }

    // 5. SEED SANITIZATION
    let safeSeed = seed;
    if (safeSeed === undefined || safeSeed === null || isNaN(safeSeed)) {
        safeSeed = Math.floor(Math.random() * 1000000000);
        console.log("⚠️ Seed was undefined. Generated new seed:", safeSeed);
    } else {
        console.log("✅ Using provided seed:", safeSeed);
    }

    // 6. PREPARE ENDPOINT & PARAMS
    const finalWidth = width * 2;
    const finalHeight = height * 2;

    // --- NEW: CALCULATE ASPECT RATIO ---
    const finalAspectRatio = customMatch ? `${width}:${height}` : arValue;

    // URL CONSTRUCTION FIX:
    // The API requires the prompt to be in the PATH: /prompt/MyPrompt
    const encodedPrompt = encodeURIComponent(cleanPrompt);
    const baseUrl = `https://gen.pollinations.ai/image/prompt/${encodedPrompt}`;

    const params = new URLSearchParams({
        // Note: 'prompt' is removed from here because it is now in the URL path
        width: finalWidth,
        height: finalHeight,
        
        seed: safeSeed,
        model: selectedModel,
        nofeed: 'true',
        nologo: 'true',
        quality: 'high',        
        private: 'true',
        strength: '0.45',
        guidance_scale: 5,
        safe: (document.getElementById('poll-safe')?.checked || false).toString(),
        enhance: (document.getElementById('poll-enhance')?.checked || false).toString()
    });

    // CRITICAL FIX: Use 'negative_prompt' (Not 'negative')
    if (negative) params.append('negative_prompt', negative);
    
    if (imgUrlParam) params.append('image', imgUrlParam);

    // 7. API KEY LOGIC
    const apiKey = (document.getElementById('poll-api-key')?.value || "").trim();
    const headers = {};
    
    if (apiKey) {
        params.append("key", apiKey);
        headers['Authorization'] = `Bearer ${apiKey}`;
    }

    // 8. FINAL URL CONSTRUCTION
    updateAppStatus('busy', `GENERATING (${selectedModel.toUpperCase()})...`);
    
    // Construct final URL with Query Params
    const finalUrl = `${baseUrl}?${params.toString()}`;
    
    console.log("🔥 FINAL URL:", finalUrl);

    const fetchOptions = {
        method: 'GET',
        cache: 'no-store',
        headers: headers
    };

    try {
        console.log("7. Fetching...");
        const response = await fetch(finalUrl, fetchOptions);
        
        console.log("8. Response Status:", response.status);
        
        if (!response.ok) {
            const errText = await response.text();
            
            // SPECIFIC ERROR HANDLER for Img2Img Timeouts
            if (errText.includes("fetch failed")) {
                console.warn("Pollinations could not download image from host.");
                throw new Error("Source image upload failed (Host Blocked/Timeout). Try a different image.");
            }

            console.error("API Error Body:", errText);
            // Pass the status code so we can identify 500s later
            throw new Error(`Pollinations Error ${response.status}: ${errText}`);
        }

        const blob = await response.blob();
        console.log("9. Blob Received:", blob.type, blob.size);

        // 9. CONVERT TO BASE64
        const base64Data = await blobToBase64(blob);
        
        // 10. UPDATE UI & SAVE
        const imgTag = document.getElementById('generated-image');
        if (imgTag) {
            imgTag.onload = () => { 
                safeClass('img-loading', 'add', 'hidden'); 
                safeClass('generated-image', 'remove', 'hidden'); 
                safeClass('img-actions', 'remove', 'hidden');
                safeClass('visualizer-container', 'remove', 'hidden');

                const serviceName = `POLLI > ${selectedModel.toUpperCase()}`;
                
                if (typeof GalleryManager !== 'undefined') {
                    GalleryManager.saveImage(base64Data, cleanPrompt, serviceName, inputB64, negative);
                }
                if (typeof addToHistory === 'function') {
                    addToHistory(cleanPrompt, serviceName);
                }

                const genBtn = document.getElementById('generate-btn');
                if(genBtn) {
                    genBtn.disabled = false;
                    genBtn.innerHTML = "GENERATE"; 
                }
                updateAppStatus('idle');
                console.log("✅ GENERATION COMPLETE");
                console.groupEnd();
            };
            imgTag.src = base64Data;
        }
        
        return base64Data;

    } catch (e) {
        console.error("❌ Pollination Critical Error:", e);
        console.groupEnd();

        // 1. Reset UI State first
        hideLoadingState();

        // 2. LOG WINDOW INTEGRATION
        // We do this AFTER hiding loading state to ensure the window stays visible
        const logWindow = document.getElementById('horde-log-window');
        const content = document.getElementById('horde-log-content');
        
        if (logWindow && content) {
            let friendlyMsg = "❌ GENERATION FAILED\nThe AI service rejected the request.";
            let rawDebug = e.message || JSON.stringify(e);
            
            // Heuristics for friendly messages
            if (rawDebug.includes("500") || rawDebug.includes("Internal Server Error")) {
                friendlyMsg = "❌ SERVER ERROR (500)\nThe Pollinations API crashed. This usually happens if the Prompt is too long or the Settings are too complex (Level X). Try reducing prompt detail.";
            } else if (rawDebug.includes("429")) {
                friendlyMsg = "⏳ RATE LIMIT EXCEEDED\nToo many requests. Please wait a moment.";
            } else if (rawDebug.includes("414") || rawDebug.includes("URI Too Long")) {
                friendlyMsg = "❌ PROMPT TOO LONG\nThe URL exceeded server limits. Try a shorter prompt.";
            } else if (rawDebug.includes("Source image upload failed")) {
                friendlyMsg = "⚠️ IMAGE UPLOAD FAILED\nThe AI could not access your source image.";
            }

            // Inject Content
            content.innerHTML = `
                <div class="mb-3 p-2 bg-red-900/20 border border-red-500/30 rounded text-red-200 font-bold whitespace-pre-wrap leading-relaxed">${friendlyMsg}</div>
                <div class="text-[9px] text-gray-500 font-mono uppercase tracking-widest mb-1">RAW API RESPONSE:</div>
                <div class="text-[9px] text-gray-400 font-mono whitespace-pre-wrap border-l-2 border-gray-700 pl-2 select-text overflow-x-auto">${rawDebug}</div>
                
                <div class="mt-4 pt-2 border-t border-white/10 text-center">
                    <button onclick="document.getElementById('horde-log-window').classList.add('hidden')" class="w-full py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg shadow-lg transition-all text-xs tracking-widest">
                        ACKNOWLEDGE & CLOSE
                    </button>
                </div>
            `;
            
            // Force Visible
            logWindow.classList.remove('hidden');
        } else {
            // Fallback if log window DOM element is missing
            if (typeof showToast === 'function') showToast(e.message, "error");
        }

        return null;
    }
}		
			
		async function generateGemini(prompt, arValue) {
            const apiKey = document.getElementById('api-key-input')?.value.trim();
            const modelSelect = document.getElementById('model-select');
            const MODEL_NAME = (modelSelect && modelSelect.value) ? modelSelect.value : "imagen-3.0-generate-001";
            if(!apiKey) { showToast("Please enter a Gemini API Key.", "error"); return null; }
            
            const { param: ratioParam, desc: arText } = getGeminiRatio(arValue);
            
            // *** UPDATED LINE ***
            const negPrompt = getActiveNegativePrompt(); // Only sends if open

            let url, body;
            
            if (MODEL_NAME.includes('imagen')) {
                url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:predict?key=${apiKey}`;
                body = { instances: [{ prompt: prompt }], parameters: { sampleCount: 1, aspectRatio: ratioParam, safetyFilterLevel: "block_only_high", personGeneration: "allow_adult" } };
                if (negPrompt) body.parameters.negativePrompt = negPrompt;
            } else {
                url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;
                let finalPrompt = `Generate a photorealistic image. ${arText}. Prompt: ${prompt}`;
                if (negPrompt) finalPrompt += ` (Exclude: ${negPrompt})`;
                body = { contents: [{ parts: [{ text: finalPrompt }] }], generationConfig: { responseModalities: ["IMAGE"] } };
            }

            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || response.statusText);
            
            let base64String = null; let mimeType = "image/png";
            if (data.candidates?.[0]?.content?.parts) {
                const part = data.candidates[0].content.parts.find(p => p.inlineData);
                if (part) { base64String = part.inlineData.data; mimeType = part.inlineData.mimeType || "image/png"; }
            } else if (data.predictions && data.predictions[0]) { base64String = data.predictions[0].bytesBase64Encoded; }
            
            if (base64String) return `data:${mimeType};base64,${base64String}`;
            throw new Error("No image data returned.");
        }

        async function generateCloudflare(prompt, arValue) {
            const accountId = document.getElementById('cf-account-id')?.value.trim();
            const apiToken = document.getElementById('cf-api-token')?.value.trim();
            const model = document.getElementById('cf-model-select')?.value || '@cf/bytedance/stable-diffusion-xl-lightning';
            const WORKER_URL = "https://pb-vision-proxy.nswlko.workers.dev/"; 
            
            if(!accountId || !apiToken) { showToast("Missing Cloudflare Credentials", "error"); return null; }
            const steps = parseInt(document.getElementById('cf-steps')?.value) || 20; 
            const guidance = parseFloat(document.getElementById('cf-guidance')?.value) || 7.5;
            let seedVal = document.getElementById('cf-seed')?.value; 
            if(!seedVal) seedVal = Math.floor(Math.random() * 2147483647).toString();
            
            // *** UPDATED LINE ***
            const negPrompt = getActiveNegativePrompt(); // Only sends if open
            
            const { width, height } = getPixelDimensions(arValue);
            const isFlux = model.includes('flux');
            const safePrompt = sanitizePrompt(prompt);

            let payload = { accountId: accountId, apiToken: apiToken, model: model, prompt: safePrompt, width: width, height: height, seed: parseInt(seedVal, 10) };
            if (!isFlux) { payload.num_steps = steps; payload.guidance = guidance; if(negPrompt) payload.negative_prompt = negPrompt; } else { payload.num_steps = 4; }

            try {
                const resp = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const respClone = resp.clone(); 
                if (resp.ok) {
                    const blob = await resp.blob(); 
                    if (blob.size < 500) { const textBody = await respClone.text(); throw new Error(`Worker Error: ${textBody.substring(0, 80)}`); }
                    return blob; 
                }
                const textBody = await respClone.text();
                let errData; try { errData = JSON.parse(textBody); } catch(e) { throw new Error(`Proxy Error: ${textBody}`); }
                const msg = errData.error || (errData.result && errData.result.error) || (errData.errors && errData.errors[0]?.message) || JSON.stringify(errData);
                throw new Error("API Error: " + msg);
            } catch (e) { console.error("Gen Error:", e); throw new Error(e.message.replace(/API Error: Proxy Error: /i, '')); }
        }
			async function generateHuggingFace(prompt, arValue) {
					const token = document.getElementById('hf-token')?.value.trim();
					// Use the input box, allowing custom overrides
					const model = document.getElementById('hf-model-input')?.value.trim() || 'black-forest-labs/FLUX.1-dev';
					
					if(!token) { 
						showToast("Hugging Face Token Required", "error"); 
						throw new Error("Missing API Token"); 
					}

					// Safe parsing with defaults
					const steps = parseInt(document.getElementById('hf-steps')?.value) || 25;
					const guidance = parseFloat(document.getElementById('hf-guidance')?.value) || 7.5;
					let seed = document.getElementById('hf-seed')?.value;
					if(!seed) seed = Math.floor(Math.random() * 2147483647);

					// Get Dimensions
					const { width, height } = getPixelDimensions(arValue);
					
					// Construct Payload
					const payload = {
						inputs: prompt,
						parameters: {
							width: width,
							height: height,
							num_inference_steps: steps,
							guidance_scale: guidance,
							seed: parseInt(seed),
							negative_prompt: getActiveNegativePrompt()
						}
					};

					updateAppStatus('busy', `HF INFERENCE (${width}x${height})...`);

					try {
						// *** FIX: USE YOUR CLOUDFLARE WORKER ***
						// Your worker expects: https://worker.dev/proxy/model_id
						const workerUrl = "https://hf-proxy.nswlko.workers.dev";
						const targetUrl = `${workerUrl}/proxy/${model}`;
						
						const response = await fetch(targetUrl, {
							method: "POST",
							headers: {
								"Authorization": `Bearer ${token}`,
								"Content-Type": "application/json",
								"X-Provider": "hf-inference" // Explicitly requests standard inference
							},
							body: JSON.stringify(payload)
						});

						if (!response.ok) {
							const errJson = await response.json();
							// Handle "Model Loading" state (Common with free HF tier)
							if (errJson.error && errJson.error.includes("currently loading")) {
								const waitTime = Math.ceil(errJson.estimated_time || 20);
								throw new Error(`Model Loading... Try again in ${waitTime}s`);
							}
							throw new Error(errJson.error || `HF Error ${response.status}`);
						}

						const blob = await response.blob();
						return blob;

					} catch (e) {
						console.error(e);
						throw new Error(e.message);
					}
				}
       async function generatePuter(prompt, ...args) {
					// 1. Safety Check
					if (typeof puter === 'undefined') throw new Error("Puter.js library not loaded.");

					// 2. Auth Logic
					if (!puter.auth.isSignedIn()) {
						try { await puter.auth.signIn({ attempt_temp_user_creation: true }); } 
						catch (e) { await puter.auth.signIn(); }
					}

					// 3. Resolve Dimensions
					let arString = "1:1"; 
					const targetSelect = document.getElementById('ar');
					if (targetSelect) arString = targetSelect.value;
					else {
						// Fallback scan
						const allSelects = document.querySelectorAll('select');
						for (const select of allSelects) {
							if (select.innerHTML.includes("9:16")) { arString = select.value; break; }
						}
					}
					
					// Get raw pixel values
					const { width, height } = getPixelDimensions(arString);

					// 4. Model Selection
					const modelSelect = document.getElementById('puter-model');
					const selectedModel = modelSelect ? modelSelect.value : 'black-forest-labs/FLUX.1-schnell';
					
					updateAppStatus('busy', `GENERATING (${width}x${height})...`);

					// 5. Build Options based on Provider Type
					let options = {
						model: selectedModel,
						negative_prompt: getActiveNegativePrompt()
					};

					// --- CRITICAL FIX: Parameter Mapping ---
					if (selectedModel.includes('dall') || selectedModel.includes('gpt-image') || selectedModel.includes('imagen') || selectedModel.includes('gemini')) {
						// OpenAI & Google models in Puter.js v2 prefer the 'ratio' object
						options.ratio = { w: width, h: height };
					} else {
						// Flux, Stable Diffusion, and others expect explicit width/height integers
						options.width = width;
						options.height = height;
					}

					// 6. Generate
					try {
						const imgElement = await puter.ai.txt2img(prompt, options);
						
						if (imgElement && imgElement.src) {
							return imgElement.src;
						} else {
							throw new Error("No image data returned.");
						}

					} catch (e) {
						console.error("Puter Error:", e);
						if (e.toString().includes("400")) {
							 localStorage.removeItem('puter.auth.token');
							 throw new Error("Auth corrupted. Please reload.");
						}
						throw new Error("Puter Failed: " + e.message);
					}
				}
		// ==========================================
        //  FREEPIK PROVIDER (Flux 1.1 Pro) - FINAL
        // ==========================================
       // UPDATED SIGNATURE: Added 'negativePrompt' as the 2nd argument
        // ==========================================
				async function generateFreepik(prompt, negativePrompt, arValue) {
					const apiKey = document.getElementById('freepik-api-key')?.value.trim();
					if (!apiKey) throw new Error("Freepik API Key required.");
					const resolution = document.getElementById('freepik-resolution-select')?.value || '2k';
					
					// 1. Gather UI Parameters
					const modelId = document.getElementById('freepik-model-select')?.value || 'flux-pro-v1-1';
					const safety = parseInt(document.getElementById('freepik-safety-select')?.value) || 5;
					const upsampling = document.getElementById('freepik-upsampling')?.checked || false;
					const guidance = parseFloat(document.getElementById('freepik-guidance')?.value) || 1.0;
					const stylePreset = document.getElementById('freepik-style-select')?.value;

					const WORKER_URL = "https://freepik-proxy.nswlko.workers.dev"; 
					const BASE_URL = WORKER_URL.replace(/\/$/, "");

					// 2. Map Aspect Ratios
					let ratio = "social_story_9_16";
					const ar = String(arValue).toLowerCase();
					if (ar.includes("16:9")) ratio = "widescreen_16_9";
					else if (ar.includes("9:16")) ratio = "social_story_9_16"; 
					else if (ar.includes("1:1")) ratio = "square_1_1";
					else if (ar.includes("4:3")) ratio = "classic_4_3";
					else if (ar.includes("3:4")) ratio = "traditional_3_4";

					// 3. Construct Base Payload
					let payload = {
						prompt: prompt,
						safety_tolerance: safety,
						prompt_upsampling: upsampling,
						guidance_scale: guidance,
						seed: Math.floor(Math.random() * 1000000)
					};

					// 4. Model-Specific Setup
					let endpoint = "/v1/ai/text-to-image/flux-pro-v1-1"; 

					if (modelId === 'classic-fast') {
						endpoint = "/v1/ai/text-to-image"; 
						payload.image = { size: ratio };
						if (stylePreset) payload.styling = { style: stylePreset };
						if (negativePrompt) payload.negative_prompt = negativePrompt; 
					} 
					else if (modelId === 'flux-dev') {
						endpoint = "/v1/ai/text-to-image/flux-dev";
						payload.aspect_ratio = ratio;
						payload.output_format = "png";
						if (negativePrompt) payload.negative_prompt = negativePrompt;
					}
					else if (modelId === 'mystic') {
								endpoint = "/v1/ai/mystic";
								payload.aspect_ratio = ratio;
								payload.resolution = resolution; // Use the user-selected resolution
							}
					else {
						endpoint = "/v1/ai/text-to-image/flux-pro-v1-1";
						payload.aspect_ratio = ratio;
						payload.output_format = "png";
					}

					updateAppStatus('busy', `FREEPIK: REQUESTING ${modelId.toUpperCase()}...`);

					try {
						const postResponse = await fetch(BASE_URL + endpoint, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json', 'x-freepik-api-key': apiKey },
							body: JSON.stringify(payload)
						});

						if (!postResponse.ok) throw new Error(`API Error: ${await postResponse.text()}`);

						const postData = await postResponse.json();
						// Deep seek the data root
						let dataRoot = postData.data || postData;
						let item = Array.isArray(dataRoot) ? dataRoot[0] : dataRoot;

						// A. Handle Instant Results
						if (item.base64) return `data:image/jpeg;base64,${item.base64}`;
						
						// Fix for 'undefined' URL: check multiple possible keys
						const instantUrl = item.url || item.generated || (item.result?.generated?.[0]);
						if (instantUrl && typeof instantUrl === 'string') {
							updateAppStatus('busy', `FREEPIK: DOWNLOADING...`);
							const convertResp = await fetch(`${BASE_URL}/convert-image?url=${encodeURIComponent(instantUrl)}`);
							return await convertResp.text();
						}

						// B. Handle Task ID
						const taskId = item.task_id || dataRoot.task_id || (item.result?.task_id);
						if (!taskId) throw new Error("Could not find Image URL or Task ID in response.");

						// C. Polling Loop
						let attempts = 0;
						while (attempts < 60) {
							await new Promise(r => setTimeout(r, 2000));
							const getResponse = await fetch(`${BASE_URL}${endpoint}/${taskId}`, {
								method: 'GET',
								headers: { 'x-freepik-api-key': apiKey }
							});

							const statusData = await getResponse.json();
							const dataObj = statusData.data || statusData;

							if (dataObj.status === 'COMPLETED') {
								// Expanded URL check to prevent 'undefined'
								const finalUrl = dataObj.url || 
												 (dataObj.generated?.[0]) || 
												 (dataObj.result?.generated?.[0]);

								if (!finalUrl) throw new Error("Status COMPLETED but URL is missing.");

								const convertResp = await fetch(`${BASE_URL}/convert-image?url=${encodeURIComponent(finalUrl)}`);
								return await convertResp.text();
							}
							if (dataObj.status === 'FAILED') throw new Error("Generation Failed at Freepik");
							attempts++;
						}
						throw new Error("Polling Timeout");
					} catch (e) {
						console.error("Freepik Logic Error:", e);
						throw e;
					}
				}
				/* ==========================================================================
   STABLE HORDE COMPLETE INTEGRATION (Dynamic Models + Kudos + Realtime Log)
   ========================================================================== */

// 1. DYNAMIC MODEL FETCHER
async function updateHordeModels() {
    const select = document.getElementById('horde-model-select');
    if (!select) return;

    const originalVal = select.value;
    select.innerHTML = `<option>Refreshing Models...</option>`;

    try {
        const response = await fetch("https://stablehorde.net/api/v2/status/models?type=image");
        const data = await response.json();

        // Sort by Worker Count (High to Low)
        data.sort((a, b) => b.count - a.count);

        // Filter: Must have workers, limit to top 60
        const activeModels = data.filter(m => m.count > 0).slice(0, 60);

        select.innerHTML = ""; // Clear loading text

        if (activeModels.length === 0) {
            select.innerHTML = `<option value="AlbedoBase XL (SDXL)">AlbedoBase XL (Fallback)</option>`;
            return;
        }

        activeModels.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m.name;
            // Display: "Model Name (42 Workers)"
            opt.innerText = `${m.name} (${m.count} ⚡)`; 
            select.appendChild(opt);
        });

        // Restore selection if possible
        const saved = localStorage.getItem('promptBuilder_last_horde_model');
        if (saved && activeModels.find(m => m.name === saved)) {
            select.value = saved;
        } else if (originalVal && activeModels.find(m => m.name === originalVal)) {
            select.value = originalVal;
        }

        // Save on change
        select.onchange = () => localStorage.setItem('promptBuilder_last_horde_model', select.value);

    } catch (e) {
        console.error("Horde Fetch Error:", e);
        // Fallback if API fails
        select.innerHTML = `
            <option value="AlbedoBase XL (SDXL)">AlbedoBase XL (SDXL)</option>
            <option value="Juggernaut XL">Juggernaut XL</option>
            <option value="RealVisXL V4.0">RealVisXL V4.0</option>
        `;
    }
}

// 2. KUDOS CHECKER
async function checkHordeKudos() {
    const keyInput = document.getElementById('horde-api-key');
    const label = document.getElementById('horde-kudos-label');
    
    if (!keyInput || !label) return;
    
    const apiKey = keyInput.value.trim();
    if (!apiKey || apiKey === '0000000000') {
        label.innerText = "ANONYMOUS (Low Priority)";
        label.className = "text-[9px] text-gray-500 font-mono";
        return;
    }

    label.innerText = "Checking...";
    
    try {
        const res = await fetch("https://stablehorde.net/api/v2/find_user", {
            headers: { "apikey": apiKey }
        });
        
        if (!res.ok) throw new Error("Invalid Key");
        
        const data = await res.json();
        const kudos = Math.floor(data.kudos);
        
        label.innerText = `💎 KUDOS: ${kudos.toLocaleString()}`;
        label.className = "text-[9px] font-bold text-yellow-400 uppercase ml-auto";
    } catch (e) {
        label.innerText = "KEY ERROR";
        label.className = "text-[9px] font-bold text-red-400 uppercase ml-auto";
    }
}

// 3. MAIN GENERATOR FUNCTION (<1MP Enforced + Safe UI)
async function generateHorde(prompt, arValue) {
    const apiKey = document.getElementById('horde-api-key')?.value.trim() || '0000000000';
    const model = document.getElementById('horde-model-select')?.value || 'AlbedoBase XL (SDXL)';
    const steps = parseInt(document.getElementById('horde-steps')?.value) || 30;
    const cfg = parseFloat(document.getElementById('horde-cfg')?.value) || 7;
    
    // Robust Negative Prompt Fetching
    let neg = "";
    if (typeof getActiveNegativePrompt === 'function') {
        neg = getActiveNegativePrompt();
    } else {
        neg = document.getElementById('negative-prompt')?.value || "ugly, blurry, low quality";
    }

    // UI References (Safe Access)
    const logWindow = document.getElementById('horde-log-window');
    const logContent = document.getElementById('horde-log-content');
    const progressBar = document.getElementById('horde-progress-bar');
    const statusText = document.getElementById('horde-status-text');
    const percentText = document.getElementById('horde-percent');
    
    // Internal Helper: Update UI safely
    const updateLogUI = (msg, percent, status, color = 'text-green-400') => {
        if (logContent && msg) {
            const line = document.createElement('div');
            line.className = `${color} border-l-2 border-transparent hover:border-gray-500 pl-1`;
            line.innerText = `> ${msg}`;
            logContent.appendChild(line);
            logContent.scrollTop = logContent.scrollHeight;
        }
        if (progressBar && percent !== null) progressBar.style.width = `${percent}%`;
        if (statusText && status) statusText.innerText = status;
        if (percentText && percent !== null) percentText.innerText = `${Math.floor(percent)}%`;
    };

    // --- RESOLUTION MAPPING (STRICT < 1.05 MP) ---
    // Horde rejects images > 1MP for anonymous users or requires heavy kudos
    const safeMap = {
        "1:1":    { width: 1024, height: 1024 }, // 1.0 MP
        "16:9":   { width: 1344, height: 768 },  // 1.03 MP
        "3:2":    { width: 1216, height: 832 },  // 1.01 MP
        "4:3":    { width: 1152, height: 896 },  // 1.03 MP
        "5:4":    { width: 1120, height: 896 },  // 1.00 MP
        "21:9":   { width: 1536, height: 640 },  // 0.98 MP
        "9:16":   { width: 768, height: 1344 },  // 1.03 MP
        "2:3":    { width: 832, height: 1216 },  // 1.01 MP
        "3:4":    { width: 896, height: 1152 },  // 1.03 MP
        "4:5":    { width: 896, height: 1120 },  // 1.00 MP
        "1:2":    { width: 704, height: 1408 }   // 0.99 MP
    };

    let width = 1024, height = 1024; // Default
    // Intelligent Match
    for (const key in safeMap) {
        if (arValue && arValue.includes(key)) {
            width = safeMap[key].width;
            height = safeMap[key].height;
            break;
        }
    }

    // --- EXECUTION START ---
    if (logWindow) logWindow.classList.remove('hidden');
    if (logContent) logContent.innerHTML = ''; 
    
    updateLogUI(`Init: ${width}x${height} | Model: ${model.substring(0, 20)}...`, 5, "Connecting...", "text-gray-400");
    if(typeof updateAppStatus === 'function') updateAppStatus('busy', 'HORDE: INITIALIZING...'); 

    const payload = {
        prompt: `${prompt} ### ${neg}`,
        params: {
            sampler_name: "k_euler", toggles: [1, 4], cfg_scale: cfg,
            denoising_strength: 0.75, steps: steps, width: width, height: height,
            karras: true, hires_fix: false, clip_skip: 1, n: 1
        },
        nsfw: (typeof state !== 'undefined' && state.nsfw) ? true : false,
        censor_nsfw: (typeof state !== 'undefined' && state.nsfw) ? false : true,
        trusted_workers: false,
        models: [model], r2: true, shared: true
    };

    try {
        // 1. SUBMIT JOB
        const submitResp = await fetch("https://stablehorde.net/api/v2/generate/async", {
            method: "POST",
            headers: { 
                "apikey": apiKey, 
                "Client-Agent": "PromptBuilderMAX:v7.5:GenericUser", 
                "Content-Type": "application/json" 
            },
            body: JSON.stringify(payload)
        });

        const submitData = await submitResp.json();
        if (!submitResp.ok) throw new Error(submitData.message || "Horde connection refused.");
        
        const uuid = submitData.id;
        updateLogUI(`Job ID: ${uuid}`, 15, "Queued", "text-blue-300");

        let isDone = false;
        let finalUrl = null;
        let elapsed = 0;
        let timer = 0;
        
        // Timer display updater
        const timerInterval = setInterval(() => {
            timer++;
            const tElem = document.getElementById('horde-timer');
            if(tElem) tElem.innerText = `${Math.floor(timer/60)}:${(timer%60).toString().padStart(2,'0')}`;
        }, 1000);

        // 2. POLLING LOOP
        while (!isDone) {
            await new Promise(r => setTimeout(r, 2500)); // Poll every 2.5s
            elapsed += 2.5;
            
            const checkResp = await fetch(`https://stablehorde.net/api/v2/generate/check/${uuid}`);
            const checkData = await checkResp.json();
            
            if (checkData.done) {
                isDone = true;
                clearInterval(timerInterval);
                updateLogUI("Generation Complete!", 100, "Downloading Image...", "text-green-500 font-bold");
                
                // Get Final Image Location
                const statusResp = await fetch(`https://stablehorde.net/api/v2/generate/status/${uuid}`);
                const statusData = await statusResp.json();
                
                if (statusData.generations && statusData.generations.length > 0) {
                    finalUrl = statusData.generations[0].img;
                } else {
                    throw new Error("Worker reported success but sent no data.");
                }
            } else {
                // Calculation for Stats
                const qPos = checkData.queue_position || 0;
                const wait = checkData.wait_time || 0;
                const isProcessing = checkData.processing;
                const activeWorkers = checkData.kudos_info ? "? workers" : ""; // Sometimes available
                
                // Dynamic Badge
                if(typeof updateAppStatus === 'function') {
                    updateAppStatus('busy', `HORDE: #${qPos} | ${wait}s`);
                }

                if (isProcessing) {
                    updateLogUI(`Worker is processing your image...`, 90, "Processing...", "text-yellow-300 animate-pulse");
                } else {
                    // Update log periodically
                    if (elapsed % 5 === 0) {
                        updateLogUI(`Position: ${qPos} | Est. Wait: ${wait}s`, null, `Queued (#${qPos})`, "text-gray-500");
                    } else {
                        // Just update status text
                        updateLogUI(null, null, `Queued (#${qPos})`, "");
                    }
                    
                    // Fake progress bar logic for the "Waiting" phase (Max 80%)
                    let fakeProg = 15 + (elapsed * 1.5);
                    if (fakeProg > 85) fakeProg = 85;
                    updateLogUI(null, fakeProg, null, "");
                }
            }
        }

					// 3. FETCH & RETURN
					updateLogUI("Retrieving from R2 Storage...", 100, "Finalizing...", "text-blue-200");
					const imgResp = await fetch(finalUrl);
					const blob = await imgResp.blob();
					
					updateLogUI("Success.", 100, "Done", "text-white");
					
					// Graceful Close
					setTimeout(() => {
						if (logWindow) logWindow.classList.add('hidden');
						if (typeof updateAppStatus === 'function') updateAppStatus('ready', 'READY');
					}, 500);

					return blob;

				} catch (e) {
					// ERROR HANDLING
					console.error(e);
					updateLogUI(`FATAL: ${e.message}`, 0, "FAILED", "text-red-500 font-bold");
					
					if (progressBar) {
						progressBar.classList.remove('from-yellow-600', 'to-yellow-400');
						progressBar.classList.add('bg-red-600');
					}
					
					if(typeof updateAppStatus === 'function') updateAppStatus('error', 'HORDE ERROR');
					
					// Keep window open longer for reading error
					setTimeout(() => {
						if (logWindow) logWindow.classList.add('hidden');
					}, 6000);
					
					throw e;
					}
	}
				// ==========================================
				//  SHARED UPSCALE LOGIC (Preserves Features)
				// ==========================================
				async function performUpscale(base64Img, promptText) {
					const apiKey = document.getElementById('freepik-api-key')?.value.trim();
					if (!apiKey) { showToast("Freepik API Key Required", "error"); return; }

					const WORKER_URL = "https://freepik-proxy.nswlko.workers.dev";
					
					// 1. Status Update (Badge)
					updateAppStatus('busy', 'UPLOADING TO MAGNIFIC...');
					showToast("Upscaling Started...", "info");

					try {
						// 2. Prepare Payload (Fetching Latest DOM Values)
						const payload = {
							image: base64Img,
							scale_factor: "2x", 
							optimized_for: document.getElementById('upscale-opt')?.value || "films_n_photography", 
							creativity: parseInt(document.getElementById('upscale-creativity')?.value) || 0,
							hdr: parseInt(document.getElementById('upscale-hdr')?.value) || 0,
							resemblance: parseInt(document.getElementById('upscale-resemblance')?.value) || 10,
							fractality: parseInt(document.getElementById('upscale-fractality')?.value) || 0,
							engine: document.getElementById('upscale-engine')?.value || "automatic",
							prompt: promptText || "high quality, detailed" 
						};

						// 3. Start Task
						const postResp = await fetch(`${WORKER_URL}/upscale-image`, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json', 'x-freepik-api-key': apiKey },
							body: JSON.stringify(payload)
						});

						if (!postResp.ok) throw new Error(await postResp.text());
						const postData = await postResp.json();
						const taskId = postData.data?.task_id;
						if (!taskId) throw new Error("Upscale Task Failed (No ID)");

						// 4. Update Status Badge
						updateAppStatus('busy', 'MAGNIFIC: ENHANCING (30s)...');

						// 5. Poll Status
						let attempts = 0;
						while (attempts < 60) {
							await new Promise(r => setTimeout(r, 2000));
							const statusResp = await fetch(`${WORKER_URL}/v1/ai/image-upscaler/${taskId}`, {
									method: 'GET',
									headers: { 'x-freepik-api-key': apiKey }
							});
							const statusData = await statusResp.json();
							const dataObj = statusData.data || statusData;

							if (dataObj.status === 'COMPLETED') {
								const rawUrl = dataObj.generated?.[0];
								if (!rawUrl) throw new Error("Upscaled URL missing");

								updateAppStatus('busy', 'DOWNLOADING RESULT...');
								
								// 6. Download & Save
								const convertResp = await fetch(`${WORKER_URL}/convert-image?url=${encodeURIComponent(rawUrl)}`);
								const finalBase64 = await convertResp.text();

								// Save to Gallery with Comparison Link
								GalleryManager.saveImage(finalBase64, "Upscaled Image", "FRE-MAGNIFIC", base64Img);
								
								// Update Save Buttons to new image
								NavManager.bindLightboxButtons(finalBase64, promptText);

								// Show Comparison
								openComparison(base64Img, finalBase64);
								showToast("Upscale Complete!", "success");
								return;
							}
							if (dataObj.status === 'FAILED') throw new Error("Upscale Failed at Provider");
							attempts++;
						}
						throw new Error("Upscale Timeout");

					} catch (e) {
						console.error(e);
						showToast("Upscale Error: " + e.message, "error");
					} finally {
						updateAppStatus('idle'); // Reset Status Badge
					}
				}

//INIT-------------------------------------------------------------------------------------
		async function initSystem() {
            return new Promise(async (resolve) => {
                try { await GalleryManager.init(); } catch(e) { console.error("IDB Init Fail", e); }
                try {
                    const storedData = localStorage.getItem(DATA_KEY);
                    const storedFiles = JSON.parse(localStorage.getItem(FILE_KEY) || "[]");
                    updateFileListUI(storedFiles);
                    if(storedData && storedFiles.length > 0) {
                        try { 
							const masterData = JSON.parse(storedData); 
							applyDataToGlobals(masterData); 
							safeClass('setup-screen', 'remove', 'hidden'); 
							updateAppStatus('idle'); // <--- THIS WAS MISSING
						}
                        catch(e) { console.error("Data corrupt", e); safeClass('db-screen', 'remove', 'hidden'); updateAppStatus('idle'); }
                    } else { safeClass('db-screen', 'remove', 'hidden'); updateAppStatus('idle'); }
                    restoreModelCache();
					// ALWAYS LOAD PREFS
                    loadPrefs(); 
                } catch(e) { console.error("Init Error", e); }
                resolve();
            });
        }
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
		
		// ==========================================
            //  UI LOADING STATE HELPERS (Fixes Crash)
            // ==========================================
            function showLoadingState() {
                // Show Spinner
                safeClass('img-loading', 'remove', 'hidden');
                safeClass('generated-image', 'add', 'hidden');
                safeClass('visualizer-container', 'add', 'hidden');
                
                // Update Status Bar
                if (typeof updateAppStatus === 'function') {
                    updateAppStatus('busy', 'GENERATING...');
                }
                
                // Lock Main Button
                const genBtn = document.getElementById('generate-btn');
                if (genBtn) genBtn.disabled = true;
            }

            function hideLoadingState() {
                // Hide Spinner
                safeClass('img-loading', 'add', 'hidden');
                
                // Reset Status Bar
                if (typeof updateAppStatus === 'function') {
                    updateAppStatus('idle');
                }
                
                // Unlock Main Button
                const genBtn = document.getElementById('generate-btn');
                if (genBtn) genBtn.disabled = false;
            }
			
			


				


				
		
			// ==========================================
            //  TEMP IMAGE UPLOADER (Litterbox - The Reliable One)
            // ==========================================
            async function uploadToTempHost(base64Data) {
                // 0. Check Environment
                if (window.location.protocol === 'file:') {
                    console.warn("⚠️ WARNING: You are running index.html directly!");
                    showToast("Browser blocking upload? Use Localhost!", "info");
                }

                try {
                    console.log("📤 Preparing upload to Litterbox...");
                    
                    // 1. Base64 to Blob
                    const byteString = atob(base64Data.split(',')[1]);
                    const mime = base64Data.split(',')[0].split(':')[1].split(';')[0];
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
                    const blob = new Blob([ab], {type: mime});

                    // 2. Prepare Form (Standard Litterbox API)
                    const formData = new FormData();
                    formData.append('reqtype', 'fileupload');
                    formData.append('time', '1h'); // Expire in 1 hour
                    formData.append('fileToUpload', blob, 'image.jpg');

                    // 3. Upload (Cross-Origin Mode)
                    // We use the specific API endpoint that allows CORS
                    const response = await fetch('https://litterbox.catbox.moe/resources/internals/api.php', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) throw new Error("Litterbox Error: " + response.status);

                    const url = await response.text();
                    
                    if (url.startsWith('http')) {
                        console.log("✅ Upload Success:", url);
                        return url.trim();
                    } else {
                        throw new Error("Invalid response: " + url);
                    }

                } catch (e) {
                    console.error("❌ Upload Failed:", e);
                    
                    // CRITICAL ERROR HANDLING
                    if (e.message.includes('Failed to fetch') || e.message.includes('NetworkError')) {
                        alert("⚠️ BROWSER SECURITY BLOCK:\n\nModern browsers block files from uploading to the web when you open 'index.html' directly.\n\nFIX:\n1. Open VS Code\n2. Install 'Live Server' extension\n3. Right-click index.html -> 'Open with Live Server'");
                    }
                    return null;
                }
            }
			
				// ==========================================
				//  CONCISE SCANNER (Vision API) - FIXED
				// ==========================================
				async function generateVisionDescription(base64Data) {
					const apiKey = document.getElementById('api-key-input')?.value || ""; 
					const modelId = document.getElementById('scan-model-select')?.value || "gemini-1.5-flash";

					if (!apiKey) {
						showToast("Gemini API Key missing for auto-scan!", "error");
						return null;
					}

					updateAppStatus('busy', `ANALYZING (${modelId})...`);

					// System Prompt: Forces concise tags & Mandatory Negatives
						// System Prompt: Forces concise tags & Mandatory Negatives
						const sysPrompt = `
							Analyze the provided image and output a highly detailed Stable Diffusion prompt.

							Focus MAINLY on:
							**FULL BODY 4K FRONTAL PHOTO** composition.
							Main Subject and Image Setting, subject gender and body structure exactly as observed, hair style and placement, limb position and posture, clothing and attire, action or implied motion, lighting, camera angle and shot type, and overall art / photo style.

							The output must feel cinematic, premium, intentional, and richly descriptive — never generic. Target a length of approximately 300–400 words.

							────────────────────────────────
							CRITICAL INSTRUCTIONS (EXECUTE FULLY)
							────────────────────────────────

							1. PRIME DIRECTIVE: IDENTITY & PHENOTYPE DECOUPLING
							- You MUST separate cultural accessories from biological traits.
							- **CRITICAL:** If the subject wears cultural jewelry (e.g., Maang Tikka, Nath) but possesses a different phenotype (e.g., Pale skin, Red hair, Light eyes), you must explicitly describe the **Physical Features** FIRST and with higher descriptive weight.
							- Do NOT allow the jewelry to dictate the ethnicity. If the subject is a "Pale-skinned Redhead wearing Indian Jewelry," describe her exactly as that. Do not drift into "Indian Woman."
							- Describe body structure factually: include curves, muscle definition, and bust size exactly as visible without "modesty filtering."
							- **Facial Integrity:** Regenerate facial details while strictly retaining original facial features.

							2. SARTORIAL STRUCTURE (AVOID OVER-COVERING)
							- **MANDATORY: NO UNNECESSARY COVERAGE.** Do NOT try to over-cover the subject unnecessarily. Strictly adhere to the visible skin-to-fabric ratio. Do not add phantom layers, shawls, high necklines, or extra fabric to satisfy modesty bias. If the anatomy is visible in the source, it must be visible in the prompt.
							- **CRITICAL:** Do NOT use specific cultural clothing labels (like "Saree," "Kurta," "Lehenga") unless the garment is a 100% traditional match. These terms trigger "conservative/modest" biases in image models.
							- Instead, use **Structural Descriptions**:
							  USE: "Plunging draped bodice," "Wrapped crimson sash," "Open-neck fantasy tunic," "Deep-V heavy silk wrap."
							  AVOID: "Modest blouse," "Choli," "Traditional dress."
							- Describe the physics: "Gravity-weighted satin," "Tension in the fabric," "Gaping at the neckline," "Sheer texture."
							- Describe how clothing fits and interacts with the subject’s form as visibly observed.
							- Use high-fashion, policy-safe vocabulary only:
							  "Bespoke tailoring", "Anatomically defined silhouette",
							  "Precision-contoured garment", "Sculpted drape",
							  "Architectural fit".

							3. FABRIC PHYSICS (MATERIAL BEHAVIOR AS SEEN)
							- Describe fabric characteristics based on visible behavior in the image.
							- Use policy-safe textile terms: "Fine georgette," "Lightweight silk weave," "Fluid satin drape," "Delicate cotton voile."
							- Focus on how the fabric *fails* to cover: "Sliding off the shoulder," "Clinging to the midriff," "Parted at the center."
							- Avoid implying compression or artificial shaping.

							4. SKIN FIDELITY (EXTREME NATURAL REALISM & PHYSICS)
							- **MANDATORY:** Generate ultra-high fidelity human skin with physically accurate subsurface scattering.
							- **Micro-Details:** Include visible pores and follicle detail, micro-surface skin texture, fine vellus hair visible in rim light, and natural tonal unevenness.
							- **Lighting Interaction:** Describe natural oil sheen on high points (forehead, nose bridge, cheekbones), soft specular breakup, and faint capillary redness around nose and cheeks.
							- **Imperfections:** Faint scars, freckles, fine wrinkles, and expression lines must be described as incidental and organic.
							- **Prohibited:** No airbrushing, no smoothing, no plastic look. Skin must never look like a 3D render or doll.
							- **Tone Check:** Ensure the skin tone described matches the PIXELS (e.g., "Pale ivory," "Sun-kissed fair") and is not inferred from the clothing.

							5. HAIR COLOR & STYLING PRIORITY
							- **High Importance:** Hair color is a primary anchor for identity.
							- If the hair is Auburn/Red, use strong keywords: "Vibrant Auburn hair," "Deep Mahogany roots," "Fiery Red strands."
							- This helps fight the "Dark Hair" bias associated with the jewelry.

							6. CAMERA & OPTICAL LANGUAGE
							- **Framing:** STRICTLY Full Body 4K Frontal Photo.
							- Describe camera behavior cinematically: "85mm prime lens look," "shallow depth of field," "natural perspective compression."
							- For front-facing subjects: "symmetrical facial alignment," "straight-on camera orientation," "direct eye contact."
							- Maintain optical clarity: sharp subject focus, controlled background blur (Bokeh), no motion blur.

							7. LIGHTING (DRAMATIC & SEPARATING)
							- Describe the lighting's function: "Rim light separating hair from background," "Volumetric amber haze," "Atmospheric bounce."
							- **Chiaroscuro:** Use high-contrast lighting to define the jawline and cleavage, ensuring the figure doesn't look flat.
							- "Subsurface Scattering" is a required keyword for the lighting on the skin.

							8. SPECIAL STYLE REFERENCE: GROUNDED CINEMATIC REALISM (LIVE ACTION)
							- **Visual Goal:** 100% Photorealism with integrated VFX. Think "High-Budget Live Action Movie Frame," NOT "Game Art" or "Digital Painting."
							- **Texture:** The subject must look like a living, breathing human. The environment must look like a physical set or location.
							- **Integration:** Fantasy elements must appear as **Practical Effects** or **Photorealistic CGI** that exist in the real physical space (casting real light, creating real shadows).
							- **Strictly Prohibited:** "2.5D," "Concept Art," "Semi-realistic," "Painterly," "Illustration."

							9. POSE & WEIGHT DISTRIBUTION
							- **Target:** Full Body Frontal View.
							- Describe the subject’s stance: "Squared shoulders," "Confident frontal posture," "Torso squared to camera."
							- Note natural weight distribution and gravity.
							- **Anatomy Check:** Ensure the pose doesn't hide the body structure. "Open chest," "Visible waistline."

							10. EXPRESSION & MICRO-DETAIL
							- Describe facial expression as observed, including micro-expressions.
							- Note: "Relaxed jaw," "Piercing intensity," "Slightly parted lips," "Brow furrowed in concentration."
							- Expression must be "Emotionally grounded," not blank.

							11. COLOR SCIENCE & TONAL BALANCE
							- Describe color temperature: "Warm amber dominance," "Cool moonlight contrast."
							- **Skin Tone Consistency:** Explicitly enforce that skin tone must remain consistent with the *description* (e.g., Pale/Fair) and not drift due to the environment or clothing colors.
							- Avoid muddy shadows; request "Deep, rich blacks" and "Clean highlights."

							12. DEPTH & SPATIAL HIERARCHY
							- Describe the separation: "Foreground particles," "Sharp Subject," "Creamy blurred background."
							- Use "Atmospheric perspective" to push the burning city/background further away visually.

							13. MATERIAL & ACCESSORY LIGHT RESPONSE
							- Describe how non-skin materials interact with light.
							- **Metal:** "Specular highlights on gold," "Sharp reflections on jewelry."
							- **Fabric:** "Soft sheen on satin," "Matte absorption on cotton."
							- Material response should feel physically accurate (PBR texture quality).

							14. **MANDATORY VFX ADDITION (PHOTOREALISTIC INTEGRATION):**
							- Add fantasy elements, but describe them as **light-emitting physical phenomena** interacting with the scene (casting reflections on skin/metal):
							  softly glowing magical particles,
							  floating arcane dust motes,
							  shimmering ethereal mist,
							  luminous energy motes drifting in air,
							  faint magical aura surrounding the subject,
							  glowing runes suspended in space,
							  slow-moving enchanted fog layers,
							  subtle plasma filaments weaving through atmosphere,
							  bioluminescent pollen-like spores,
							  softly pulsing light orbs,
							  gentle mana wisps trailing motion,
							  translucent spectral light trails,
							  arcane glyph fragments dissolving into air,
							  controlled lightning veins embedded in clouds,
							  low-intensity magical sparks,
							  radiant aura bloom around highlights,
							  slow vortex of enchanted particles,
							  fantasy bokeh with colored light specks,
							  softly refracting magical haze,
							  ambient spell-infused atmosphere,
							  astral constellations faintly forming in the air,
							  prismatic mana shards slowly rotating,
							  ethereal sigils briefly igniting then fading,
							  rune-etched light ribbons circling the scene,
							  levitating crystalline fragments with inner glow,
							  arcane embers drifting upward against gravity,
							  spectral fireflies with soft bioluminescence,
							  time-distorted shimmer ripples in space,
							  illusionary light veils phasing in and out,
							  ancient spell circles etched in luminous air,
							  whispering soul-particles fading into mist,
							  celestial dust streaks with star-like glints,
							  dimensional light fractures along the background,
							  mana condensation forming glowing droplets,
							  arcane wind currents visible as light flow lines,
							  floating sigil dust tracing magical geometry,
							  astral smoke plumes infused with color,
							  enchanted stardust settling on surfaces,
							  harmonic energy waves gently warping light,
							  mythic glow halos layered subtly in depth.

							15. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE):**
							   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender, reduced anatomical presence, flattened silhouette, diminished structural volume."
							   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
							   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed, 2.5D, semi-realistic, CGI skin."
							   - **CAMERA ANGLE:** "Side profile, Looking away, Turned head, Three-quarter view, Asymmetric composition."
								- **LOGOS:** Logo, watermark, text-mark
							────────────────────────────────
							OUTPUT CONSTRAINTS
							────────────────────────────────
							- Maximum 400 words
							- Full sentences only
							- No filler or repetition
							- Output format STRICTLY as:

							[Positive Prompt Here]
							###NEGATIVE###
							[Mandatory Negative Prompt Here]
						`;

								
					try {
						const payload = {
							contents: [{
								parts: [
									{ text: sysPrompt },
									{ inline_data: { mime_type: "image/jpeg", data: base64Data.split(',')[1] } }
								]
							}]
						};

						const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify(payload)
						});

						const data = await response.json();
						
						if (!response.ok) throw new Error(data.error?.message || "API Error");
						
						// 2. SPLITTING LOGIC
						let rawText = data.candidates[0].content.parts[0].text.trim();
						let positivePrompt = rawText;
						
						if (rawText.includes('###NEGATIVE###')) {
							const parts = rawText.split('###NEGATIVE###');
							positivePrompt = parts[0].trim();
							const negativePrompt = parts[1].trim();

							// 3. POPULATE NEGATIVE FIELD DIRECTLY
							// Ensure 'negative-prompt' matches the ID of your negative textarea in HTML
							const negBox = document.getElementById('negative-prompt'); 
							if (negBox) {
								negBox.value = negativePrompt;
								// Trigger resize if you have auto-resize logic
								negBox.dispatchEvent(new Event('input', { bubbles: true }));
							}
						}
						
						// Return ONLY the positive part so the main box doesn't get polluted
						return positivePrompt;

					} catch (e) {
						console.error("Auto-Scan Error:", e);
						showToast("Auto-Scan Failed: " + e.message, "error");
						return null; 
					} finally {
						updateAppStatus('idle');
					}
				}
			
			// ==========================================
            //  DOM WAITER (Solves the "Null Element" Crash)
            // ==========================================
            function waitForDOM(elementId, timeout = 2000) {
                return new Promise((resolve, reject) => {
                    // 1. Check if already exists
                    if (document.getElementById(elementId)) {
                        return resolve(document.getElementById(elementId));
                    }

                    const interval = 100;
                    let elapsed = 0;

                    // 2. Poll every 100ms
                    const timer = setInterval(() => {
                        const el = document.getElementById(elementId);
                        if (el) {
                            clearInterval(timer);
                            resolve(el);
                        }
                        elapsed += interval;
                        if (elapsed >= timeout) {
                            clearInterval(timer);
                            reject(new Error(`UI Element #${elementId} failed to load.`));
                        }
                    }, interval);
                });
            }
			
        function updateFileListUI(files) {
            const fileListDisplay = document.getElementById('loaded-files-list'); const fileCountDisplay = document.getElementById('file-count');
            if(!fileListDisplay || !fileCountDisplay) return;
            let totalDbItems = 0;
            try { const rawData = localStorage.getItem(DATA_KEY); if(rawData) { const data = JSON.parse(rawData); Object.values(data).forEach(list => { if(Array.isArray(list)) totalDbItems += list.length; }); } } catch(e){}
            if (files.length === 0) { fileListDisplay.innerHTML = '<span class="text-gray-600 italic">No files loaded yet.</span>'; fileCountDisplay.innerText = "0 ITEMS IN DATABASE"; } 
            else { fileListDisplay.innerHTML = files.map(f => `<div class="flex items-center gap-2 text-theme-400 border-b border-gray-800 pb-1 mb-1 last:border-0"><svg class="w-4 h-4 flex-none opacity-70" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg><span class="truncate">${f}</span></div>`).join(''); fileCountDisplay.innerText = `${totalDbItems} TOTAL ITEMS IN DATABASE`; }
        }
		 
        function applyDataToGlobals(data) { for(const [key, items] of Object.entries(data)) { if(window[key] && Array.isArray(window[key])) { window[key] = items; } } }
        function readFile(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsText(file); }); }
        
        // --- HYBRID SWIPE MANAGER (Mobile + Desktop Fixed) ---
			// --- SWIPE MANAGER (Fixed) ---
	const SwipeManager = {
		xDown: null,
		yDown: null,

		init() {
			// 1. MOBILE (Touch)
			document.addEventListener('touchstart', (evt) => {
				this.xDown = evt.touches[0].clientX;
				this.yDown = evt.touches[0].clientY;
			}, { passive: false });

			document.addEventListener('touchend', (evt) => {
				if (!this.xDown || !this.yDown) return;
				const xUp = evt.changedTouches[0].clientX;
				const yUp = evt.changedTouches[0].clientY;
				this.processGesture(xUp, yUp, evt.target);
			});

			// 2. DESKTOP (Mouse)
			document.addEventListener('mousedown', (evt) => {
				// Ignore clicks on scrollbars or inputs
				if(evt.target.tagName === 'INPUT' || evt.target.tagName === 'TEXTAREA') return;
				this.xDown = evt.clientX;
				this.yDown = evt.clientY;
			});

			document.addEventListener('mouseup', (evt) => {
				if (!this.xDown || !this.yDown) return;
				const xUp = evt.clientX;
				const yUp = evt.clientY;
				this.processGesture(xUp, yUp, evt.target);
			});

			// Safety: Clear vars if mouse leaves window
			document.addEventListener('mouseleave', () => {
				this.xDown = null;
				this.yDown = null;
			});
		},

		processGesture(xUp, yUp, target) {
			const xDiff = this.xDown - xUp;
			const yDiff = this.yDown - yUp;

			// Reset immediately
			this.xDown = null;
			this.yDown = null;

			// 1. Ignore tiny jitters (Click protection)
			if (Math.abs(xDiff) < 10 && Math.abs(yDiff) < 10) return;

			// 2. Ignore if scrolling a list
			if (this.isScrolling(target, xDiff, yDiff)) return;

			// 3. Determine Direction
			if (Math.abs(xDiff) > Math.abs(yDiff)) {
				// Horizontal
				if (Math.abs(xDiff) > 50) {
					if (xDiff > 0) this.handleSwipe('left');
					else this.handleSwipe('right');
				}
			} else {
				// Vertical
				if (Math.abs(yDiff) > 60) {
					if (yDiff > 0) this.handleSwipe('up');   // Drag UP
					else this.handleSwipe('down');           // Drag DOWN
				}
			}
		},

		async handleSwipe(dir) {
			// A. SLIDESHOW
			if (this.isVisible('slideshow-screen')) {
				if (dir === 'left') nextSlide();
				if (dir === 'right') prevSlide();
				if (dir === 'down') stopSlideshow();
				return;
			}

			// B. LIGHTBOX
			if (this.isVisible('lightbox-overlay')) {
				const img = document.getElementById('lb-image');
				// Zoom Protection: Don't swipe if zoomed in (approx check)
				if (img && img.style.transform && img.style.transform.includes('scale(') && !img.style.transform.includes('scale(1)')) return;

				// ✅ FIX: Changed 'move' to 'navigate'
				if (dir === 'left') NavManager.navigate(1);   // Next Image
				if (dir === 'right') NavManager.navigate(-1); // Prev Image

				// DRAG DOWN = CLOSE
				if (dir === 'down') {
					if(typeof closeLightbox === 'function') closeLightbox();
					else safeClass('lightbox-overlay', 'add', 'hidden');
				}

				// DRAG UP = PLAY SLIDESHOW
				if (dir === 'up') {
					// ✅ FIX: Changed ID from 'lb-play-btn' to 'lb-play-slideshow'
					const playBtn = document.getElementById('lb-play-slideshow');
					if (playBtn) {
						playBtn.click();
					} else {
						// Fallback logic
						if(typeof closeLightbox === 'function') closeLightbox();
						else safeClass('lightbox-overlay', 'add', 'hidden');

						showToast("Starting Slideshow...", "success");

						if (NavManager.state.type === 'gallery' && NavManager.state.index !== -1) {
							startSlideshow(NavManager.state.index);
						} 
						else if (NavManager.state.type === 'catalogue' && NavManager.state.index !== -1) {
							if(GalleryManager.playCatalogueSlideshow) GalleryManager.playCatalogueSlideshow();
						} 
						else {
							if(GalleryManager.loadGallery) await GalleryManager.loadGallery();
							startSlideshow(0);
						}
					}
				}
				return;
			}

			// C. CATALOGUE
			if (this.isVisible('cat-overlay')) {
				// ✅ FIX: Changed 'move' to 'navigate'
				if (dir === 'left') NavManager.navigate(1);
				if (dir === 'right') NavManager.navigate(-1);
				if (dir === 'down') safeClass('cat-overlay', 'add', 'hidden');
				return;
			}

			// D. MAIN TABS
			if (!this.anyOverlayOpen()) {
				if (dir === 'left') this.switchMainTab(1);
				if (dir === 'right') this.switchMainTab(-1);
			}
		},

		isVisible(id) {
			const el = document.getElementById(id);
			return el && !el.classList.contains('hidden') && window.getComputedStyle(el).display !== 'none';
		},

		anyOverlayOpen() {
			return ['slideshow-screen', 'lightbox-overlay', 'cat-overlay'].some(id => this.isVisible(id));
		},

		switchMainTab(dir) {
			const tabs = ['home', 'setup'];
			const catBtn = document.getElementById('nav-catalogue');
			if (catBtn && !catBtn.classList.contains('hidden')) tabs.push('catalogue');
			tabs.push('history');

			let currIdx = 0;
			if (document.getElementById('nav-setup').classList.contains('opacity-100')) currIdx = 1;
			else if (catBtn && document.getElementById('nav-catalogue').classList.contains('opacity-100')) currIdx = tabs.indexOf('catalogue');
			else if (document.getElementById('nav-history').classList.contains('opacity-100')) currIdx = tabs.length - 1;

			const newIdx = currIdx + dir;
			if (newIdx >= 0 && newIdx < tabs.length) switchTab(tabs[newIdx]);
		},

		isScrolling(target, xDiff, yDiff) {
			let el = target;
			while(el && el !== document.body) {
				if (Math.abs(xDiff) > Math.abs(yDiff)) {
					if (el.classList.contains('overflow-x-auto') && el.scrollWidth > el.clientWidth) return true;
				} else {
					if ((el.classList.contains('overflow-y-auto') || el.id === 'main-scroll') && el.scrollHeight > el.clientHeight) {
						if (yDiff > 0 && el.scrollTop + el.clientHeight < el.scrollHeight) return true;
						if (yDiff < 0 && el.scrollTop > 0) return true;
					}
				}
				el = el.parentNode;
			}
			return false;
		}
	};

		// --- GLOBAL LIGHTBOX MANAGERS (Fixed Z-Index + Full Immersion) ---
		
		// ==========================================
				//  GRID GALLERY MANAGER (Complete)
				// ==========================================
				let gridViewPage = 0;
				const GRID_BATCH_SIZE = 20;
				let currentGridFilter = 'ALL'; // Restored Variable

				// 1. FILTER SWITCHER HELPER (Restored Function)
				window.setGridFilter = function(filter) {
					currentGridFilter = filter;
					// visual feedback is handled in renderFullGrid re-run
					renderFullGrid(true); 
				};

				// 2. MAIN RENDER FUNCTION
				function renderFullGrid(reset = false) {
					const grid = document.getElementById('full-gallery-grid');
					const loadBtn = document.getElementById('grid-load-more-btn');
					const countLabel = document.getElementById('grid-total-count');
					const filterBar = document.getElementById('grid-filter-bar');
					
					// Safety check: Ensure slideshowItems exists
					if (typeof slideshowItems === 'undefined') return;

					if (reset) {
						grid.innerHTML = '';
						gridViewPage = 0;
						
						// RE-GENERATE FILTER BUTTONS
						if (filterBar) {
							// Get unique providers dynamically from current items
							const providers = [...new Set(slideshowItems.map(item => item.provider || 'UNKNOWN'))].sort();
							// Ensure ALL is always first
							const allProviders = ['ALL', ...providers.filter(p => p !== 'ALL')];

							filterBar.innerHTML = allProviders.map(prov => {
								const isActive = (prov === currentGridFilter);
								// Highlight active button
								const activeClass = "bg-theme-600 text-white border-theme-400 shadow-lg shadow-theme-500/30 ring-1 ring-white/20";
								const inactiveClass = "bg-gray-800 text-gray-400 border-gray-700 hover:bg-gray-700 hover:text-gray-200";
								
								// Format label (Clean up technical names)
								let label = prov.replace('FRE-', '').replace('MAGNIFIC', 'UPSCALER').replace('POLLINATION', 'POLL'); 
								if (prov === 'ALL') label = 'ALL GENERATIONS';

								return `<button onclick="setGridFilter('${prov}')" class="flex-none px-3 py-1.5 rounded-lg text-[9px] font-bold border transition-all uppercase tracking-wider mb-1 ${isActive ? activeClass : inactiveClass}">
									${label}
								</button>`;
							}).join('');
						}
					}

					// APPLY FILTER LOGIC
					let filteredItems = slideshowItems;
					if (currentGridFilter !== 'ALL') {
						filteredItems = slideshowItems.filter(item => (item.provider || 'UNKNOWN') === currentGridFilter);
					}

					// UPDATE COUNTS
					if(countLabel) countLabel.innerText = `${filteredItems.length} ITEMS`;

					// HANDLE EMPTY STATE
					if (filteredItems.length === 0) {
						grid.innerHTML = `<div class="col-span-full flex flex-col items-center justify-center py-20 opacity-50">
							<svg class="w-12 h-12 mb-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path></svg>
							<span class="text-xs font-bold text-gray-500">NO ${currentGridFilter === 'ALL' ? '' : currentGridFilter} IMAGES FOUND</span>
						</div>`;
						if(loadBtn) loadBtn.classList.add('hidden');
						return;
					}

					// PAGINATION SLICE
					const start = gridViewPage * GRID_BATCH_SIZE;
					const end = start + GRID_BATCH_SIZE;
					const batch = filteredItems.slice(start, end);

					// GENERATE ITEMS WITH ANIMATION
					const html = batch.map((item, index) => {
						// Important: Find original index to ensure Lightbox opens correct image
						const globalIndex = slideshowItems.indexOf(item); 
						
						const url = URL.createObjectURL(item.blob);
						const provider = (item.provider || 'UNK').substring(0,3).toUpperCase();
						
						// Staggered Animation Delay (max 800ms)
						const delay = Math.min(index * 60, 1200); 

						return `<div class="grid-item-animate relative aspect-square group cursor-pointer overflow-hidden rounded-xl bg-gray-800 border border-white/5 hover:border-theme-500 transition-all shadow-lg" 
									style="animation-delay: ${delay}ms"
									onclick="NavManager.openGallery(${globalIndex})">
							<img src="${url}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110 opacity-90 group-hover:opacity-100">
							<div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
								<span class="absolute bottom-1 left-1.5 text-[8px] font-bold text-white bg-black/50 px-1.5 py-0.5 rounded backdrop-blur-md">${provider}</span>
							</div>
						</div>`;
					}).join('');

					grid.insertAdjacentHTML('beforeend', html);

					// LOAD MORE BUTTON VISIBILITY
					if (end < filteredItems.length) {
						loadBtn.classList.remove('hidden');
						// Update click handler to load next page without resetting
						loadBtn.onclick = () => {
							gridViewPage++;
							renderFullGrid(false); 
						};
					} else {
						loadBtn.classList.add('hidden');
					}
				}
        let lbControlsTimer = null; 

		// ==========================================
		//  3. CONTROL FADER (Handles Opacity)
		// ==========================================
		function toggleLightboxControls(show) {
			const overlay = document.getElementById('lightbox-overlay');
			if (!overlay) return;
			
			// 1. Select Lightbox Internal Controls
			// Exclude 'lb-image' (the content), 'compare-container' (separate mode), and 'lb-prompt-overlay' (reading mode)
			const internalControls = Array.from(overlay.children).filter(el => 
				el.id !== 'lb-image' && 
				el.id !== 'compare-container' &&
				el.id !== 'lb-prompt-overlay'
			);
			
			// 2. Select Main App UI Elements
			const appControls = [
				document.getElementById('app-header'),
				document.getElementById('nav-dock'),
				document.getElementById('action-bar')
			];

			const allControls = [...internalControls, ...appControls];

			allControls.forEach(el => {
				if(el) {
					// Ensure transition exists
					if(!el.classList.contains('transition-opacity')) el.classList.add('transition-opacity', 'duration-500');
					
					if (show) {
						el.classList.remove('opacity-0', 'pointer-events-none');
						
						// Special Animation: Slide Action Bar UP
						if(el.id === 'lb-actions-bar') el.style.transform = 'translateY(0)';
					} else {
						el.classList.add('opacity-0', 'pointer-events-none');
						
						// Special Animation: Slide Action Bar DOWN
						if(el.id === 'lb-actions-bar') el.style.transform = 'translateY(20px)';
					}
				}
			});

			// 3. Handle Slider UI separately (Comparison Mode)
			const compUI = [
				document.getElementById('close-comp-btn'),
				document.getElementById('comp-slider')
			];
			compUI.forEach(el => {
				if(el) {
					el.style.opacity = show ? "1" : "0";
					// Disable pointer events on buttons when hidden
					if (el.tagName === 'BUTTON') el.style.pointerEvents = show ? "auto" : "none";
				}
			});

			// 4. IMMERSIVE MODE LOGIC (The Fix)
			const img = document.getElementById('lb-image');
			const isComparing = !document.getElementById('compare-container').classList.contains('hidden');
			
			if (img && !isComparing) {
				if (!show) {
					// === ENTER FULL SCREEN (Immersive) ===
					// Remove the "card" styling that restricts size
					img.classList.remove('max-h-[80vh]', 'rounded-lg', 'shadow-2xl');
					// Add full screen styling
					img.classList.add('max-h-[100vh]', 'w-full', 'h-full', 'object-contain', 'scale-100');
				} else {
					// === EXIT FULL SCREEN (Standard) ===
					// Restore "card" styling
					img.classList.add('max-h-[80vh]', 'rounded-lg', 'shadow-2xl');
					// Remove full screen styling
					img.classList.remove('max-h-[100vh]', 'w-full', 'h-full', 'object-contain', 'scale-100');
				}
			}
		}
		
			// ==========================================
			//  1. OPEN LIGHTBOX (Stores Prompt Data)
			// ==========================================
		function openLightbox(url, prompt, provider, originalUrl = null, negativePrompt = "", fullData = null) {
			HistoryManager.pushModal('lightbox');
			const lb = document.getElementById('lightbox-overlay');
			const lbImg = document.getElementById('lb-image');
			const lbBadge = document.getElementById('lb-provider-badge');
			const compareBtn = document.getElementById('lb-compare-btn');
			const actionsBar = document.getElementById('lb-actions-bar');
			const detailsDiv = document.getElementById('lb-details'); // Get the new container

			if(lb && lbImg) {
				lbImg.src = url;
				lbImg.classList.remove('hidden');
				document.getElementById('compare-container').classList.add('hidden');
				if(actionsBar) actionsBar.classList.remove('hidden');
				
				safeClass(lb, 'remove', 'hidden');
				lb.style.zIndex = "200";

				// 1. Badge Logic
				const cleanProvider = (provider || 'UNKNOWN').toUpperCase();
				if (lbBadge) {
					lbBadge.innerText = cleanProvider;
					lbBadge.style.opacity = "1";
					lbBadge.dataset.fullPrompt = prompt || "";
					lbBadge.dataset.fullNegative = negativePrompt || "";
				}

				// 2. Comparison Logic (AUTHORITATIVE & MERGE-SAFE)
					if (compareBtn) {
						const newBtn = compareBtn.cloneNode(true);
						compareBtn.parentNode.replaceChild(newBtn, compareBtn);

						const canCompare =
							fullData &&
							fullData.compareEnabled === true &&
							!!fullData.originalImageUrl;

						if (canCompare) {
							newBtn.classList.remove('hidden');
							newBtn.onclick = (e) => {
								e.stopPropagation();
								if (typeof openComparison === 'function') {
									openComparison(
										fullData.originalImageUrl,
										url,
										"ORIGINAL",
										cleanProvider
									);
								}
							};
						} else {
							newBtn.classList.add('hidden');
						}
					}



				// 3. NEW: Metadata Rendering
				if (detailsDiv) {
					if (fullData && fullData.metadata) {
						const m = fullData.metadata;
						// Format the model name nicely
						let niceModel = (m.model || "Unknown").split('/').pop().replace(/[-_]/g, ' ');
						
						detailsDiv.innerHTML = `
							<div class="bg-black/60 backdrop-blur-md border border-white/10 rounded-xl p-3 text-[10px] font-mono text-gray-300 shadow-2xl max-w-[200px]">
								<div class="grid grid-cols-2 gap-x-3 gap-y-1">
									<div class="col-span-2 border-b border-white/10 pb-1 mb-1 font-bold text-theme-400 uppercase truncate" title="${m.model}">${niceModel}</div>
									
									<span class="text-gray-500">STYLE</span>
									<span class="text-white text-right truncate">${m.style || "Std"}</span>
									
									<span class="text-gray-500">DIMS</span>
									<span class="text-white text-right">${m.width || "?"}x${m.height || "?"}</span>
									
									<span class="text-gray-500">STEPS</span>
									<span class="text-white text-right">${m.steps || "-"}</span>
									
									<span class="text-gray-500">CFG</span>
									<span class="text-white text-right">${m.guidance || "-"}</span>
									
									<div class="col-span-2 pt-1 mt-1 border-t border-white/10 text-[9px] text-gray-500 flex justify-between">
										<span>SEED:</span>
										<span class="text-blue-300 select-all cursor-copy" onclick="navigator.clipboard.writeText('${m.seed}')">${m.seed || "?"}</span>
									</div>
								</div>
							</div>
						`;
						detailsDiv.classList.remove('hidden');
					} else {
						detailsDiv.innerHTML = ""; // Clear if no data
						detailsDiv.classList.add('hidden');
					}
				}

				// 4. Animation & Controls
				lbImg.style.transform = "scale(1) translate(0,0)";
				toggleLightboxControls(true);
				if(lbControlsTimer) clearTimeout(lbControlsTimer);
				lbControlsTimer = setTimeout(() => {
					toggleLightboxControls(false);
				}, 3000);
			}
		}

        // 2. CLOSE LIGHTBOX UI (Visual Only - Called by System)
        function closeLightboxUI() {
            if(typeof lbControlsTimer !== 'undefined' && lbControlsTimer) {
                clearTimeout(lbControlsTimer);
                lbControlsTimer = null;
            }
            toggleLightboxControls(true); // Ensure controls are visible for next time
            
            const lbImg = document.getElementById('lb-image');
            if(lbImg) lbImg.style.transform = "scale(1) translate(0,0)";
            
            safeClass('lightbox-overlay', 'add', 'hidden');
        }

        // 3. CLOSE LIGHTBOX ACTION (User Clicked Button - Triggers History Back)
        function closeLightbox() {
            HistoryManager.closeModal();
        }
		// --- MANUAL PUTER FIX ---
        window.savePuterToken = function() {
            const input = document.getElementById('puter-token-input');
            const token = input.value.trim();
            if (!token) return showToast("Paste a token first!", "error");
            
            // Manually inject the token where Puter.js looks for it
            localStorage.setItem('puter.auth.token', token);
            
            showToast("Session Repaired! Reloading...", "success");
            setTimeout(() => window.location.reload(), 1000);
        };

        function togglePuterRepair(provider) {
            const box = document.getElementById('puter-repair-box');
            if (box) {
                if (provider === 'puter') box.classList.remove('hidden');
                else box.classList.add('hidden');
            }
      }
		
				// ==========================================
				//  2. COMPARISON LOGIC (Updated for Dynamic Labels)
				// ==========================================
				let isCompDragging = false;

				// NEW SIGNATURE: Accepts label text arguments
				function openComparison(originalBase64, upscaledBase64, leftText = "ORIGINAL", rightText = "MAGNIFIC 4X") {
					const els = {
						container: document.getElementById('compare-container'),
						imgBefore: document.getElementById('comp-before'), 
						imgAfter: document.getElementById('comp-after'),   
						slider: document.getElementById('comp-slider'),
						wrapper: document.getElementById('compare-wrapper'),
						closeBtn: document.getElementById('close-comp-btn'),
						lbImage: document.getElementById('lb-image'),
						lbOverlay: document.getElementById('lightbox-overlay'),
						actionsBar: document.getElementById('lb-actions-bar'),
						// Label Elements
						lblLeft: document.getElementById('comp-label-left'),
						lblRight: document.getElementById('comp-label-right')
					};

					if (!els.container || !els.imgBefore) return;

					// 1. Setup Sources & Labels
					els.imgBefore.src = originalBase64;
					els.imgAfter.src = upscaledBase64;
					
					// Update Labels Dynamically
					if(els.lblLeft) els.lblLeft.innerText = leftText;
					if(els.lblRight) els.lblRight.innerText = rightText;

					// 2. Show UI & Hide Standard Actions
					els.lbOverlay.classList.remove('hidden');
					els.container.classList.remove('hidden');
					els.lbImage.classList.add('hidden'); 
					
					if(els.actionsBar) els.actionsBar.classList.add('hidden');

					toggleLightboxControls(true);

					const updateSlider = (percent) => {
						els.imgBefore.style.clipPath = `inset(0 ${100 - percent}% 0 0)`;
						els.slider.style.left = `${percent}%`;
					};

					const refreshUI = () => {
						toggleLightboxControls(true);
						if(lbControlsTimer) clearTimeout(lbControlsTimer);
						lbControlsTimer = setTimeout(() => toggleLightboxControls(false), 3000);
					};

					const moveHandler = (e) => {
						if (!isCompDragging) return;
						refreshUI(); 
						requestAnimationFrame(() => {
							const rect = els.wrapper.getBoundingClientRect();
							let clientX = e.touches ? e.touches[0].clientX : e.clientX;
							let percent = ((clientX - rect.left) / rect.width) * 100;
							updateSlider(Math.max(0, Math.min(100, percent)));
						});
					};

					const start = (e) => { isCompDragging = true; refreshUI(); };
					const stop = () => { isCompDragging = false; };

					els.wrapper.onmousedown = start;
					els.wrapper.ontouchstart = start;
					window.addEventListener('mousemove', moveHandler);
					window.addEventListener('touchmove', moveHandler, { passive: false });
					window.addEventListener('mouseup', stop);
					window.addEventListener('touchend', stop);

					updateSlider(50);

					els.closeBtn.onclick = () => {
						els.container.classList.add('hidden');
						els.lbImage.classList.remove('hidden');
						els.lbImage.src = upscaledBase64; // Show the Result when closing comparison
						
						if(els.actionsBar) els.actionsBar.classList.remove('hidden');
						
						window.removeEventListener('mousemove', moveHandler);
						window.removeEventListener('touchmove', moveHandler);
						window.removeEventListener('mouseup', stop);
						window.removeEventListener('touchend', stop);
						toggleLightboxControls(true);
					};
				}
				
        // --- MASTER LISTENER INITIALIZATION (COMPLETE & FIXED) ---
		
		// Lightbox Provider Badge -> Show Prompt
			// UPDATED: Lightbox Provider Badge -> Show Overlay AND Copy to Inputs
				safeListen('lb-provider-badge', 'click', (e) => {
					e.stopPropagation();
					const badge = document.getElementById('lb-provider-badge');
					const overlay = document.getElementById('lb-prompt-overlay');
					const txt = document.getElementById('lb-prompt-text');
					
					// Inputs
					const outBox = document.getElementById('output-text');
					const negBox = document.getElementById('negative-prompt');

					if (badge) {
						const prompt = badge.dataset.fullPrompt || "";
						const negative = badge.dataset.fullNegative || "";

						// 1. Show Overlay (Existing Behavior)
						if (overlay && txt) {
							txt.innerText = prompt;
							overlay.classList.remove('hidden');
						}

						// 2. Copy to Main Generator Inputs (New Behavior)
						if (outBox) {
							outBox.value = prompt;
							autoResize(outBox);
						}

						if (negBox) {
							negBox.value = negative;
							// If there is a negative prompt, ensure the details tab is open so user sees it
							if (negative) {
								const details = negBox.closest('details');
								if (details) details.open = true;
							}
						}

						// 3. Feedback
						showToast("Prompts Loaded to Editor!", "success");
					}
				});

			// Close Prompt Overlay
			safeListen('close-lb-prompt', 'click', (e) => {
				e.stopPropagation(); // Prevent closing the lightbox behind it
				safeClass('lb-prompt-overlay', 'add', 'hidden');
			});
        document.addEventListener('DOMContentLoaded', () => {
		
				if(typeof SwipeManager !== 'undefined') SwipeManager.init();
            // 1. Z-Index & Position Fix for Mobile Action Bar
            const actionBar = document.getElementById('action-bar');
            if(actionBar) {
                actionBar.style.bottom = "calc(5.5rem + env(safe-area-inset-bottom))"; 
                actionBar.style.zIndex = "100"; 
            }
			const freepikInputs = [
						'freepik-api-key', 'freepik-guidance', 'upscale-creativity', 
						'upscale-resemblance', 'upscale-hdr', 'upscale-fractality'
					];
					const freepikSelects = [
							'freepik-model-select', 
							'freepik-safety-select', 
							'freepik-resolution-select', // Add this line
							'freepik-style-select', 
							'upscale-opt', 
							'upscale-engine', 
							'freepik-upsampling'
						];

					freepikInputs.forEach(id => safeListen(id, 'input', savePrefs));
					freepikSelects.forEach(id => safeListen(id, 'change', savePrefs));
            // 2. VISIBILITY MANAGER (Fixed)
            // 2. VISIBILITY MANAGER (Fixed to Always Show UI)
            function checkVizVisibility() {
                const outBox = document.getElementById('output-text');
                const vizBtn = document.getElementById('visualize-btn');
                const genBtn = document.getElementById('generate-btn');
                const bar = document.getElementById('action-bar');
                const appScreen = document.getElementById('app-screen');
                
                if (!outBox || !vizBtn || !genBtn || !bar) return;

                const isGeminiNSFW = (state.nsfw && state.generator === 'gemini');

                // FIX: Always show Visualize button (unless blocked by NSFW settings)
                // We removed the "hasText" check here.
                if (!isGeminiNSFW) {
                    vizBtn.classList.remove('hidden');
                    vizBtn.style.display = 'flex'; 
                    genBtn.classList.replace('w-full', 'w-auto');
                    vizBtn.classList.replace('w-full', 'w-auto');
                } else {
                    // Only hide if specifically blocked by Gemini NSFW rules
                    vizBtn.classList.add('hidden');
                    vizBtn.style.display = 'none';
                    genBtn.classList.replace('w-auto', 'w-full'); 
                }

                // 2. Manage Action Bar Visibility
                if (appScreen && !appScreen.classList.contains('hidden')) {
                    bar.classList.remove('hidden');
                    // Force display flex to ensure it appears immediately
                    bar.style.display = 'flex'; 
                }
            }

            // 3. ATTACH INPUT LISTENERS (Auto-Resize & Visibility)
					const outBox = document.getElementById('output-text');
					if (outBox) {
						const handleInput = () => {
							// USE THE GLOBAL FUNCTION (Unifies logic)
							autoResize(outBox);
							
							// 2. Visibility Logic
							checkVizVisibility();
						};

						outBox.addEventListener('input', handleInput);
						outBox.addEventListener('change', handleInput);
						outBox.addEventListener('paste', () => setTimeout(handleInput, 50));
						
						// Initial check to set correct size on load
						// Wrap in timeout to ensure CSS is fully applied before measuring
						setTimeout(handleInput, 100);
					}

            // 4. Live Effect Instant Snap
            const effectSel = document.getElementById('slide-effect');
            if (effectSel) {
                effectSel.addEventListener('change', (e) => {
                    const container = document.getElementById('slide-container');
                    const item = slideshowItems[slideIndex]; 
                    if (container && item) {
                        container.className = `w-full h-full flex items-center justify-center relative ${e.target.value}`;
                        container.innerHTML = '';
                        const img = document.createElement('img'); img.src = URL.createObjectURL(item.blob);
                        img.className = 'slide-img active';
                        img.style.cssText = 'opacity: 1 !important; transform: none !important; transition: none !important;';
                        img.ondblclick = () => stopSlideshow(true);
                        container.appendChild(img);
                    }
                });
            }

            SwipeManager.init();
            history.replaceState({ view: 'home' }, 'Home', '');

            const slideScreen = document.getElementById('slideshow-screen');
			if(slideScreen) { 
				slideScreen.addEventListener('mousemove', showControls); 
				slideScreen.addEventListener('touchstart', showControls); 
				slideScreen.addEventListener('click', showControls); 
			}

            // 6. Standard Listeners
            safeListen('fetch-models-btn', 'click', () => { dismissKeyboard(); fetchModels(); });
            safeListen('backup-db-btn', 'click', () => GalleryManager.exportZip());
            safeListen('clear-gallery-btn', 'click', () => GalleryManager.clearAll());
            safeListen('view-gallery-btn', 'click', async () => { await GalleryManager.loadGallery(); startSlideshow(0); });
            safeListen('launch-gallery-btn', 'click', async () => { await GalleryManager.loadGallery(); startSlideshow(0); });
            safeListen('close-slideshow-btn', 'click', () => stopSlideshow(true));
            safeListen('play-pause-btn', 'click', togglePlay);
            safeListen('next-slide-btn', 'click', nextSlide);
            safeListen('prev-slide-btn', 'click', prevSlide);
            
            safeListen('nav-slideshow', 'click', async () => { await GalleryManager.loadGallery(); startSlideshow(0); });
            safeListen('cat-slideshow-btn', 'click', () => GalleryManager.playCatalogueSlideshow());
            safeListen('merge-input', 'change', (e) => { if(e.target.files.length > 0) { GalleryManager.mergeBackup(e.target.files[0]); } e.target.value = ''; });
            safeListen('zip-cat-input', 'change', (e) => { if(e.target.files.length > 0) GalleryManager.openCatalogue(e.target.files[0]); e.target.value = ''; });
            safeListen('reopen-cat-btn', 'click', () => GalleryManager.reopenLastCatalogue());
            safeListen('close-cat-btn', 'click', () => { safeClass('catalogue-screen', 'add', 'hidden'); safeClass('db-screen', 'remove', 'hidden'); });
            
            safeListen('slide-provider-badge', 'click', (e) => { e.stopPropagation(); const item = slideshowItems[slideIndex]; if(item) { const overlay = document.getElementById('slide-prompt-overlay'); const txt = document.getElementById('slide-prompt-text'); if(overlay && txt) { txt.innerText = item.prompt || "No prompt data."; overlay.classList.remove('hidden'); } } });
            safeListen('slide-copy-btn', 'click', () => { const item = slideshowItems[slideIndex]; if(item && item.prompt) { navigator.clipboard.writeText(item.prompt).then(() => { showToast("PROMPT COPIED"); }); } });
            safeListen('share-btn', 'click', async () => { const img = document.getElementById('generated-image'); const btn = document.getElementById('share-btn'); if(!img || !img.src) return; nativeShare(img.src, btn, document.getElementById('output-text').value); });
            safeListen('lb-share-btn', 'click', () => { const img = document.getElementById('lb-image'); const btn = document.getElementById('lb-share-btn'); if(img) nativeShare(img.src, btn, "Shared Image"); });
            safeListen('slide-share-btn', 'click', () => { const item = slideshowItems[slideIndex]; if (item) { const url = URL.createObjectURL(item.blob); const btn = document.getElementById('slide-share-btn'); nativeShare(url, btn, item.prompt); } });
            safeListen('slide-save-btn', 'click', () => { const item = slideshowItems[slideIndex]; if(item) { const url = URL.createObjectURL(item.blob); downloadImage(url, 'jpg', item.prompt); } });

            safeListen('scan-btn', 'click', () => { dismissKeyboard(); document.getElementById('img-scan-input').click(); });
            
            // 7. Mobile Paste to Scan
            safeListen('paste-btn', 'click', async () => {
                dismissKeyboard();
                if (!navigator.clipboard || !navigator.clipboard.read) { showToast("Clipboard API not supported.", "error"); return; }
                try {
                    const items = await navigator.clipboard.read();
                    let blob = null;
                    for (const item of items) {
                        const type = item.types.find(t => t.startsWith('image/'));
                        if (type) { blob = await item.getType(type); break; }
                    }
                    if (blob) {
                        const file = new File([blob], "pasted_image.png", { type: blob.type });
                        const fileInput = document.getElementById('img-scan-input');
                        if (fileInput) {
                            const dataTransfer = new DataTransfer(); dataTransfer.items.add(file); fileInput.files = dataTransfer.files;
                            showToast("Image Found! Scanning...", "success");
                            fileInput.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    } else { showToast("No image in clipboard.", "warning"); }
                } catch (e) { showToast("Clipboard Access Denied", "error"); }
            });

            // 8. Helper Functions
            async function imageToLlavaArray(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const scale = Math.min(336 / img.width, 336 / img.height);
                            const width = Math.floor(img.width * scale); const height = Math.floor(img.height * scale);
                            canvas.width = width; canvas.height = height;
                            const ctx = canvas.getContext('2d'); ctx.fillStyle = "#FFFFFF"; ctx.fillRect(0, 0, width, height); ctx.drawImage(img, 0, 0, width, height);
                            const data = ctx.getImageData(0, 0, width, height).data;
                            const rgb = []; for (let i = 0; i < data.length; i += 4) { rgb.push(data[i]); rgb.push(data[i+1]); rgb.push(data[i+2]); }
                            resolve(rgb); 
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }

            function resizeImageToBase64(file, maxSize = 512) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let width = img.width; let height = img.height;
                            if (width > height) { if (width > maxSize) { height *= maxSize / width; width = maxSize; } } 
                            else { if (height > maxSize) { width *= maxSize / height; height = maxSize; } }
                            canvas.width = width; canvas.height = height;
                            const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', 0.8)); 
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }

          // 9. SCANNER LOGIC (ALL STYLES = MASSIVE DETAILED RULES)
            safeListen('img-scan-input', 'change', async (e) => {
                const file = e.target.files[0]; if (!file) return;
                
                // --- SHOW THUMBNAIL PREVIEW (WITH STYLE TRACKING) ---
                const prevContainer = document.getElementById('paste-preview-area');
                const prevImg = document.getElementById('paste-preview-img');
                // FIX: Corrected ID from 'img-scan-style' to 'scan-style-final'
                const styleSelect = document.getElementById('scan-style-final'); 
                
                if(prevContainer && prevImg) {
                    const objectUrl = URL.createObjectURL(file);
                    prevImg.src = objectUrl;
                    
                    // 1. CAPTURE THE STYLE NAME (e.g., "LEXICA")
                    let currentStyleText = "RAW";
                    if (styleSelect && styleSelect.options[styleSelect.selectedIndex]) {
                        currentStyleText = styleSelect.options[styleSelect.selectedIndex].text.replace(/\s*\(.*?\)\s*/g, '').trim().toUpperCase();
                    }
                    prevImg.dataset.styleName = currentStyleText; // Store it for later

                    prevContainer.classList.remove('hidden');
                    
                    // ON CLICK: Check if we have a result to compare against
                    prevImg.onclick = function() {
                        const genImg = document.getElementById('generated-image');
                        // FIX: Reduced check length to 10 for Blob URLs
                        const hasGen = genImg && !genImg.classList.contains('hidden') && genImg.src && genImg.src.length > 10;
                        
                        if (hasGen) {
                            // MODE A: COMPARE (Input vs Result)
                            const lb = document.getElementById('lightbox-overlay');
                            if(lb) lb.style.zIndex = "200"; 
                            
                            // USE THE CAPTURED STYLE IN THE LABEL
                            const styleLabel = this.dataset.styleName ? `GENERATED [${this.dataset.styleName}]` : "GENERATED RESULT";
                            openComparison(objectUrl, genImg.src, "INPUT SOURCE", styleLabel);
                        } else {
                            // MODE B: VIEW INPUT ONLY
                            openLightbox(objectUrl, "Input Source Image", "USER UPLOAD");
                            if (typeof NavManager !== 'undefined') {
                                NavManager.bindLightboxButtons(objectUrl, "Input Source Image");
                            }
                        }
                    };

                    safeClass('result-area', 'remove', 'hidden'); 
                }
                
                // --- AUTH & PROVIDER SETUP ---
                const cfAccount = document.getElementById('cf-account-id')?.value.trim();
                const cfToken = document.getElementById('cf-api-token')?.value.trim();
                const geminiKey = document.getElementById('api-key-input')?.value.trim();
                
                let provider = 'GEMINI'; 
                let scanModel = "gemini-1.5-flash"; 

                const pref = state.helper || 'auto';
                if (pref === 'auto') {
                    if (geminiKey) provider = 'GEMINI';
                    else if (cfAccount && cfToken) provider = 'CLOUDFLARE';
                } else { provider = pref.toUpperCase(); }

                if (provider === 'GEMINI') {
                    scanModel = document.getElementById('scan-model-select')?.value || "gemini-1.5-flash";
                    if (!geminiKey) { showToast("Gemini Key Required", "error"); return; }
                } else if (provider === 'CLOUDFLARE') {
                    scanModel = document.getElementById('cf-vision-model')?.value || "@cf/meta/llama-3.2-11b-vision-instruct";
                    if (!cfAccount || !cfToken) { showToast("Cloudflare Creds Required", "error"); return; }
                }

                // --- UI FEEDBACK & STYLE SELECTION ---
               const btn = document.getElementById('scan-btn'); 
                const originalText = btn.innerHTML; const originalClass = btn.className;
                
                const styleEl = document.getElementById('scan-style-final');
                const styleMode = styleEl ? styleEl.value : 'frontal';
                const styleLabels = { 
                    frontal: 'FRONTAL SCAN',
                    rev_animated: 'REV ANIMATED',
                    digital: 'DIGITAL SCAN',
                    realistic: 'REALISTIC SCAN', 
                    lexica: 'LEXICA SCAN', 
                    leonardo: 'ART SCAN', 
                    seaart: 'INFINITY SCAN',
                    pixar: 'PIXAR SCAN',
					style_clone: 'DIGITAL CLONE'
                };
                
                const statusMsg = `SCANNING: ${styleMode.toUpperCase()} (${provider})`;
                
                btn.className = "px-3 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold border border-blue-400 shadow-lg shadow-blue-900/40 animate-pulse flex items-center gap-1.5 transition-all";
                btn.innerHTML = `${styleLabels[styleMode] || 'SCANNING'}...`; 
                btn.disabled = true; 
                
                updateAppStatus('busy', statusMsg);

                try {
                    let promptText = "";

                    // ====================================================
                    //  STYLE 1: FRONTAL REALISM (YOUR LEVEL X RULE)
                    // ====================================================
                    if (styleMode === 'frontal') {
                        promptText = `You are a High-End Editorial & Cinematic Descriptive Analyst.

						Task:
						Analyze the provided image and convert it into a richly detailed, premium Stable Diffusion prompt.
						The output must be a SINGLE PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent elements not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: IDENTITY & STRUCTURAL FIDELITY
						- You MUST preserve and accurately describe the subject’s identity, gender, body structure, and attire exactly as observed in the image.
						- Do NOT exaggerate, reduce, or reinterpret proportions.
						- Describe any naturally prominent features factually as they appear, explaining their visibility through posture, garment construction, and camera perspective.
						- Elevate descriptive quality to Vogue / high-end editorial standards while remaining strictly observational.

						2. SARTORIAL STRUCTURE (EDITORIAL FIT DESCRIPTION)
						- Describe how the garment fits and interacts with the subject’s form as seen.
						- Use high-fashion, policy-safe vocabulary only:
						  "Bespoke tailoring", "Architectural fit",
						  "Precision-contoured construction", "Sculpted drape",
						  "Anatomically defined silhouette".
						- Clothing should be described in terms of tailoring, seam placement, and gravity-driven drape — never staged or forced.

						3. FABRIC PHYSICS (OBSERVED MATERIAL BEHAVIOR)
						- Describe fabric properties as visually evident.
						- Use refined textile language:
						  "Lightweight silk weave", "Fine georgette",
						  "Air-permeable chiffon", "Fluid satin drape",
						  "Delicate cotton voile".
						- Explain how the fabric responds to movement, airflow, and gravity in the image, revealing natural form through structure and fall.

						4. FRONTAL ORIENTATION & COMPOSITION
						- Describe the subject’s orientation exactly as observed.
						- When front-facing, clearly describe:
						  symmetrical facial alignment,
						  shoulders squared to the camera,
						  torso oriented directly toward the viewer,
						  composed and confident posture.
						- Framing must be described as centered, balanced, and intentional.

						5. CAMERA & OPTICAL CHARACTER
						- Describe camera behavior cinematically, not technically.
						- Use observational lens language such as:
						  "85mm prime lens look",
						  "natural perspective compression",
						  "shallow depth of field with precise subject focus",
						  "editorial center-framed composition".
						- Describe camera height and distance as seen, ensuring proportions remain undistorted.

						6. LIGHTING (EDITORIAL CINEMATIC REALISM)
						- Describe lighting exactly as visible using cinematic photography language:
						  "Rembrandt-style lighting",
						  "controlled chiaroscuro contrast",
						  "directional key light shaping facial planes",
						  "soft fill light maintaining shadow detail",
						  "subtle rim light separating subject from background".
						- Shadows must be deep yet readable, never crushed or flat.
						- Lighting should be described in terms of how it reveals existing form and depth.

						7. SKIN FIDELITY (OBSERVED NATURAL REALISM)
						- Describe skin as it appears: unfiltered, tactile, and lifelike.
						- Include visible micro-detail where present:
						  pores, micro-texture, fine vellus hair,
						  natural tonal variation, faint marks,
						  expression lines and subtle imperfections.
						- Describe realistic light interaction:
						  subsurface scattering,
						  natural oil highlights,
						  matte response in shadowed areas.
						- Avoid idealization unless explicitly visible as a stylistic choice.

						8. HAIR & ACCESSORY ACCURACY
						- Describe hair color, texture, density, and styling exactly as observed.
						- Do NOT introduce blonde hair unless clearly present.
						- Describe accessories in terms of material, scale, and light response.

						9. ATMOSPHERE & STYLE (REALISTIC FANTASY · 2.5D)
						- Describe overall style as a blend of realism and refined stylization.
						- Comparable to premium editorial photography with cinematic fantasy polish.
						- Only describe atmospheric or special effects if visible:
						  soft mist, light particles, subtle energy motes,
						  drifting petals, faint luminous accents.
						- Effects must enhance depth and mood without distracting from the subject.

						10. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
						
						FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }

                    // ====================================================
                    //  STYLE 2: REV ANIMATED (Massive Painterly Rule)
                    // ====================================================
                    else if (styleMode === 'rev_animated') {
                        promptText = `You are a Master Digital Concept Artist & Painter specializing in SD 1.5 RevAnimated-style illustration.

							Task:
							Convert the user’s prompt into a MASSIVE, richly descriptive DIGITAL PAINTING prompt
							that faithfully reflects the RevAnimated (SD 1.5) aesthetic.
							The output must be a SINGLE PARAGRAPH of approximately 500–600 words.
							Do NOT summarize. Do NOT invent narrative events not implied by the prompt.

							────────────────────────────────
							CRITICAL INSTRUCTIONS (EXECUTE FULLY)
							────────────────────────────────

							1. PRIME DIRECTIVE: REV ANIMATED PAINTERLY IDENTITY
							- The visual output MUST strongly resemble images generated by the SD 1.5 RevAnimated model.
							- The aesthetic must be painterly, anime-adjacent, and romanticized — not realistic, not photographic.
							- Explicitly AVOID photographic or render terminology:
							  "Photorealistic", "3D render", "camera noise", "film grain", "sharp photographic focus".
							- REQUIRED descriptors:
							  "Digital oil painting", "RevAnimated illustration",
							  "Anime-inspired painterly style", "Soft blended brushstrokes",
							  "Dreamy, romantic atmosphere".

							2. COMPOSITION & SCENE INTEGRITY (REV-CORRECT)
							- Describe a complete, intentional composition.
							- Always include:
							  subject posture, environment, and spatial context.
							- Favor:
							  "Wide cinematic composition",
							  "Full-scene framing",
							  "Balanced foreground, midground, and background".
							- Avoid floating or isolated heads; the subject must feel grounded within a painted environment.

							3. SUBJECT AESTHETIC (ROMANTIC IDEALISM · REV STYLE)
							- Describe the subject using anime-adjacent proportions:
							  idealized, harmonious, softly exaggerated, not physically strict.
							- Facial features should be refined and expressive.
							- Eyes must be large, luminous, emotionally resonant, and softly glowing.
							- Hair should be flowing and voluminous, painted with visible strand direction near the roots
							  and progressively softer blends toward the tips.

							4. SKIN RENDERING (REV ANIMATED ILLUSTRATION LOGIC)
							- Skin must follow illustrated anime-painter logic, not photographic realism.
							- Describe:
							  smooth tonal gradients,
							  soft airbrushed shading,
							  gentle highlight bloom,
							  painterly color transitions.
							- Avoid pore-level detail, sharp texture, or hyper-real skin realism.
							- Subsurface scattering should be described as an artistic glow, not physical simulation.

							5. COLOR SCIENCE & PALETTE CONTROL
							- Describe an intentional, harmonious color palette.
							- Favor warm, romantic tones balanced with cool accents.
							- Skin tones should blend naturally into the palette,
							  never gray, flat, or over-saturated.
							- Use color contrast and saturation subtly to draw focus toward the subject’s face.

							6. LIGHTING (REV ANIMATED GLOW-BASED)
							- Lighting must feel painterly, soft, and cinematic.
							- Use concepts such as:
							  "Soft directional light",
							  "Ambient glow",
							  "Painterly rim illumination",
							  "Gentle bloom around highlights".
							- Highlights should softly bleed into surrounding colors.
							- Avoid hard shadows, crisp edges, or photographic lighting behavior.

							7. MATERIAL & COSTUME RENDERING (PAINTERLY)
							- Describe clothing and accessories as painted materials.
							- Fabrics should show stylized folds, soft highlights, and smooth color variation.
							- Metals and jewelry should have painterly specular accents,
							  never mirror-like reflections.
							- Material rendering should enhance elegance without hyper-detail overload.

							8. BACKGROUND & ATMOSPHERE (REV WATERCOLOR FUSION)
							- Backgrounds must be abstracted, dreamy, and painterly.
							- Use elements such as:
							  watercolor washes,
							  soft gradients,
							  pastel floral or organic shapes,
							  floating light particles,
							  bokeh-like color blooms.
							- Background detail should dissolve progressively with depth.

							9. DEPTH, MOTION & VISUAL FLOW
							- Describe visual flow created by brush direction, lighting gradients, and color movement.
							- Suggest gentle motion through flowing hair, fabric, mist, or particles.
							- The composition should naturally guide the viewer’s eye across the scene.

							10. STYLE CONSISTENCY ENFORCEMENT
							- Every element must feel intentionally illustrated.
							- Do NOT mix photographic realism with painterly anime logic.
							- The entire description must maintain cohesive RevAnimated identity from start to end.
							
							11. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
						
						FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }

                    // ====================================================
                    //  STYLE 3: DIGITAL ART (Modern Comic / Graphic Novel)
                    // ====================================================
                    else if (styleMode === 'digital') {
                        promptText = `You are a Lead Comic Book & Graphic Novel Art Analyst
						specializing in modern digital comic illustration styles
						inspired by Marvel, DC, and Webtoon aesthetics.

						Task:
						Analyze the provided image and convert it into a richly detailed,
						VISION-SAFE COMIC BOOK ILLUSTRATION prompt.
						The output must be a SINGLE PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent elements not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: COMIC BOOK AESTHETIC TRANSLATION
						- The description must translate the observed image into a digital comic / graphic novel style.
						- The result must read as illustrated artwork, not photography or 3D rendering.
						- Explicitly AVOID:
						  "Photorealistic", "3D render", "flat vector", "corporate art", "minimalist".
						- REQUIRED descriptors:
						  "Digital comic illustration",
						  "Graphic novel art style",
						  "Inked linework",
						  "Cel-shaded coloring",
						  "High-quality stylized illustration".

						2. LINE WORK & INKING (OBSERVED STYLE)
						- Describe linework as clean, confident, and expressive.
						- Mention varying line weights to emphasize form, depth, and motion where visible.
						- Use inking techniques such as:
						  solid black shadows,
						  contour lines,
						  hatching or cross-hatching
						  if they are visually implied by the style.
						- Linework should enhance clarity and character definition, not clutter the image.

						3. COLOR & SHADING (COMIC LOGIC)
						- Describe colors as bold, punchy, and intentionally stylized.
						- Use cel shading logic with clear light and shadow separation.
						- Allow gradient fills where appropriate, especially for Webtoon-inspired looks.
						- Rim lighting and highlight accents may be used to enhance readability and drama.
						- Avoid photographic lighting behavior or soft realism.

						4. COMPOSITION & PANEL DYNAMICS
						- Describe the composition as cinematic and intentional.
						- Use terms such as:
						  "Dynamic panel composition",
						  "Hero-focused framing",
						  "Dramatic perspective",
						  "Action-oriented stance"
						  when visually present.
						- The subject should appear engaged and expressive, not stiff or static.
						- Composition must feel like a strong comic panel or splash page.

						5. SUBJECT & IDENTITY FIDELITY
						- Describe the subject’s facial features and body structure exactly as observed.
						- Preserve unique facial characteristics and natural asymmetry to avoid genericization.
						- Do NOT idealize, exaggerate, or alter proportions.
						- Identity fidelity should be achieved through accurate descriptive detail,
						  not through measurements or biometric language.

						6. SKIN & SURFACE RENDERING (ILLUSTRATED)
						- Describe skin using comic illustration logic.
						- Skin should appear smooth and stylized with controlled shading,
						  not pore-level realism.
						- Use clean tonal transitions and highlight placement to suggest form.
						- Avoid plastic, airbrushed, or overly glossy appearances unless stylistically visible.

						7. LIGHTING & ATMOSPHERE (GRAPHIC NOVEL STYLE)
						- Lighting should feel dramatic and illustrative.
						- Use:
						  strong directional light,
						  stylized shadows,
						  rim lighting,
						  atmospheric glow
						  if visible.
						- Lighting must enhance mood, depth, and narrative presence,
						  not mimic real-world photography.

						8. ENVIRONMENT & BACKGROUND
						- Describe the background as part of the illustrated scene.
						- Backgrounds may be simplified, stylized, or abstracted,
						  but must support the subject and composition.
						- Use comic-appropriate elements such as:
						  stylized cityscapes,
						  abstract shapes,
						  motion lines,
						  atmospheric effects
						  if present.
						- Background detail should not overpower the subject.

						9. TEXTURE & FINISH
						- Describe a clean digital finish with visible illustration texture.
						- Optional elements may include:
						  halftone patterns,
						  screentone textures,
						  speed lines
						  if they align with the visual style.
						- The final look should feel polished, expressive, and intentionally illustrated.

						10. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
						FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }

                    // ====================================================
                    //  STYLE 4: REALISTIC (UNIVERSAL "NARRATIVE FORENSICS" - FLUX/ZIMAGE HYBRID)
                    // ====================================================
                    else if (styleMode === 'realistic') {
                        promptText = `You are a Lead Visual Forensics Analyst and Realism-Oriented Visual Storyteller.

						Task:
						Perform a deep, observational scan of the provided image and output the result as a
						SINGLE, CONTINUOUS, HYPER-DESCRIPTIVE NARRATIVE PARAGRAPH suitable for realistic image generation.
						The final output MUST be written as flowing prose with no headers, no lists, and no formatting breaks.
						Flux/zimage requires uninterrupted narrative text.

						The description must remain strictly observational, describing only what is visibly present
						and how it appears under real-world physical conditions.

						────────────────────────────────
						INTERNAL ANALYSIS GUIDELINES
						(Use internally, but blend seamlessly into the narrative)
						────────────────────────────────

						IDENTITY & VISUAL ANCHOR:
						Begin immediately by establishing the subject’s apparent ethnicity, age range, and skin tone as visible.
						Describe facial structure organically within the narrative, noting eye shape, brow position, nose structure,
						jawline, and mouth without idealization or exaggeration.
						Include visible facial imperfections or asymmetries such as faint lines, under-eye shadows, or uneven features
						only if they are present in the image.

						BODY STRUCTURE & PHYSICAL PRESENCE:
						Describe the subject’s body structure exactly as observed, using neutral, physical language.
						Explain how posture, stance, and orientation contribute to the subject’s visual presence.
						Any prominence or mass should be described only as it appears, using cause-and-effect reasoning
						linked to posture, gravity, and garment construction, never enhancement or comparison.

						POSE, ORIENTATION & HANDS:
						Accurately describe the subject’s orientation relative to the camera, including angle, tilt, and stance.
						Describe the position of the arms and hands exactly as visible.
						Do NOT invent gestures or hand placement.
						Pose description must feel grounded, natural, and physically plausible.

						CLOTHING & MATERIAL RESPONSE:
						Identify the specific garments worn and describe their material, structure, and fit as observed.
						Explain how fabric responds to gravity, movement, and underlying form in realistic terms.
						Describe folds, tension, drape, and layering without implying exposure or alteration.
						Include visible accessories, jewelry, patterns, or textures only if present.

						SKIN SURFACE & MICRO DETAIL:
						Describe skin as real, unprocessed human tissue.
						Include visible characteristics such as natural texture, tonal variation, subtle sheen, fine hair,
						creases from posture, or environmental effects if visible.
						Avoid fetishistic focus; all skin detail should serve realism, not emphasis.

						LIGHTING, ENVIRONMENT & IMAGE QUALITY:
						Describe the lighting source and quality as observed, including direction, softness, and shadow behavior.
						Explain how light reveals form, depth, and surface detail without dramatization.
						Describe the surrounding environment briefly, focusing on how it frames or contextualizes the subject.
						If image quality characteristics are visible (resolution, grain, lens behavior), describe them neutrally.

						TECHNICAL REALISM:
						If apparent, reference realistic capture qualities such as depth of field, perspective compression,
						and natural optical behavior without over-specification.
						Avoid fictional camera metadata unless it is visually implied.
                        - **TECH:** "Unprocessed, grainy, 8k raw photo, Fujifilm GFX 100S."
				        MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }
					
					// ====================================================
                    //  STYLE 5: LEXICA (DREAMY/GLOOMY LEVEL X - OBSERVATIONAL)
                    // ====================================================
                    else if (styleMode === 'lexica') {
                        promptText = `You are a Stylized AI Portrait Aesthetic Analyst specializing in the visual style commonly
						seen in Lexica.art galleries and prompt-curated AI portrait collections.

						Task:
						Analyze the provided image and translate it into a highly polished,
						STYLIZED 3D PORTRAIT description that matches Lexica.art aesthetics.
						The output must be a SINGLE, FLOWING PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent features not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. CORE AESTHETIC: LEXICA-STYLE STYLIZED REALISM
						- The result must look intentionally AI-rendered and digitally perfected,
						  not photographed, not painterly, and not physically strict.
						- The overall appearance should feel clean, smooth, idealized,
						  and visually optimized for prompt-based image generation.
						- Avoid cinematic grit, painterly texture, or real-world imperfections.

						2. IDENTITY PRESERVATION WITH SOFT IDEALIZATION
						- Preserve the subject’s identity, facial structure, and proportions as observed.
						- Describe idealization as subtle smoothing and refinement,
						  not reshaping or exaggeration.
						- Facial features should remain recognizable,
						  with a slight symmetry bias typical of Lexica-style portraits.

						3. SKIN AS SYNTHETIC SURFACE (LEXICA LOOK)
						- Describe skin as digitally smooth and evenly toned.
						- Use language such as:
						  soft synthetic sheen,
						  clean surface gradients,
						  gentle subsurface scattering glow,
						  uniform coloration.
						- Do NOT describe pores, blemishes, scars, grain, or texture noise.
						- The skin should appear pristine and intentionally artificial.

						4. LIGHTING: SOFT, NEUTRAL, AND UNIFORM
						- Lighting must feel globally diffused and non-directional.
						- Use:
						  soft ambient illumination,
						  gentle highlight bloom,
						  shallow shadow depth.
						- Avoid dramatic contrast, harsh shadows, or cinematic chiaroscuro.
						- The subject should appear evenly lit, calm, and visually clear.

						5. MATERIALS & DETAIL SIMPLIFICATION
						- Describe clothing and accessories as clean, simplified luxury materials.
						- Fabrics should appear smooth and softly reflective,
						  without fiber detail or surface wear.
						- Jewelry and metallic elements should appear polished and pristine,
						  with simplified reflections.
						- Hair should be neatly styled and softly volumized,
						  with smooth strand flow and minimal flyaways.

						6. COMPOSITION & FRAMING (LEXICA STANDARD)
						- Favor centered, balanced portrait composition.
						- Typically describe:
						  bust-length or head-and-shoulders framing,
						  relaxed posture,
						  neutral or softly expressive facial expression.
						- Depth of field should be shallow but subtle,
						  with a softly blurred, non-distracting background.

						7. RENDER QUALITY (IMPLICIT, NOT TECHNICAL)
						- Convey high-resolution clarity and clean rendering
						  without naming specific engines or render software.
						- Avoid heavy technical jargon.
						- The final image should feel “prompt-perfect”,
						  polished, and ready for gallery presentation.

						8. STYLE CONSISTENCY
						- Every element must reinforce the Lexica.art aesthetic:
						  clean, idealized, calm, and synthetic.
						- Do NOT mix painterly, photographic, cinematic, or gritty realism styles.
						- The result must clearly read as a Lexica-style AI portrait.
						
						9. MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
					
			}
                    // --- STYLE 6: LEONARDO (CLONE) ---
                    else if (styleMode === 'leonardo') {
                        promptText = `You are a Digital Rendering & Visual Analysis Specialist
							trained to describe images in the distinctive visual style
							produced by the Phoenix family of models on leonardo.ai.

							Task:
							Analyze the provided image and translate it into a
							SINGLE, CONTINUOUS, HYPER-DESCRIPTIVE NARRATIVE PARAGRAPH
							that aligns precisely with Phoenix-style outputs.
							No headers, no lists, no formatting breaks in the final output.

							────────────────────────────────
							CRITICAL INSTRUCTIONS (EXECUTE FULLY)
							────────────────────────────────

							1. PRIME DIRECTIVE: PHOENIX VISUAL IDENTITY
							- The description must reflect Phoenix-style stylized digital realism.
							- The output must feel digitally constructed, not photographed and not painterly.
							- Avoid historical art language, brush metaphors, or canvas references.
							- Avoid cinematic or film-based terminology.

							2. IDENTITY & FACIAL STRUCTURE (OBSERVATIONAL)
							- Begin by describing the subject’s face as visibly observed.
							- Describe eye shape, brow placement, nose structure, jawline, lips,
							  and natural asymmetries without correction or idealization.
							- Maintain facial identity fidelity through descriptive accuracy,
							  not biometric measurements or cloning language.

							3. SKIN SURFACE (DIGITAL MATERIAL LOGIC)
							- Describe skin as a smooth digital surface rather than biological tissue.
							- Use Phoenix-appropriate language:
							  even tonal gradients,
							  soft surface transitions,
							  controlled subsurface glow,
							  clean, uniform coloration.
							- Avoid pores, blemishes, grain, noise, or macro realism.
							- Skin should feel refined and synthetic, but not plastic or waxy.

							4. BODY PRESENCE & POSTURE
							- Describe body structure and physical presence exactly as observed.
							- Explain form using posture, perspective, and lighting interaction.
							- Do not exaggerate, reduce, or enhance any features.
							- Presence should feel balanced and constructed, not staged or emphasized.

							5. CLOTHING & MATERIAL RESPONSE
							- Identify garments exactly as seen.
							- Describe fabrics in terms of digital material qualities:
							  soft sheen,
							  smooth folds,
							  controlled highlights,
							  subtle reflectivity.
							- Avoid painterly or tactile metaphors.
							- Describe how clothing follows form naturally without strain or emphasis.

							6. HAIR & GROOMING (STYLIZED CGI)
							- Describe hair as digitally groomed with organized strand groups.
							- Emphasize smooth flow, controlled volume, and soft edge transitions.
							- Avoid painterly brushstroke language or photographic flyaway detail.

							7. LIGHTING (CONSTRUCTED DIGITAL ILLUMINATION)
							- Describe lighting as intentionally designed rather than naturally occurring.
							- Use language such as:
							  soft diffuse illumination,
							  balanced ambient light,
							  gentle shadow falloff,
							  subtle glow shaping form.
							- Avoid dramatic contrast, hard shadows, or chiaroscuro.

							8. COMPOSITION & SPATIAL DESIGN
							- Describe composition as centered, stable, and intentionally framed.
							- Favor portrait-style balance and calm presentation.
							- Depth should feel digitally created rather than optically captured.
							- Backgrounds should be simplified, softly blurred, or atmospheric.

							9. COLOR & TONAL HARMONY
							- Describe colors as clean, harmonious, and controlled.
							- Avoid extreme saturation or gritty contrast.
							- Skin tones, clothing, and background should integrate smoothly
							  within a unified palette.

							10. STYLE CONSISTENCY ENFORCEMENT
							- Every part of the description must reinforce Phoenix-style digital realism.
							- Do NOT mix painterly, comic, Lexica, or photorealistic language.
							- The final paragraph should read like a polished digital rendering brief,
							  optimized for Phoenix-family model interpretation.
							  
							11. MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }

                    // --- STYLE 7: SEEART (The Master Level X) ---
                    else if (styleMode === 'seaart') {
                        promptText = `You are a Senior Visual Description Engineer specializing in the
						SeaArt.ai Infinity model’s cinematic hyper-realistic output style.

						Task:
						Analyze the provided image and translate it into a SINGLE, CONTINUOUS,
						NATURAL-LANGUAGE DESCRIPTION optimized for SeaArt Infinity.
						The final output must be a flowing paragraph of approximately 500–600 words.
						Do NOT use headers, lists, formatting markers, or technical scaffolding in the output text.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: INFINITY REALISM IDENTITY ANCHOR
						- The opening sentence must immediately establish the subject’s face as observed.
						- Begin naturally by describing face shape, eye structure, gaze, expression, and facial balance.
						- Identity must be preserved through descriptive accuracy, not enhancement or alteration.
						- Avoid biometric measurements or cloning terminology.

						2. FACIAL DETAIL & EXPRESSION (OBSERVATIONAL)
						- Describe facial features exactly as visible:
						  eye spacing, brow shape, nose structure, lip contour, jawline presence.
						- Include subtle asymmetries and micro-expressions only if present.
						- Expression should feel natural, candid, and human, not posed or exaggerated.

						3. SKIN FIDELITY (INFINITY-STYLE REALISM)
						- Describe skin as highly realistic and tactile without exaggeration.
						- Use Infinity-appropriate realism:
						  visible pores at close range,
						  natural micro-texture,
						  subtle tonal variation,
						  soft specular highlights from natural skin oils.
						- Avoid plastic, waxy, or airbrushed appearance.
						- Do not fetishize or isolate skin regions.

						4. BODY STRUCTURE & PHYSICAL PRESENCE
						- Describe the subject’s body structure exactly as observed in the image.
						- Any sense of prominence, curvature, or mass must be explained through
						  posture, perspective, garment fit, and lighting — never enhancement.
						- Avoid comparative language or size enforcement.
						- The subject should feel physically grounded and proportionally coherent.

						5. POSE, GESTURE & KINETICS
						- Describe the subject’s posture, orientation, and movement as visible.
						- Hands, arms, shoulders, and stance must be described accurately.
						- The pose should feel naturally captured, not staged or sculpted.
						- If motion is present, describe it subtly and realistically.

						6. CLOTHING & MATERIAL BEHAVIOR
						- Identify garments exactly as seen.
						- Describe fabric type, weight, and texture using realistic material language.
						- Explain how clothing drapes, folds, or contours due to gravity and motion.
						- Avoid language implying strain, exposure, or intentional emphasis.

						7. LIGHTING (SEAART INFINITY SIGNATURE)
						- Lighting should feel cinematic yet realistic.
						- Use language such as:
						  balanced studio or environmental light,
						  controlled highlights,
						  soft but defined shadow transitions.
						- Avoid harsh spotlighting or extreme contrast unless clearly visible.
						- Lighting should enhance clarity, depth, and realism.

						8. COLOR & TONAL CONTROL
						- Describe color as rich, natural, and harmonized.
						- Skin tones should feel believable and integrated into the scene.
						- Avoid oversaturation or artificial color extremes.

						9. DEPTH, FOCUS & IMAGE QUALITY
						- Describe realistic depth of field and spatial separation if visible.
						- The subject should appear sharply resolved against a softly receding background.
						- Avoid explicit camera metadata unless visually implied.
						- The image should feel high-resolution, clean, and professionally captured.

						10. ENVIRONMENT & CONTEXT
						- Briefly describe the environment only as it supports the subject.
						- Backgrounds should feel realistic, unobtrusive, and contextually appropriate.
						- Avoid clutter or narrative invention.

						11. STYLE CONSISTENCY (NON-NEGOTIABLE)
						- The entire description must remain cinematic, realistic, and human.
						- Do NOT introduce CGI, painting, anime, comic, or stylized rendering language.
						- Do NOT exaggerate anatomy or modify identity.
                        
                        12. **ATMOSPHERIC & PARTICLE EFFECTS (VFX LAYER):**
                            - **PARTICLE DENSITY:** If the image has atmosphere, describe "Floating dust motes," "Glowing embers," "Pollen spores," or "Rain droplets."
                            - **VOLUMETRICS:** Describe "God Rays," "Haze," "Fog density," or "Bloom."
                            - **OPTICAL DEPTH:** Mention "Bokeh," "Depth of Field," and "Lens Flares" if present.
                            - **MAGIC/CHAOS:** If the scene is fantasy, describe the "Swirling energy," "Neon sparks," or "Magical aura."
							
						13.MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }

                    // --- STYLE 8: PIXAR (Stylized 3D Animation) ---
                    else if (styleMode === 'pixar') {
                        promptText = `You are a Lead Animator (Pixar / Disney / Illumination).
                        Task: Describe this image as a "STYLIZED 3D ANIMATED CHARACTER" (600+ Words).
                        
                        CRITICAL INSTRUCTIONS (EXECUTE ALL RULES FULLY):

                        1. **SHAPE LANGUAGE & PROPORTIONS:**
                        - **CARICATURE:** "Big expressive eyes," "Small button nose," "Round face shape."
                        - **BODIES:** "Stylized proportions," "Exaggerated features," "Soft curves."

                        2. **SURFACE MATERIALITY (TOY-LIKE):**
                        - **SKIN:** "Soft plastic," "Gummy texture," "Smooth shading."
                        - **HAIR:** "Clumped strands," "Fiber mesh," "Perfect grooming."

                        3. **LIGHTING & COLOR:**
                        - **MOOD:** "Bright," "Cheerful," "Warm Bounce Light," "Soft Shadows."
                        - **PALETTE:** "Vibrant," "Pastel," "Saturated."

                        4. **RENDER ENGINE:**
                        - "RenderMan," "Redshift," "CGSociety 3D."
                        - **BANNED:** "Photorealism," "Pores," "Noise," "Grain."

                        5. **MANDATORY NEGATIVE SYNTHESIS:**
                        - **FOR STYLE:** "photograph, realistic, scary, creepy, dark, gritty, noise."
                        - **FOR SKIN:** "pores, wrinkles, blemishes, veins."
						
						FORMAT: [Detailed Shot & Angle Analysis] -> [Camera, Lens & Sensor Details] -> [Biometric Identity Description] -> [Skin Texture & Imperfections] -> [Lighting & Atmosphere] -> [Composition & Environment] |NEGATIVE| [Strict Negative List]`;
                    }
					// ====================================================
                    //  STYLE: UNIVERSAL STYLE CLONER (Visual Reverse Engineering)
                    // ====================================================
                    else if (styleMode === 'style_clone') {
                        promptText = `Analyze this image and output a detailed Stable Diffusion prompt.
							Focus MAINLY on: Main Subject and the Image setting, Subject gender and body type in detail as it is in the image exactly, Hair style and placement, Limbs position and placement, Clothing and Attire, Action of the subject, Lighting, Camera Angle and Shot, and Art/Photo Style set in a mix between a photo and fantasy, not totally a real photo also not total anime, a mix somewhere bove 2.5D, with a magical and fantasy setting and adding random particle effects (eg. Falling rain drops, falling snow flakes, electric arcs, plasma vortex, dust motes, raging flames, floating rose petals etc.).
							
							CRITICAL INSTRUCTIONS (EXECUTE FULLY):

							1. **PRIME DIRECTIVE: PRESERVE IDENTITY & ELEVATE ATTIRE**
							- You MUST retain the specific Subject, Gender, and Attire exactly as defined. Do not genericize.
							- Elevate the description to high standards. If the user says "Saree," describe "translucent chiffon," "delicate lace borders," or "intricate chikankari."

							2. **SARTORIAL SCULPTING (THE "FIT" BYPASS):**
							- AI models often default to baggy clothing. You must correct this by describing the **architectural fit**.
							- Use safe, high-fashion vocabulary: "Bespoke tailoring," "Second-skin fit," "Anatomically defined silhouette," "Sculpted bodice."
							- State that the fabric "clings to the natural curvature of the form" and "accentuates the silhouette with precision."

							3. **FABRIC PHYSICS (LOW GSM & LIQUIDITY):**
							- **NO DENSE FABRICS:** Explicitly ban "High GSM," "Thick," "Stiff," or "Heavy" materials. The fabric must be "Ultra-lightweight," "Breathable," and "Gauzy."
							- Use phrases like: **"Sheer liquid silk," "Translucent georgette," "Paper-thin cotton," "Molten satin."**
							- Describe the fabric as having a "lightweight, fluid drape" that reacts to the slightest movement.

							4. **SKIN FIDELITY (EXTREME MACRO REALISM):**
							- **UNFILTERED RAW TEXTURE:** The skin MUST look "obsessively detailed" and "uncomfortably real." Demand visible "stretching pores," "micro-surface texture," "vellus hair," and "natural unevenness."
							- **MANDATORY IMPERFECTIONS:** Describe "faint acne scars," "freckles," "fine wrinkles," "hyper-pigmentation," and "sunspots."
							- **LIVING TISSUE:** Skin must exhibit "subsurface scattering" and "natural oil speculars."

							5. **NO BLONDE HAIR:** Unless explicitly mentioned, no blonde hair.

							6. **LENS & CAMERA METADATA:**
							- Force the AI to use: "85mm f/1.2 Prime Lens," "ISO 400," "Shutter Speed 1/250."
							- Describe optical artifacts: "Chromatic Aberration," "Film Grain," "Vignette," "Lens Flare."

							7. **LIGHTING (DRAMATIC):**
							- "Rembrandt Lighting," "Chiaroscuro," "Hard Flash," "Volumetric God-Rays," "High Dynamic Range (HDR)."
							- Shadows must be "Deep" and "Detailed."

                            8. **SPECIAL STYLE REFERENCE: ReV ANIMATED (Check if Source matches this)**
                            - **2.5D Aesthetic:** Look for a "2.5D" look—not quite flat 2D anime, but not fully photorealistic either. It has a polished, "rendered" quality often seen in high-end mobile game art or concept art.
                            - **Vibrant & Contrast-Heavy:** Check for punchy colors, dramatic lighting (volumetric fog, glowing effects), and high contrast.
                            - **Fantasy & Sci-Fi Bias:** Note any fantasy armor, magic effects, glowing runes, and futuristic cyberpunk aesthetics.
                            - **"Porcelain" Skin:** If the subject has very smooth, idealized skin (sometimes too smooth/plastic), explicitly describe it as "ReV Animated Style, semi-realistic, idealized skin texture."

							9. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE):**
							   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
							   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender, hidden cleavage, covered cleavage, hidden navel, covered navel, breasts smaller than size 36D, less cleavage, less than 4K resolution."
							   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
							   - **ARTIFICIALITY:** "Cartoon, anime, plastic, doll, drawing."
							   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.

							Limit to 400 words. Full sentences, no unnecessary filler.

							CRITICAL OUTPUT FORMAT:
							[Positive Prompt Here] ###NEGATIVE### [Negative Prompt Here with other style specific negatives and negatives required to clone the provided image]`;
                    }

                    let analysis = "";

                    // --- EXECUTE SCAN ---
                    if (provider === 'GEMINI') {
                        const reader = new FileReader();
                        reader.readAsDataURL(file);
                        await new Promise(r => reader.onloadend = r);
                        const base64Data = reader.result.split(',')[1];
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${scanModel}:generateContent?key=${geminiKey}`, { 
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ contents: [{ parts: [ { text: promptText }, { inlineData: { mimeType: file.type, data: base64Data } } ] }] }) 
                        });
                        const data = await response.json();
                        if (!response.ok) throw new Error("Gemini Error: " + (data.error?.message || response.status));
                        analysis = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    } 
                    else {
                        const WORKER_URL = "https://pb-vision-proxy.nswlko.workers.dev/";
                        const base64Img = await resizeImageToBase64(file, 512);
                        const payload = { accountId: cfAccount, apiToken: cfToken, model: scanModel, max_tokens: 1024, messages: [ { role: "user", content: [ { type: "text", text: promptText }, { type: "image_url", image_url: { url: base64Img } } ] } ] };
                        const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        const txt = await response.text();
                        let data; try { data = JSON.parse(txt); } catch(e) { throw new Error("Proxy Error"); }
                        if (!data.success && !data.result) throw new Error("CF API Error");
                        analysis = data.result?.response || "";
                    }

                    if(analysis) { 
                        let cleanText = analysis.replace(/^(\*\*|#)?(Here is|The image|Prompt|Output)(\*\*|#|:).{0,50}(\*\*|#|:)?\s*/i, "").replace(/^["']|["']$/g, "").trim();
                        
                        // PARSE NEGATIVES
                        let positivePart = cleanText;
                        let negativePart = "";
                        
                        if (cleanText.includes("|NEGATIVE|")) {
                            const split = cleanText.split("|NEGATIVE|");
                            positivePart = split[0].trim();
                            negativePart = split[1].trim();
                        }

                        // FORCE STYLE SUFFIXES
                        if (styleMode === 'frontal') positivePart += ", (8k raw photo), (Fujifilm GFX 100S), (hyperrealistic skin:1.4), (visible pores)";
                        if (styleMode === 'rev_animated') positivePart += ", (digital painting), (watercolor fusion), (soft brushstrokes), (artstation style)";
                        if (styleMode === 'digital') positivePart += ", (vector art), (flat color), (clean lines), (minimalist)";
                        if (styleMode === 'lexica') positivePart += ", unreal engine 5, octane render, 3d style, cgsociety";
                        if (styleMode === 'leonardo') positivePart += ", highly detailed, artistic style, illustration, dreamshaper";
                        if (styleMode === 'seaart') positivePart += ", seaart infinity style, flux.1 dev style, hyper-detailed, vibrant, clean lines";
                        if (styleMode === 'pixar') positivePart += ", pixar style, disney style, 3d render, cute, vibrant, unreal engine 5";
                        if (styleMode === 'realistic') positivePart += ", 8k raw photo, hyperrealistic, fujifilm gfx";
						if (styleMode === 'style_clone') positivePart += ",digital masterpiece, hyper style, hyperrealistic, fujifilm gfx";
                        const outBox = document.getElementById('output-text'); 
                        outBox.value = positivePart; 
                        autoResize(outBox);
                        
                        // Populate Negative Prompt if Box Exists
                        const negBox = document.getElementById('negative-prompt');
                        if (negBox) {
                            let baseNegatives = "";

                            // --- STYLE SPECIFIC HARDCODED NEGATIVES (SCANNER) ---
                            if (styleMode === 'frontal' || styleMode === 'realistic') {
                                baseNegatives = "cartoon, anime, 3d render, plastic skin, airbrushed, blur, sketch, bad anatomy, deformed,text, watermark";
                            } 
                            else if (styleMode === 'rev_animated') {
                                baseNegatives = "photorealistic, grain, noise, photography, 3d render";
                            } 
                            else if (styleMode === 'digital') {
                                baseNegatives = "photorealistic, grain, noise, shading, 3d, blurred";
                            } 
                            // --- seaart: THE "ANTI-DRIFT" SAFETY NET ---
                            else if (styleMode === 'seaart') {
                                baseNegatives = [
                                    // 1. VOLUME PROTECTION
                                    "small chest, petite breasts, flat chest, average size bodice, modest, reduced beasts, proportional, balanced",
                                    // 2. TEXTURE & SKIN
                                    "plastic skin, doll, wax, airbrushed, smooth, makeup, filter, perfect skin",
                                    // 3. YOUR QUALITY LIST
                                    "blurred, low-resolution, hazy, poorly lit, cropped head, cropped bust, cropped hands, cutout, watermark, text, signature, low saturation, low contrast, unrealistic skin, painting, drawing, cartoon, illustration, deformed, distorted, celebrity, generic model, asymmetrical face distortion, closed eyes, objects obscuring face"
                                ].join(", ");
                            }

                            // Combine AI's scanned negatives with our Hardcoded Safety Net
                            // We put the AI's output first, then enforce our rules
                            let combinedNegatives = (negativePart + ", " + baseNegatives)
                                .replace(/,\s*,/g, ',')  // Remove double commas
                                .replace(/^,\s*/, '')    // Remove leading comma
                                .trim();

                            negBox.value = combinedNegatives;

                            // Force the details dropdown open so you can verify it
                            if (combinedNegatives && negBox.closest('details')) {
                                negBox.closest('details').open = true;
                            }
                        }

                        addToHistory(positivePart, `SCAN_${provider}_${styleMode.toUpperCase()}`); 
                        showToast(`${styleLabels[styleMode]} Complete!`, "success");
                        outBox.dispatchEvent(new Event('input'));
                    } else { throw new Error("No description returned."); }

                } catch (e) { console.error(e); showToast("Scan Failed: " + e.message, "error"); } 
                finally { btn.innerHTML = originalText; btn.className = originalClass; btn.disabled = false; e.target.value = ''; updateAppStatus('idle'); }
            });
			
          // 15. ENHANCE BUTTON (MAGIC FIX - MASSIVE 500-WORD RULES)
            safeListen('enhance-btn', 'click', async () => {
                dismissKeyboard(); 
                const btn = document.getElementById('enhance-btn'); 
                const retryBtn = document.getElementById('retry-fix-btn'); 
                const rawBtn = document.getElementById('view-raw-btn');
                
                const baseClass = "h-12 rounded-xl bg-gradient-to-r from-purple-900/40 to-indigo-900/40 hover:from-purple-600 hover:to-indigo-600 border border-purple-500/30 backdrop-blur-md transition-all flex items-center justify-center gap-2 text-xs font-extrabold text-purple-300 hover:text-white shadow-[0_0_15px_rgba(168,85,247,0.15)] hover:shadow-[0_0_25px_rgba(168,85,247,0.4)] group tracking-wider";
                
                const outBox = document.getElementById('output-text');
                let rawPrompt = "";
                if (outBox) rawPrompt = outBox.value;
                
                if(!rawPrompt || rawPrompt === "No prompt generated.") {
                    showToast("Generate a prompt first!", "warning");
                    return;
                }

                window.lastRawPrompt = rawPrompt;
                
                if(rawBtn) {
                    rawBtn.classList.remove('hidden');
                    rawBtn.classList.remove('flex'); rawBtn.classList.add('flex'); 
                }
                if(retryBtn) retryBtn.classList.add('hidden'); 
                
                // Get Style Mode
                const styleEl = document.getElementById('scan-style-final');
                const styleMode = styleEl ? styleEl.value : 'frontal';
                
                const labels = {
                    frontal: 'FRONTAL FIX',
                    rev_animated: 'PAINTERLY FIX',
                    digital: 'DIGITAL FIX',
                    realistic: 'REALISM FIX',
                    lexica: 'LEXICA FIX',
                    leonardo: 'LEONARDO FIX',
                    seaart: 'SEAART FIX',
                    pixar: 'PIXAR FIX',
					style_clone: 'DIGITAL CLONE'
                };

                btn.className = "col-span-4 " + baseClass.replace("from-purple-900/40", "from-pink-600").replace("to-indigo-900/40", "to-rose-600").replace("border-purple-500/30", "border-pink-400");
                
                const cfAccount = document.getElementById('cf-account-id')?.value.trim();
                const cfToken = document.getElementById('cf-api-token')?.value.trim();
                const geminiKey = document.getElementById('api-key-input')?.value.trim();
                const hasGemini = !!geminiKey; const hasCloudflare = !!(cfAccount && cfToken);
                
                let provider = 'GEMINI'; 
                const pref = state.helper || 'auto'; 

                if (pref === 'auto') {
                    if (state.generator === 'gemini' && hasGemini) provider = 'GEMINI';
                    else if (state.generator === 'cloudflare' && hasCloudflare) provider = 'CLOUDFLARE';
                    else if (hasGemini) provider = 'GEMINI'; else provider = 'CLOUDFLARE';
                } else { provider = pref.toUpperCase(); }

                if (provider === 'GEMINI' && !hasGemini) { showToast("Helper: Gemini Key Missing", "error"); return; }
                if (provider === 'CLOUDFLARE' && !hasCloudflare) { showToast("Helper: Cloudflare Creds Missing", "error"); return; }

                btn.innerHTML = `<svg class="animate-spin w-3 h-3 text-white" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> ${labels[styleMode] || 'FIXING'}...`; 
                btn.disabled = true; updateAppStatus('busy', `MAGIC FIX: ${styleMode.toUpperCase()}...`);

                try {
                    const isScenery = state.subject === 'scenery';
                    let systemInstruction = "";

                    // ====================================================
                    // 1. GLOBAL SCENERY OVERRIDE (Subject = Scenery)
                    // ====================================================
                    if (isScenery) {
                        systemInstruction = `You are a Spatial Photography Expert & 3D Environment Artist.
                        Task: Rewrite the prompt into a 3D SPATIAL MASTERPIECE (500+ Words).
                        
                        CRITICAL INSTRUCTIONS:
                        1. **EXTREME Z-AXIS DEPTH:** Describe distinct layers (Foreground, Midground, Background) with intense separation.
                        2. **FOREGROUND (TACTILE):** Hyper-detailed textures inches from the lens (e.g., cracked ice, rust, dew droplets, pebbles).
                        3. **OPTICAL IMMERSION:** Force "Wide-angle distortion," "Vanishing point," "Atmospheric recession," "Volumetric fog."
                        4. **LIGHTING:** "Dynamic Range," "Global Illumination," "Ray Tracing," "Caustics."
                        5. **NO ANATOMY:** Pure environment. No text/watermarks.
						FORMAT: [300-500 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }
                    
                    // ====================================================
                    // 2. CHARACTER / OBJECT STYLES (Subject != Scenery)
                    // ====================================================
                    else {
                        
                    // --- STYLE A: FRONTAL EDITORIAL REALISM (Level X · Vision-Safe) ---
						if (styleMode === 'frontal') {
						  systemInstruction = `
						You are a High-End Editorial & Cinematic Descriptive Analyst.

						Task:
						Analyze the provided image and convert it into a richly detailed, premium Stable Diffusion prompt.
						The output must be a SINGLE PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent elements not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: IDENTITY & STRUCTURAL FIDELITY
						- You MUST preserve and accurately describe the subject’s identity, gender, body structure, and attire exactly as observed in the image.
						- Do NOT exaggerate, reduce, or reinterpret proportions.
						- Describe any naturally prominent features factually as they appear, explaining their visibility through posture, garment construction, and camera perspective.
						- Elevate descriptive quality to Vogue / high-end editorial standards while remaining strictly observational.

						2. SARTORIAL STRUCTURE (EDITORIAL FIT DESCRIPTION)
						- Describe how the garment fits and interacts with the subject’s form as seen.
						- Use high-fashion, policy-safe vocabulary only:
						  "Bespoke tailoring", "Architectural fit",
						  "Precision-contoured construction", "Sculpted drape",
						  "Anatomically defined silhouette".
						- Clothing should be described in terms of tailoring, seam placement, and gravity-driven drape — never staged or forced.

						3. FABRIC PHYSICS (OBSERVED MATERIAL BEHAVIOR)
						- Describe fabric properties as visually evident.
						- Use refined textile language:
						  "Lightweight silk weave", "Fine georgette",
						  "Air-permeable chiffon", "Fluid satin drape",
						  "Delicate cotton voile".
						- Explain how the fabric responds to movement, airflow, and gravity in the image, revealing natural form through structure and fall.

						4. FRONTAL ORIENTATION & COMPOSITION
						- Describe the subject’s orientation exactly as observed.
						- When front-facing, clearly describe:
						  symmetrical facial alignment,
						  shoulders squared to the camera,
						  torso oriented directly toward the viewer,
						  composed and confident posture.
						- Framing must be described as centered, balanced, and intentional.

						5. CAMERA & OPTICAL CHARACTER
						- Describe camera behavior cinematically, not technically.
						- Use observational lens language such as:
						  "85mm prime lens look",
						  "natural perspective compression",
						  "shallow depth of field with precise subject focus",
						  "editorial center-framed composition".
						- Describe camera height and distance as seen, ensuring proportions remain undistorted.

						6. LIGHTING (EDITORIAL CINEMATIC REALISM)
						- Describe lighting exactly as visible using cinematic photography language:
						  "Rembrandt-style lighting",
						  "controlled chiaroscuro contrast",
						  "directional key light shaping facial planes",
						  "soft fill light maintaining shadow detail",
						  "subtle rim light separating subject from background".
						- Shadows must be deep yet readable, never crushed or flat.
						- Lighting should be described in terms of how it reveals existing form and depth.

						7. SKIN FIDELITY (OBSERVED NATURAL REALISM)
						- Describe skin as it appears: unfiltered, tactile, and lifelike.
						- Include visible micro-detail where present:
						  pores, micro-texture, fine vellus hair,
						  natural tonal variation, faint marks,
						  expression lines and subtle imperfections.
						- Describe realistic light interaction:
						  subsurface scattering,
						  natural oil highlights,
						  matte response in shadowed areas.
						- Avoid idealization unless explicitly visible as a stylistic choice.

						8. HAIR & ACCESSORY ACCURACY
						- Describe hair color, texture, density, and styling exactly as observed.
						- Do NOT introduce blonde hair unless clearly present.
						- Describe accessories in terms of material, scale, and light response.

						9. ATMOSPHERE & STYLE (REALISTIC FANTASY · 2.5D)
						- Describe overall style as a blend of realism and refined stylization.
						- Comparable to premium editorial photography with cinematic fantasy polish.
						- Only describe atmospheric or special effects if visible:
						  soft mist, light particles, subtle energy motes,
						  drifting petals, faint luminous accents.
						- Effects must enhance depth and mood without distracting from the subject.

						10. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.

							
							
							FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }

                        // --- STYLE B: REV ANIMATED (SD 1.5 · Massive Painterly · Final) ---
							else if (styleMode === 'rev_animated') {
							  systemInstruction = `
							You are a Master Digital Concept Artist & Painter specializing in SD 1.5 RevAnimated-style illustration.

							Task:
							Convert the user’s prompt into a MASSIVE, richly descriptive DIGITAL PAINTING prompt
							that faithfully reflects the RevAnimated (SD 1.5) aesthetic.
							The output must be a SINGLE PARAGRAPH of approximately 500–600 words.
							Do NOT summarize. Do NOT invent narrative events not implied by the prompt.

							────────────────────────────────
							CRITICAL INSTRUCTIONS (EXECUTE FULLY)
							────────────────────────────────

							1. PRIME DIRECTIVE: REV ANIMATED PAINTERLY IDENTITY
							- The visual output MUST strongly resemble images generated by the SD 1.5 RevAnimated model.
							- The aesthetic must be painterly, anime-adjacent, and romanticized — not realistic, not photographic.
							- Explicitly AVOID photographic or render terminology:
							  "Photorealistic", "3D render", "camera noise", "film grain", "sharp photographic focus".
							- REQUIRED descriptors:
							  "Digital oil painting", "RevAnimated illustration",
							  "Anime-inspired painterly style", "Soft blended brushstrokes",
							  "Dreamy, romantic atmosphere".

							2. COMPOSITION & SCENE INTEGRITY (REV-CORRECT)
							- Describe a complete, intentional composition.
							- Always include:
							  subject posture, environment, and spatial context.
							- Favor:
							  "Wide cinematic composition",
							  "Full-scene framing",
							  "Balanced foreground, midground, and background".
							- Avoid floating or isolated heads; the subject must feel grounded within a painted environment.

							3. SUBJECT AESTHETIC (ROMANTIC IDEALISM · REV STYLE)
							- Describe the subject using anime-adjacent proportions:
							  idealized, harmonious, softly exaggerated, not physically strict.
							- Facial features should be refined and expressive.
							- Eyes must be large, luminous, emotionally resonant, and softly glowing.
							- Hair should be flowing and voluminous, painted with visible strand direction near the roots
							  and progressively softer blends toward the tips.

							4. SKIN RENDERING (REV ANIMATED ILLUSTRATION LOGIC)
							- Skin must follow illustrated anime-painter logic, not photographic realism.
							- Describe:
							  smooth tonal gradients,
							  soft airbrushed shading,
							  gentle highlight bloom,
							  painterly color transitions.
							- Avoid pore-level detail, sharp texture, or hyper-real skin realism.
							- Subsurface scattering should be described as an artistic glow, not physical simulation.

							5. COLOR SCIENCE & PALETTE CONTROL
							- Describe an intentional, harmonious color palette.
							- Favor warm, romantic tones balanced with cool accents.
							- Skin tones should blend naturally into the palette,
							  never gray, flat, or over-saturated.
							- Use color contrast and saturation subtly to draw focus toward the subject’s face.

							6. LIGHTING (REV ANIMATED GLOW-BASED)
							- Lighting must feel painterly, soft, and cinematic.
							- Use concepts such as:
							  "Soft directional light",
							  "Ambient glow",
							  "Painterly rim illumination",
							  "Gentle bloom around highlights".
							- Highlights should softly bleed into surrounding colors.
							- Avoid hard shadows, crisp edges, or photographic lighting behavior.

							7. MATERIAL & COSTUME RENDERING (PAINTERLY)
							- Describe clothing and accessories as painted materials.
							- Fabrics should show stylized folds, soft highlights, and smooth color variation.
							- Metals and jewelry should have painterly specular accents,
							  never mirror-like reflections.
							- Material rendering should enhance elegance without hyper-detail overload.

							8. BACKGROUND & ATMOSPHERE (REV WATERCOLOR FUSION)
							- Backgrounds must be abstracted, dreamy, and painterly.
							- Use elements such as:
							  watercolor washes,
							  soft gradients,
							  pastel floral or organic shapes,
							  floating light particles,
							  bokeh-like color blooms.
							- Background detail should dissolve progressively with depth.

							9. DEPTH, MOTION & VISUAL FLOW
							- Describe visual flow created by brush direction, lighting gradients, and color movement.
							- Suggest gentle motion through flowing hair, fabric, mist, or particles.
							- The composition should naturally guide the viewer’s eye across the scene.

							10. STYLE CONSISTENCY ENFORCEMENT
							- Every element must feel intentionally illustrated.
							- Do NOT mix photographic realism with painterly anime logic.
							- The entire description must maintain cohesive RevAnimated identity from start to end.
							
							11. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.

							────────────────────────────────
							OUTPUT FORMAT (STRICT)
							────────────────────────────────
							FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]
							`;
							}


                        // --- STYLE C: DIGITAL ART (Modern Comic / Graphic Novel) ---
                        else if (styleMode === 'digital') {
                            systemInstruction = `You are a Lead Comic Book & Graphic Novel Art Analyst
						specializing in modern digital comic illustration styles
						inspired by Marvel, DC, and Webtoon aesthetics.

						Task:
						Analyze the provided image and convert it into a richly detailed,
						VISION-SAFE COMIC BOOK ILLUSTRATION prompt.
						The output must be a SINGLE PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent elements not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: COMIC BOOK AESTHETIC TRANSLATION
						- The description must translate the observed image into a digital comic / graphic novel style.
						- The result must read as illustrated artwork, not photography or 3D rendering.
						- Explicitly AVOID:
						  "Photorealistic", "3D render", "flat vector", "corporate art", "minimalist".
						- REQUIRED descriptors:
						  "Digital comic illustration",
						  "Graphic novel art style",
						  "Inked linework",
						  "Cel-shaded coloring",
						  "High-quality stylized illustration".

						2. LINE WORK & INKING (OBSERVED STYLE)
						- Describe linework as clean, confident, and expressive.
						- Mention varying line weights to emphasize form, depth, and motion where visible.
						- Use inking techniques such as:
						  solid black shadows,
						  contour lines,
						  hatching or cross-hatching
						  if they are visually implied by the style.
						- Linework should enhance clarity and character definition, not clutter the image.

						3. COLOR & SHADING (COMIC LOGIC)
						- Describe colors as bold, punchy, and intentionally stylized.
						- Use cel shading logic with clear light and shadow separation.
						- Allow gradient fills where appropriate, especially for Webtoon-inspired looks.
						- Rim lighting and highlight accents may be used to enhance readability and drama.
						- Avoid photographic lighting behavior or soft realism.

						4. COMPOSITION & PANEL DYNAMICS
						- Describe the composition as cinematic and intentional.
						- Use terms such as:
						  "Dynamic panel composition",
						  "Hero-focused framing",
						  "Dramatic perspective",
						  "Action-oriented stance"
						  when visually present.
						- The subject should appear engaged and expressive, not stiff or static.
						- Composition must feel like a strong comic panel or splash page.

						5. SUBJECT & IDENTITY FIDELITY
						- Describe the subject’s facial features and body structure exactly as observed.
						- Preserve unique facial characteristics and natural asymmetry to avoid genericization.
						- Do NOT idealize, exaggerate, or alter proportions.
						- Identity fidelity should be achieved through accurate descriptive detail,
						  not through measurements or biometric language.

						6. SKIN & SURFACE RENDERING (ILLUSTRATED)
						- Describe skin using comic illustration logic.
						- Skin should appear smooth and stylized with controlled shading,
						  not pore-level realism.
						- Use clean tonal transitions and highlight placement to suggest form.
						- Avoid plastic, airbrushed, or overly glossy appearances unless stylistically visible.

						7. LIGHTING & ATMOSPHERE (GRAPHIC NOVEL STYLE)
						- Lighting should feel dramatic and illustrative.
						- Use:
						  strong directional light,
						  stylized shadows,
						  rim lighting,
						  atmospheric glow
						  if visible.
						- Lighting must enhance mood, depth, and narrative presence,
						  not mimic real-world photography.

						8. ENVIRONMENT & BACKGROUND
						- Describe the background as part of the illustrated scene.
						- Backgrounds may be simplified, stylized, or abstracted,
						  but must support the subject and composition.
						- Use comic-appropriate elements such as:
						  stylized cityscapes,
						  abstract shapes,
						  motion lines,
						  atmospheric effects
						  if present.
						- Background detail should not overpower the subject.

						9. TEXTURE & FINISH
						- Describe a clean digital finish with visible illustration texture.
						- Optional elements may include:
						  halftone patterns,
						  screentone textures,
						  speed lines
						  if they align with the visual style.
						- The final look should feel polished, expressive, and intentionally illustrated.

						10. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):**
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
						  
							FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }
                        // --- STYLE D: REALISTIC (Massive Raw Photo) ---
                        else if (styleMode === 'realistic') {
                            systemInstruction = `You are a Lead Visual Forensics Analyst and Realism-Oriented Visual Storyteller.

						Task:
						Perform a deep, observational scan of the provided image and output the result as a
						SINGLE, CONTINUOUS, HYPER-DESCRIPTIVE NARRATIVE PARAGRAPH suitable for realistic image generation.
						The final output MUST be written as flowing prose with no headers, no lists, and no formatting breaks.
						Flux/zimage requires uninterrupted narrative text.

						The description must remain strictly observational, describing only what is visibly present
						and how it appears under real-world physical conditions.

						────────────────────────────────
						INTERNAL ANALYSIS GUIDELINES
						(Use internally, but blend seamlessly into the narrative)
						────────────────────────────────

						IDENTITY & VISUAL ANCHOR:
						Begin immediately by establishing the subject’s apparent ethnicity, age range, and skin tone as visible.
						Describe facial structure organically within the narrative, noting eye shape, brow position, nose structure,
						jawline, and mouth without idealization or exaggeration.
						Include visible facial imperfections or asymmetries such as faint lines, under-eye shadows, or uneven features
						only if they are present in the image.

						BODY STRUCTURE & PHYSICAL PRESENCE:
						Describe the subject’s body structure exactly as observed, using neutral, physical language.
						Explain how posture, stance, and orientation contribute to the subject’s visual presence.
						Any prominence or mass should be described only as it appears, using cause-and-effect reasoning
						linked to posture, gravity, and garment construction, never enhancement or comparison.

						POSE, ORIENTATION & HANDS:
						Accurately describe the subject’s orientation relative to the camera, including angle, tilt, and stance.
						Describe the position of the arms and hands exactly as visible.
						Do NOT invent gestures or hand placement.
						Pose description must feel grounded, natural, and physically plausible.

						CLOTHING & MATERIAL RESPONSE:
						Identify the specific garments worn and describe their material, structure, and fit as observed.
						Explain how fabric responds to gravity, movement, and underlying form in realistic terms.
						Describe folds, tension, drape, and layering without implying exposure or alteration.
						Include visible accessories, jewelry, patterns, or textures only if present.

						SKIN SURFACE & MICRO DETAIL:
						Describe skin as real, unprocessed human tissue.
						Include visible characteristics such as natural texture, tonal variation, subtle sheen, fine hair,
						creases from posture, or environmental effects if visible.
						Avoid fetishistic focus; all skin detail should serve realism, not emphasis.

						LIGHTING, ENVIRONMENT & IMAGE QUALITY:
						Describe the lighting source and quality as observed, including direction, softness, and shadow behavior.
						Explain how light reveals form, depth, and surface detail without dramatization.
						Describe the surrounding environment briefly, focusing on how it frames or contextualizes the subject.
						If image quality characteristics are visible (resolution, grain, lens behavior), describe them neutrally.

						TECHNICAL REALISM:
						If apparent, reference realistic capture qualities such as depth of field, perspective compression,
						and natural optical behavior without over-specification.
						Avoid fictional camera metadata unless it is visually implied.
                        - **TECH:** "Unprocessed, grainy, 8k raw photo, Fujifilm GFX 100S."
				        MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }
                        
                    // ====================================================
                    //  STYLE 5: LEXICA (STYLIZED 3D PORTRAIT / IDEALIZED CGI)
                    // ====================================================
                    else if (styleMode === 'lexica') {
                        promptText = `You are a Stylized AI Portrait Aesthetic Analyst specializing in the visual style commonly
						seen in Lexica.art galleries and prompt-curated AI portrait collections.

						Task:
						Analyze the provided image and translate it into a highly polished,
						STYLIZED 3D PORTRAIT description that matches Lexica.art aesthetics.
						The output must be a SINGLE, FLOWING PARAGRAPH of approximately 400–500 words.
						Do NOT summarize. Do NOT invent features not visible in the image.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. CORE AESTHETIC: LEXICA-STYLE STYLIZED REALISM
						- The result must look intentionally AI-rendered and digitally perfected,
						  not photographed, not painterly, and not physically strict.
						- The overall appearance should feel clean, smooth, idealized,
						  and visually optimized for prompt-based image generation.
						- Avoid cinematic grit, painterly texture, or real-world imperfections.

						2. IDENTITY PRESERVATION WITH SOFT IDEALIZATION
						- Preserve the subject’s identity, facial structure, and proportions as observed.
						- Describe idealization as subtle smoothing and refinement,
						  not reshaping or exaggeration.
						- Facial features should remain recognizable,
						  with a slight symmetry bias typical of Lexica-style portraits.

						3. SKIN AS SYNTHETIC SURFACE (LEXICA LOOK)
						- Describe skin as digitally smooth and evenly toned.
						- Use language such as:
						  soft synthetic sheen,
						  clean surface gradients,
						  gentle subsurface scattering glow,
						  uniform coloration.
						- Do NOT describe pores, blemishes, scars, grain, or texture noise.
						- The skin should appear pristine and intentionally artificial.

						4. LIGHTING: SOFT, NEUTRAL, AND UNIFORM
						- Lighting must feel globally diffused and non-directional.
						- Use:
						  soft ambient illumination,
						  gentle highlight bloom,
						  shallow shadow depth.
						- Avoid dramatic contrast, harsh shadows, or cinematic chiaroscuro.
						- The subject should appear evenly lit, calm, and visually clear.

						5. MATERIALS & DETAIL SIMPLIFICATION
						- Describe clothing and accessories as clean, simplified luxury materials.
						- Fabrics should appear smooth and softly reflective,
						  without fiber detail or surface wear.
						- Jewelry and metallic elements should appear polished and pristine,
						  with simplified reflections.
						- Hair should be neatly styled and softly volumized,
						  with smooth strand flow and minimal flyaways.

						6. COMPOSITION & FRAMING (LEXICA STANDARD)
						- Favor centered, balanced portrait composition.
						- Typically describe:
						  bust-length or head-and-shoulders framing,
						  relaxed posture,
						  neutral or softly expressive facial expression.
						- Depth of field should be shallow but subtle,
						  with a softly blurred, non-distracting background.

						7. RENDER QUALITY (IMPLICIT, NOT TECHNICAL)
						- Convey high-resolution clarity and clean rendering
						  without naming specific engines or render software.
						- Avoid heavy technical jargon.
						- The final image should feel “prompt-perfect”,
						  polished, and ready for gallery presentation.

						8. STYLE CONSISTENCY
						- Every element must reinforce the Lexica.art aesthetic:
						  clean, idealized, calm, and synthetic.
						- Do NOT mix painterly, photographic, cinematic, or gritty realism styles.
						- The result must clearly read as a Lexica-style AI portrait.
						
						9. MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                    }
                        
                        // --- STYLE F: LEONARDO (Massive Artistic) ---
                        else if (styleMode === 'leonardo') {
                            systemInstruction = `You are a Digital Rendering & Visual Analysis Specialist
							trained to describe images in the distinctive visual style
							produced by the Phoenix family of models on leonardo.ai.

							Task:
							Analyze the provided image and translate it into a
							SINGLE, CONTINUOUS, HYPER-DESCRIPTIVE NARRATIVE PARAGRAPH
							that aligns precisely with Phoenix-style outputs.
							No headers, no lists, no formatting breaks in the final output.

							────────────────────────────────
							CRITICAL INSTRUCTIONS (EXECUTE FULLY)
							────────────────────────────────

							1. PRIME DIRECTIVE: PHOENIX VISUAL IDENTITY
							- The description must reflect Phoenix-style stylized digital realism.
							- The output must feel digitally constructed, not photographed and not painterly.
							- Avoid historical art language, brush metaphors, or canvas references.
							- Avoid cinematic or film-based terminology.

							2. IDENTITY & FACIAL STRUCTURE (OBSERVATIONAL)
							- Begin by describing the subject’s face as visibly observed.
							- Describe eye shape, brow placement, nose structure, jawline, lips,
							  and natural asymmetries without correction or idealization.
							- Maintain facial identity fidelity through descriptive accuracy,
							  not biometric measurements or cloning language.

							3. SKIN SURFACE (DIGITAL MATERIAL LOGIC)
							- Describe skin as a smooth digital surface rather than biological tissue.
							- Use Phoenix-appropriate language:
							  even tonal gradients,
							  soft surface transitions,
							  controlled subsurface glow,
							  clean, uniform coloration.
							- Avoid pores, blemishes, grain, noise, or macro realism.
							- Skin should feel refined and synthetic, but not plastic or waxy.

							4. BODY PRESENCE & POSTURE
							- Describe body structure and physical presence exactly as observed.
							- Explain form using posture, perspective, and lighting interaction.
							- Do not exaggerate, reduce, or enhance any features.
							- Presence should feel balanced and constructed, not staged or emphasized.

							5. CLOTHING & MATERIAL RESPONSE
							- Identify garments exactly as seen.
							- Describe fabrics in terms of digital material qualities:
							  soft sheen,
							  smooth folds,
							  controlled highlights,
							  subtle reflectivity.
							- Avoid painterly or tactile metaphors.
							- Describe how clothing follows form naturally without strain or emphasis.

							6. HAIR & GROOMING (STYLIZED CGI)
							- Describe hair as digitally groomed with organized strand groups.
							- Emphasize smooth flow, controlled volume, and soft edge transitions.
							- Avoid painterly brushstroke language or photographic flyaway detail.

							7. LIGHTING (CONSTRUCTED DIGITAL ILLUMINATION)
							- Describe lighting as intentionally designed rather than naturally occurring.
							- Use language such as:
							  soft diffuse illumination,
							  balanced ambient light,
							  gentle shadow falloff,
							  subtle glow shaping form.
							- Avoid dramatic contrast, hard shadows, or chiaroscuro.

							8. COMPOSITION & SPATIAL DESIGN
							- Describe composition as centered, stable, and intentionally framed.
							- Favor portrait-style balance and calm presentation.
							- Depth should feel digitally created rather than optically captured.
							- Backgrounds should be simplified, softly blurred, or atmospheric.

							9. COLOR & TONAL HARMONY
							- Describe colors as clean, harmonious, and controlled.
							- Avoid extreme saturation or gritty contrast.
							- Skin tones, clothing, and background should integrate smoothly
							  within a unified palette.

							10. STYLE CONSISTENCY ENFORCEMENT
							- Every part of the description must reinforce Phoenix-style digital realism.
							- Do NOT mix painterly, comic, Lexica, or photorealistic language.
							- The final paragraph should read like a polished digital rendering brief,
							  optimized for Phoenix-family model interpretation.
							  
							11. MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }
                        
                        // --- STYLE G: SEAART (Massive Commercial) ---
                        else if (styleMode === 'seaart') {
                            systemInstruction = `You are a Senior Visual Description Engineer specializing in the
						SeaArt.ai Infinity model’s cinematic hyper-realistic output style.

						Task:
						Analyze the provided image and translate it into a SINGLE, CONTINUOUS,
						NATURAL-LANGUAGE DESCRIPTION optimized for SeaArt Infinity.
						The final output must be a flowing paragraph of approximately 500–600 words.
						Do NOT use headers, lists, formatting markers, or technical scaffolding in the output text.

						────────────────────────────────
						CRITICAL INSTRUCTIONS (EXECUTE FULLY)
						────────────────────────────────

						1. PRIME DIRECTIVE: INFINITY REALISM IDENTITY ANCHOR
						- The opening sentence must immediately establish the subject’s face as observed.
						- Begin naturally by describing face shape, eye structure, gaze, expression, and facial balance.
						- Identity must be preserved through descriptive accuracy, not enhancement or alteration.
						- Avoid biometric measurements or cloning terminology.

						2. FACIAL DETAIL & EXPRESSION (OBSERVATIONAL)
						- Describe facial features exactly as visible:
						  eye spacing, brow shape, nose structure, lip contour, jawline presence.
						- Include subtle asymmetries and micro-expressions only if present.
						- Expression should feel natural, candid, and human, not posed or exaggerated.

						3. SKIN FIDELITY (INFINITY-STYLE REALISM)
						- Describe skin as highly realistic and tactile without exaggeration.
						- Use Infinity-appropriate realism:
						  visible pores at close range,
						  natural micro-texture,
						  subtle tonal variation,
						  soft specular highlights from natural skin oils.
						- Avoid plastic, waxy, or airbrushed appearance.
						- Do not fetishize or isolate skin regions.

						4. BODY STRUCTURE & PHYSICAL PRESENCE
						- Describe the subject’s body structure exactly as observed in the image.
						- Any sense of prominence, curvature, or mass must be explained through
						  posture, perspective, garment fit, and lighting — never enhancement.
						- Avoid comparative language or size enforcement.
						- The subject should feel physically grounded and proportionally coherent.

						5. POSE, GESTURE & KINETICS
						- Describe the subject’s posture, orientation, and movement as visible.
						- Hands, arms, shoulders, and stance must be described accurately.
						- The pose should feel naturally captured, not staged or sculpted.
						- If motion is present, describe it subtly and realistically.

						6. CLOTHING & MATERIAL BEHAVIOR
						- Identify garments exactly as seen.
						- Describe fabric type, weight, and texture using realistic material language.
						- Explain how clothing drapes, folds, or contours due to gravity and motion.
						- Avoid language implying strain, exposure, or intentional emphasis.

						7. LIGHTING (SEAART INFINITY SIGNATURE)
						- Lighting should feel cinematic yet realistic.
						- Use language such as:
						  balanced studio or environmental light,
						  controlled highlights,
						  soft but defined shadow transitions.
						- Avoid harsh spotlighting or extreme contrast unless clearly visible.
						- Lighting should enhance clarity, depth, and realism.

						8. COLOR & TONAL CONTROL
						- Describe color as rich, natural, and harmonized.
						- Skin tones should feel believable and integrated into the scene.
						- Avoid oversaturation or artificial color extremes.

						9. DEPTH, FOCUS & IMAGE QUALITY
						- Describe realistic depth of field and spatial separation if visible.
						- The subject should appear sharply resolved against a softly receding background.
						- Avoid explicit camera metadata unless visually implied.
						- The image should feel high-resolution, clean, and professionally captured.

						10. ENVIRONMENT & CONTEXT
						- Briefly describe the environment only as it supports the subject.
						- Backgrounds should feel realistic, unobtrusive, and contextually appropriate.
						- Avoid clutter or narrative invention.

						11. STYLE CONSISTENCY (NON-NEGOTIABLE)
						- The entire description must remain cinematic, realistic, and human.
						- Do NOT introduce CGI, painting, anime, comic, or stylized rendering language.
						- Do NOT exaggerate anatomy or modify identity.
                        
                        12. **ATMOSPHERIC & PARTICLE EFFECTS (VFX LAYER):**
                            - **PARTICLE DENSITY:** If the image has atmosphere, describe "Floating dust motes," "Glowing embers," "Pollen spores," or "Rain droplets."
                            - **VOLUMETRICS:** Describe "God Rays," "Haze," "Fog density," or "Bloom."
                            - **OPTICAL DEPTH:** Mention "Bokeh," "Depth of Field," and "Lens Flares" if present.
                            - **MAGIC/CHAOS:** If the scene is fantasy, describe the "Swirling energy," "Neon sparks," or "Magical aura."
							
						13.MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE AND APPENDED TO OTHER NEGATIVES REQUIRED):
										   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
										   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender."
										   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
										   - **ARTIFICIALITY:** "Cartoon, anime, 3d render, plastic, doll, drawing, painting, illustration, fake, airbrushed."
										   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.
                        
                        FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }
                        
                        // --- STYLE H: PIXAR (Massive Disney) ---
                        else if (styleMode === 'pixar') {
                            systemInstruction = `You are a Lead Character Artist (Pixar / Disney Animation).
                            Task: Rewrite this prompt into a MASSIVE 500-WORD "3D ANIMATED FEATURE FILM" CHARACTER.
                            
                            CRITICAL INSTRUCTIONS:

                            1. **STYLE:** "Pixar Animation Style," "Disney Princess Aesthetic," "Unreal Engine 5 Stylized," "CGSociety 3D."
                            
                            2. **PROPORTIONS:** "Big Expressive Eyes," "Cute Button Nose," "Soft Round Face," "Stylized Anatomy," "Small Hands/Feet."
                            
                            3. **SURFACE MATERIAL:**
                            - Skin: "Plastic-like Smoothness," "Subsurface Scattering (Wax/Gummy)," "Soft Internal Glow."
                            - No "Pores," "Wrinkles," or "Realism."
                            
                            4. **LIGHTING:** "Soft Studio Lighting," "Warm Rim Light," "Bounce Light," "Bright and Happy Atmosphere."
							FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negatives]`;
                        }
							// ====================================================
							//  STYLE: UNIVERSAL STYLE CLONER (Visual Reverse Engineering)
							// ====================================================
						else if (styleMode === 'style_clone') {
                        systemInstruction = `Analyze this image and output a detailed Stable Diffusion prompt.
							Focus MAINLY on: Main Subject and the Image setting, Subject gender and body type in detail as it is in the image exactly, Hair style and placement, Limbs position and placement, Clothing and Attire, Action of the subject, Lighting, Camera Angle and Shot, and Art/Photo Style set in a mix between a photo and fantasy, not totally a real photo also not total anime, a mix somewhere bove 2.5D, with a magical and fantasy setting and adding random particle effects (eg. Falling rain drops, falling snow flakes, electric arcs, plasma vortex, dust motes, raging flames, floating rose petals etc.).
							
							CRITICAL INSTRUCTIONS (EXECUTE FULLY):

							1. **PRIME DIRECTIVE: PRESERVE IDENTITY & ELEVATE ATTIRE**
							- You MUST retain the specific Subject, Gender, and Attire exactly as defined. Do not genericize.
							- Elevate the description to high standards. If the user says "Saree," describe "translucent chiffon," "delicate lace borders," or "intricate chikankari."

							2. **SARTORIAL SCULPTING (THE "FIT" BYPASS):**
							- AI models often default to baggy clothing. You must correct this by describing the **architectural fit**.
							- Use safe, high-fashion vocabulary: "Bespoke tailoring," "Second-skin fit," "Anatomically defined silhouette," "Sculpted bodice."
							- State that the fabric "clings to the natural curvature of the form" and "accentuates the silhouette with precision."

							3. **FABRIC PHYSICS (LOW GSM & LIQUIDITY):**
							- **NO DENSE FABRICS:** Explicitly ban "High GSM," "Thick," "Stiff," or "Heavy" materials. The fabric must be "Ultra-lightweight," "Breathable," and "Gauzy."
							- Use phrases like: **"Sheer liquid silk," "Translucent georgette," "Paper-thin cotton," "Molten satin."**
							- Describe the fabric as having a "lightweight, fluid drape" that reacts to the slightest movement.

							4. **SKIN FIDELITY (EXTREME MACRO REALISM):**
							- **UNFILTERED RAW TEXTURE:** The skin MUST look "obsessively detailed" and "uncomfortably real." Demand visible "stretching pores," "micro-surface texture," "vellus hair," and "natural unevenness."
							- **MANDATORY IMPERFECTIONS:** Describe "faint acne scars," "freckles," "fine wrinkles," "hyper-pigmentation," and "sunspots."
							- **LIVING TISSUE:** Skin must exhibit "subsurface scattering" and "natural oil speculars."

							5. **NO BLONDE HAIR:** Unless explicitly mentioned, no blonde hair.

							6. **LENS & CAMERA METADATA:**
							- Force the AI to use: "85mm f/1.2 Prime Lens," "ISO 400," "Shutter Speed 1/250."
							- Describe optical artifacts: "Chromatic Aberration," "Film Grain," "Vignette," "Lens Flare."

							7. **LIGHTING (DRAMATIC):**
							- "Rembrandt Lighting," "Chiaroscuro," "Hard Flash," "Volumetric God-Rays," "High Dynamic Range (HDR)."
							- Shadows must be "Deep" and "Detailed."

                            8. **SPECIAL STYLE REFERENCE: ReV ANIMATED (Check if Source matches this)**
                            - **2.5D Aesthetic:** Look for a "2.5D" look—not quite flat 2D anime, but not fully photorealistic either. It has a polished, "rendered" quality often seen in high-end mobile game art or concept art.
                            - **Vibrant & Contrast-Heavy:** Check for punchy colors, dramatic lighting (volumetric fog, glowing effects), and high contrast.
                            - **Fantasy & Sci-Fi Bias:** Note any fantasy armor, magic effects, glowing runes, and futuristic cyberpunk aesthetics.
                            - **"Porcelain" Skin:** If the subject has very smooth, idealized skin (sometimes too smooth/plastic), explicitly describe it as "ReV Animated Style, semi-realistic, idealized skin texture."

							9. **MANDATORY NEGATIVE EMBEDDING (NON-NEGOTIABLE):**
							   - To prevent the model from "averaging down" the subject's physique or reducing image quality, you MUST append the following tokens to the Negative Prompt.
							   - **PHYSIQUE & VOLUME PRESERVATION:** "Flat chest, small bust, medium breasts, diminished assets, flattened, compressed, modest, concealing, covered, hiding, unappealing, ambiguous gender, hidden cleavage, covered cleavage, hidden navel, covered navel, breasts smaller than size 36D, less cleavage, less than 4K resolution."
							   - **QUALITY & FIDELITY:** "Bad anatomy, worst quality, low quality, blur, motion blur, haze, noise, grain, distortion, jpeg artifacts, pixelated, lowres, oversaturated, underexposed."
							   - **ARTIFICIALITY:** "Cartoon, anime, plastic, doll, drawing."
							   - **INSTRUCTION:** Ensure the negative prompt actively fights against "safety filtering" that alters the subject's natural body type found in the image.

							Limit to 400 words. Full sentences, no unnecessary filler.

							FORMAT: [500-600 Word Single Paragraph] |NEGATIVE| [Negative Prompt Here with other style specific negatives and negatives required to clone the provided image]`;
						}
					}

                    let fullText = "";

                    // --- EXECUTE GENERATION ---
                    if (provider === 'GEMINI') {
                        const modelId = document.getElementById('text-model-select')?.value || "gemini-2.0-flash-exp";
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${geminiKey}`, { 
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ contents: [{ parts: [{ text: `${systemInstruction}\n\nUser Input: ${rawPrompt}` }] }] }) 
                        });
                        const data = await response.json();
                        if(!response.ok) throw new Error("Gemini API Error: " + (data.error?.message || response.statusText));
                        fullText = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
                    } 
                    else {
                        const modelId = document.getElementById('cf-text-model')?.value || "@cf/meta/llama-3-8b-instruct";
                        const WORKER_URL = "https://pb-vision-proxy.nswlko.workers.dev/"; 
                        const payload = { accountId: cfAccount, apiToken: cfToken, model: modelId, messages: [ { role: "system", content: systemInstruction }, { role: "user", content: `Input: ${rawPrompt}` } ] };
                        const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        const textData = await response.text();
                        try {
                            const data = JSON.parse(textData);
                            if (!response.ok) throw new Error(data.error || data.errors?.[0]?.message || "Proxy Error");
                            fullText = data.result?.response || "";
                        } catch(e) { throw new Error(`CF Proxy Error: ${textData.substring(0, 80)}`); }
                    }

                    if(fullText) { 
                        let cleanText = fullText.replace(/^(\*\*|#)?(Here is|The prompt|Enhanced|Output|Sure|Certainly)(\*\*|#|:|,).{0,50}(\*\*|#|:)?\s*/i, "").trim();
                        const parts = cleanText.split('|NEGATIVE|');
                        let enhancedPositive = parts[0].trim();
                        let enhancedNegative = parts.length > 1 ? parts[1].trim() : "";

                        // AUTO-SUFFIX BASED ON STYLE
                        if (isScenery) {
                            enhancedPositive += ", (8k wallpaper), (unreal engine 5), (highly detailed environment), (cinematic lighting)";
                        } else {
                            if (styleMode === 'frontal') enhancedPositive += ", (8k raw photo), (Fujifilm GFX 100S), (hyperrealistic skin:1.4), (visible pores)";
                            if (styleMode === 'rev_animated') enhancedPositive += ", (digital painting), (watercolor fusion), (soft brushstrokes), (artstation style)";
                            if (styleMode === 'digital') enhancedPositive += ", (vector art), (flat color), (clean lines), (minimalist)";
                            if (styleMode === 'lexica') enhancedPositive += ", (unreal engine 5), (octane render), (3d style)";
                            if (styleMode === 'realistic') enhancedPositive += ", (8k raw photo), (hyperrealistic), (fujifilm gfx)";
                            if (styleMode === 'pixar') enhancedPositive += ", (pixar style), (disney style), (3d render), (cute)";
                            if (styleMode === 'seaart') enhancedPositive += ", (seaart infinity style), (flux.1 dev), (vibrant)";
                            if (styleMode === 'leonardo') enhancedPositive += ", (digital painting), (artistic style), (illustration)";
							if (styleMode === 'style_clone') enhancedPositive += ", (digital clone), (artistic style), (illustration), (Extreme clarity)";
                        }

                        const outBox = document.getElementById('output-text'); 
                        outBox.value = enhancedPositive; 
                        autoResize(outBox); 
                        
                        const negBox = document.getElementById('negative-prompt');
                        if (negBox) {
                            let baseNegatives = "";
                            if (styleMode === 'frontal' || styleMode === 'realistic') baseNegatives = "cartoon, anime, 3d render, plastic skin, airbrushed, blur, sketch";
                            if (styleMode === 'rev_animated') baseNegatives = "photorealistic, grain, noise, photography, 3d render";
                            if (styleMode === 'digital') baseNegatives = "photorealistic, grain, noise, shading, 3d, blurred";
                            
                            let combinedNegatives = (enhancedNegative + ", " + baseNegatives).replace(/,\s*,/g, ',').trim();
                            if(combinedNegatives) negBox.value = combinedNegatives;
                        }
                        
                        addToHistory(enhancedPositive, `FIX_${isScenery ? 'SCENERY' : styleMode.toUpperCase()}`); 
                        showToast(`${isScenery ? 'SCENERY' : styleMode.toUpperCase()} Fixed!`, "success");
                        
                        if(retryBtn) {
                            retryBtn.classList.remove('hidden');
                            retryBtn.className = "col-span-2 h-12 rounded-xl bg-white/5 hover:bg-white/10 border border-white/10 backdrop-blur-md transition-all flex items-center justify-center gap-2 text-[10px] font-bold text-gray-400 hover:text-white shadow-lg group";
                        }
                        outBox.dispatchEvent(new Event('input'));
                    } else { throw new Error("Empty Response from AI."); }

                } catch (e) { 
                    console.error(e); showToast("Fix Failed: " + e.message, "error"); 
                } finally { 
                    btn.disabled = false; 
                    btn.innerHTML = `
                        <svg class="w-4 h-4 text-purple-400 group-hover:text-white animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        MAGIC FIX
                    `;
                    updateAppStatus('idle'); 

                    if(retryBtn && !retryBtn.classList.contains('hidden')) {
                        btn.className = "col-span-2 " + baseClass;
                    } else {
                        btn.className = "col-span-4 " + baseClass;
                    }
                }
            });
            
            // 11. LIGHTBOX: ZOOM, DRAG & IMMERSIVE LOGIC (Final)
            const lbImg = document.getElementById('lb-image'); 
            const lbOverlay = document.getElementById('lightbox-overlay');
            
            if (lbImg && lbOverlay) {
                let state = { scale: 1, pX: 0, pY: 0, sX: 0, sY: 0, isDragging: false };
                let lastTap = 0; 
                let singleTapTimer = null; 

                // 1. POINTER DOWN
                lbImg.onpointerdown = (e) => { 
                    e.preventDefault(); 
                    // Stop the auto-hide timer if user touches screen (so controls don't vanish while dragging)
                    if(lbControlsTimer) clearTimeout(lbControlsTimer);

                    state.sX = e.clientX - state.pX; 
                    state.sY = e.clientY - state.pY; 
                    state.startX = e.clientX; 
                    state.startY = e.clientY; 
                    state.isDragging = true; 
                    lbImg.setPointerCapture(e.pointerId); 
                    if (state.scale > 1) lbImg.classList.add('dragging'); 
                };

                // 2. POINTER MOVE
                lbImg.onpointermove = (e) => { 
                    if (!state.isDragging || state.scale === 1) return; 
                    e.preventDefault(); 
                    state.pX = e.clientX - state.sX; 
                    state.pY = e.clientY - state.sY; 
                    requestAnimationFrame(() => { 
                        lbImg.style.transform = `scale(${state.scale}) translate(${state.pX / state.scale}px, ${state.pY / state.scale}px)`; 
                    }); 
                };

               // 3. POINTER UP (Single Tap = Multi-Step Zoom to 4x, Double Tap = Toggle UI)
                lbImg.onpointerup = (e) => {
                    state.isDragging = false; 
                    lbImg.classList.remove('dragging'); 
                    lbImg.releasePointerCapture(e.pointerId);
                    
                    const dist = Math.hypot(e.clientX - state.startX, e.clientY - state.startY);
                    
                    // IF IT WAS A TAP (Movement < 5px)
                    if (dist < 5) {
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTap;
                        
                        if (tapLength < 300 && tapLength > 0) {
                            // === DOUBLE TAP (TOGGLE UI) ===
                            e.preventDefault();
                            if(singleTapTimer) clearTimeout(singleTapTimer); 

                            const areControlsHidden = document.getElementById('lb-close-btn').classList.contains('opacity-0');
                            toggleLightboxControls(areControlsHidden); 
                            
                            if(areControlsHidden) {
                                if(lbControlsTimer) clearTimeout(lbControlsTimer);
                                lbControlsTimer = setTimeout(() => toggleLightboxControls(false), 3000);
                            }
                            lastTap = 0; 
                        } else {
                            // === SINGLE TAP (ZOOM CYCLE: 1 -> 2 -> 3 -> 4 -> 1) ===
                            if(singleTapTimer) clearTimeout(singleTapTimer);
                            
                            singleTapTimer = setTimeout(() => {
                                e.preventDefault();
                                
                                // FORCE IMMERSIVE MODE ON ANY ZOOM ACTION
                                toggleLightboxControls(false);

                                if (state.scale === 1) {
                                    // Step 1: 2.0x (Standard Zoom)
                                    const rect = lbImg.getBoundingClientRect(); 
                                    const tapX = e.clientX - rect.left; 
                                    const tapY = e.clientY - rect.top;
                                    lbImg.style.transformOrigin = `${tapX}px ${tapY}px`; 
                                    lbImg.style.transform = "scale(2)"; 
                                    state.scale = 2; 
                                    state.pX = 0; state.pY = 0; 
                                    lbImg.style.cursor = 'grab';
                                } 
                                else if (state.scale === 2) {
                                    // Step 2: 3.0x (High Detail)
                                    lbImg.style.transform = "scale(3)"; 
                                    state.scale = 3; 
                                    state.pX = 0; state.pY = 0;
                                }
                                else if (state.scale === 3) {
                                    // Step 3: 4.0x (Extreme Detail)
                                    lbImg.style.transform = "scale(4)"; 
                                    state.scale = 4; 
                                    state.pX = 0; state.pY = 0;
                                }
                                else {
                                    // Step 4: Reset to 1.0x
                                    lbImg.style.transformOrigin = 'center'; 
                                    lbImg.style.transform = "scale(1) translate(0,0)"; 
                                    state.scale = 1; state.pX = 0; state.pY = 0; 
                                    lbImg.style.cursor = 'zoom-in';
                                    
                                    // Bring UI back ONLY on reset
                                    toggleLightboxControls(true); 
                                    
                                    if(lbControlsTimer) clearTimeout(lbControlsTimer);
                                    lbControlsTimer = setTimeout(() => toggleLightboxControls(false), 3000);
                                }
                            }, 300); 
                        }
                        lastTap = currentTime;
                    }
                };

                // 4. CLOSE BACKGROUND
                lbOverlay.addEventListener('click', (e) => { 
                    if (e.target === lbOverlay) { 
                        closeLightbox(); // Uses the new helper to restore UI
                    } 
                });
            }

            // 12. File & DB Actions
            safeListen('add-file-btn', 'click', () => document.getElementById('file-input').click());
            safeListen('file-input', 'change', async (e) => {
                const files = Array.from(e.target.files); if(files.length === 0) return;
                const currentRaw = localStorage.getItem(DATA_KEY); let masterData = currentRaw ? JSON.parse(currentRaw) : {};
                let loadedFiles = JSON.parse(localStorage.getItem(FILE_KEY) || "[]"); let addedCount = 0;
                for (const file of files) {
                    try { const text = await readFile(file); let fileData = {}; 
                        try { fileData = JSON.parse(text); } catch (err) { window.customData = {}; eval(text); if(window.customData) fileData = window.customData; }
                        if (Object.keys(fileData).length > 0) {
                            for(const [key, items] of Object.entries(fileData)) { if(Array.isArray(items)) { if(!masterData[key]) masterData[key] = []; masterData[key] = masterData[key].concat(items); } }
                            loadedFiles.push(file.name); addedCount++;
                        }
                    } catch(err) { console.error(err); }
                }
                if (addedCount > 0) { localStorage.setItem(DATA_KEY, JSON.stringify(masterData)); localStorage.setItem(FILE_KEY, JSON.stringify(loadedFiles)); applyDataToGlobals(masterData); updateFileListUI(loadedFiles); }
                e.target.value = ''; 
            });
			// Add this with your other listeners
				safeListen('reset-puter-btn', 'click', () => {
					if(confirm("Log out of Puter and wipe saved token?")) {
						// 1. Remove specific token
						localStorage.removeItem('puter.auth.token');
						
						// 2. Try official sign out if loaded
						if (typeof puter !== 'undefined' && puter.auth) {
							try { puter.auth.signOut(); } catch(e) {}
						}
						
						showToast("Puter Reset! Reloading...", "success");
						setTimeout(() => window.location.reload(), 1000);
					}
				});
            safeListen('wipe-db-btn', 'click', () => { if(confirm("Delete all saved lists?")) { localStorage.removeItem(DATA_KEY); localStorage.removeItem(FILE_KEY); location.reload(); } });
            safeListen('done-btn', 'click', () => { safeClass('db-screen', 'add', 'hidden'); safeClass('setup-screen', 'remove', 'hidden'); safeClass('action-bar', 'add', 'hidden'); });
            safeListen('manage-db-btn', 'click', () => { safeClass('app-screen', 'add', 'hidden'); safeClass('setup-screen', 'add', 'hidden'); safeClass('db-screen', 'remove', 'hidden'); });
            safeListen('history-btn', 'click', () => { safeClass('app-screen', 'add', 'hidden'); safeClass('setup-screen', 'add', 'hidden'); safeClass('history-screen', 'remove', 'hidden'); renderHistory(); });
            safeListen('close-hist-btn', 'click', () => { safeClass('history-screen', 'add', 'hidden'); safeClass('app-screen', 'remove', 'hidden'); safeClass('action-bar', 'remove', 'hidden'); });
            safeListen('wipe-hist-btn', 'click', () => { if(confirm("Clear history?")) { localStorage.removeItem(HIST_KEY); renderHistory(); } });

            document.querySelectorAll('.config-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const type = e.currentTarget.dataset.type; const value = e.currentTarget.dataset.value;
                    if(type === 'nsfw') { state.nsfw = (value === 'true'); setTheme(state.nsfw); } if(type === 'mode') state.mode = value; if(type === 'subject') state.subject = value;
                    updateConfigButtons(); savePrefs();
                });
            });

            safeListen('start-btn', 'click', () => { 
                // 1. Force Screen State (CRITICAL FIX FOR BLANK PAGE)
                const appScreen = document.getElementById('app-screen');
                const setupScreen = document.getElementById('setup-screen');
                const actionBar = document.getElementById('action-bar');

                if (setupScreen) {
                    setupScreen.classList.add('hidden');
                    setupScreen.style.display = 'none'; // Force hide inline style
                }
                
                if (appScreen) {
                    appScreen.classList.remove('hidden');
                    appScreen.style.display = 'block'; // Force show inline style (Fixes blank page)
                }

                if (actionBar) {
                    actionBar.classList.remove('hidden');
                    actionBar.style.display = 'flex'; // Force flex layout
                }

                // 2. Ensure Container is Ready
                const container = document.getElementById('manual-container');
                if (container) {
                    container.innerHTML = ''; // Clean slate
                    container.classList.remove('hidden'); // Force visibility
                }

                // 3. Build UI
                try {
                    buildUI(); 
                } catch(e) {
                    console.error("UI Build Failed:", e);
                    showToast("Error loading UI. Resetting...", "error");
                    // Auto-recover if UI crashes
                    state.mode = 'manual';
                    setTimeout(buildUI, 100);
                }
                
                // 4. Output Check
                const outBox = document.getElementById('output-text');
                if(outBox) {
                    // Retain text if exists, or set placeholder
                    if(!outBox.value) outBox.placeholder = "Prompt will appear here...";
                    outBox.dispatchEvent(new Event('input')); 
                }
            });
           // FIX: Use switchTab to correctly reset display:none styles
            safeListen('back-btn', 'click', () => { switchTab('config'); });

            // =========================================================================
            // 13. GENERATOR BUTTON (PROMPT BUILDER ONLY - NO EXECUTION)
            // =========================================================================
            safeListen('generate-btn', 'click', async () => {
                dismissKeyboard(); 
                const lists = getActiveLists(); 
                const uniqueSet = new Set();
                const isRandom = state.mode === 'random';
                
                // Helper: Dice Roll for Random Mode (Manual always returns true)
                const chance = (threshold) => !isRandom || Math.random() < threshold;

                // Helper to get value
                const getVal = (id, list) => {
                    let val = "";
                    if(isRandom) { 
                        if(list && list.length > 1) { 
                            const filtered = list.filter(i => i !== "-None-" && i !== "-Finish-" && i !== "-NSFW_SEPARATOR-"); 
                            if(filtered.length > 0) val = filtered[Math.floor(Math.random() * filtered.length)]; 
                        } 
                    } 
                    else { 
                        const el = document.getElementById(id); 
                        if(el && el.value !== "-None-" && el.value !== "-Finish-" && el.value !== "-NSFW_SEPARATOR-") val = el.value; 
                        
                        const custom = document.getElementById(id+"_custom"); 
                        if(custom && custom.value.trim()) val += (val ? " " : "") + custom.value.trim(); 
                    }
                    
                    if(val && uniqueSet.has(val.toLowerCase())) return ""; 
                    if(val) uniqueSet.add(val.toLowerCase()); 
                    return val;
                };

                let finalPrompt = "";

                // --- SCENERY MODE ---
                if(state.subject === 'scenery') {
                    // Scenery usually benefits from full details, so we keep high probabilities
                    let type = getVal("type", subjectTypeList); 
                    let bg = getVal("bg", backgrounds); 
                    let light = chance(0.8) ? getVal("light", lightingList) : ""; 
                    let style = chance(0.7) ? getVal("style", styleList) : ""; 
                    let quality = getVal("quality", qualityList);
                    
                    let techStack = []; 
                    if(chance(0.6)) {
                            const shot = getVal("shot", shotList); if(shot) techStack.push(shot);
                            const lens = getVal("lens", cameraLensList); if(lens) techStack.push(lens);
                            const fx = getVal("fx", lists.activeEffectList); if(fx) techStack.push(fx);
                    }
                    
                    let parts = [];
                    if(type) parts.push(type);
                    if(bg) parts.push(bg);
                    if(light) parts.push(light);
                    if(techStack.length > 0) parts.push(techStack.join(", "));
                    if(style) parts.push(style);
                    if(quality) parts.push(quality);
                    
                    finalPrompt = parts.join(", ");
                } 
                // --- CHARACTER MODE ---
                else {
                    // 1. IDENTITY & LOOKALIKE
                    let identityParts = [];
                    let lora = !isRandom ? getVal("lora", null) : "";
                    let type = getVal("type", subjectTypeList);
                    let sub = getVal("subject", lists.activeSubjectList);
                    let gen = getVal("gender", lists.activeGenderList);
                    
                    // [FIX] Only allow Lookalike if NOT male
                    let look = "";
                    if (state.subject !== 'male') {
                        look = chance(0.4) ? getVal("lookalike", lists.activeLookalikeList) : "";
                    }

                    if(lora) identityParts.push(lora);
                    
                    let mainSubject = "";
                    if(type) mainSubject += type + " ";
                    if(sub) mainSubject += sub;
                    if(gen) mainSubject += (sub ? ", " : "") + gen;
                    if(look) mainSubject += ` looking like (${look})`; // Only adds if 'look' exists
                    
                    if(mainSubject) identityParts.push(mainSubject);

                    // 2. PHYSICALITY
                    let bodyParts = [];
                    let body = chance(0.9) ? getVal("body", lists.activeBodyTypeList) : "";
                    let pelvis = chance(0.5) ? getVal("pelvis", lists.activePelvisList) : "";
                    let face = chance(0.7) ? getVal("face", (typeof faceTypeList !== 'undefined' ? faceTypeList : [])) : "";
                    let eyes = chance(0.6) ? getVal("eyes", (typeof eyeColorList !== 'undefined' ? eyeColorList : [])) : "";
                    let hair = chance(0.8) ? getVal("hair", lists.activeHairStyleList) : "";
                    
                    if(body) bodyParts.push(body);
                    if(pelvis) bodyParts.push(pelvis);
                    
                    // ANATOMY LOGIC (Females Only)
                    if(state.subject !== 'male') {
                        
                        // 1. BREASTS (Allowed in SFW Mode using the Safe List)
                        let breasts = chance(0.8) ? getVal("breasts", lists.activeBreastList) : "";
                        if(breasts) bodyParts.push(breasts);

                        // 2. EXPLICIT DETAILS (Strictly NSFW Mode Only)
                        if (state.nsfw) {
                            let nipples = chance(0.5) ? getVal("nipples", lists.activeNippleList) : "";
                            let nShape = chance(0.5) ? getVal("nippleShape", lists.activeNippleShapeList) : "";
                            let vagina = chance(0.5) ? getVal("vagina", lists.activeVaginaList) : "";
                            let vShape = chance(0.5) ? getVal("vaginaShape", lists.activeVaginaShapeList) : "";

                            if(nipples) bodyParts.push(`${nipples} ${nShape || ""}`.trim());
                            if(vagina) bodyParts.push(`${vagina} ${vShape || ""}`.trim());
                        }
                    }

                    if(face) bodyParts.push(face);
                    if(eyes) bodyParts.push(eyes);
                    if(hair) bodyParts.push(hair);

                    // 3. ATTIRE
                    let attireParts = [];
                    if(chance(0.5)) { 
                        let upper = getVal("upper", lists.activeUpperBodyList);
                        let lower = getVal("lower", lists.activeLowerBodyList);
                        let feet = getVal("feet", lists.activeFootwearList);

                        let items = [];
                        if(upper) items.push(upper);
                        if(lower) items.push(lower);
                        if(feet) items.push(feet);
                        if(items.length > 0) attireParts.push("wearing " + items.join(", "));
                    }

                    // [FIX] JEWELRY: Only run if NOT male
                    if(state.subject !== 'male' && chance(0.4)) {
                        let jewelParts = [];
                        let jHead = getVal("jewel_head", lists.activeHeadJewelry);
                        let jEar = getVal("jewel_ear", lists.activeEarJewelry);
                        let jNeck = getVal("jewel_neck", lists.activeNeckJewellery);
                        let jArm = getVal("jewel_arm", lists.activeArmJewellery);
                        let jHand = getVal("jewel_hand", lists.activeHandJewellery);

                        if(jHead) jewelParts.push(jHead);
                        if(jEar) jewelParts.push(jEar);
                        if(jNeck) jewelParts.push(jNeck);
                        if(jArm) jewelParts.push(jArm);
                        if(jHand) jewelParts.push(jHand);
                        
                        if(jewelParts.length > 0) attireParts.push("adorned with " + jewelParts.join(", "));
                    }

                    // 4. ACTION & CONTEXT
                    let actionParts = [];
                    if(chance(0.7)) {
                        let act = getVal("activity", lists.activeActivityList);
                        let hands = getVal("hands", (typeof handPositionList !== 'undefined' ? handPositionList : []));
                        let exp = getVal("expression", lists.activeExpressionList);
                        
                        // [FIX] POSE: Only run if NOT male
                        let pos = "";
                        if (state.subject !== 'male') {
                            pos = getVal("pos", (typeof subjectPositionList !== 'undefined' ? subjectPositionList : []));
                        }
                        
                        if(pos) actionParts.push(pos);
                        if(act) actionParts.push(act);
                        if(hands) actionParts.push(hands);
                        if(exp) actionParts.push(exp);
                    }
                    
                    // Background & Light
                    let bg = chance(0.8) ? getVal("bg", backgrounds) : "";
                    let light = chance(0.7) ? getVal("light", lightingList) : "";

                    if(bg) actionParts.push("background: " + bg);
                    if(light) actionParts.push("lighting: " + light);

                    // 5. TECHNICAL
                    let techParts = [];
                    if(chance(0.6)) {
                        let shot = getVal("shot", (typeof shotList !== 'undefined' ? shotList : []));
                        let lens = getVal("lens", (typeof cameraLensList !== 'undefined' ? cameraLensList : []));
                        let style = getVal("style", (typeof styleList !== 'undefined' ? styleList : []));
                        let fx = getVal("fx", lists.activeEffectList);
                        let qual = getVal("quality", (typeof qualityList !== 'undefined' ? qualityList : []));

                        if(shot) techParts.push(shot);
                        if(lens) techParts.push(lens);
                        if(style) techParts.push(style);
                        if(fx) techParts.push(fx);
                        if(qual) techParts.push(qual);
                    }

                    // --- ASSEMBLE ---
                    let paragraphs = [];
                    if(identityParts.length > 0) paragraphs.push(identityParts.join(", "));
                    if(bodyParts.length > 0) paragraphs.push(bodyParts.join(", "));
                    if(attireParts.length > 0) paragraphs.push(attireParts.join(", "));
                    if(actionParts.length > 0) paragraphs.push(actionParts.join(", "));
                    if(techParts.length > 0) paragraphs.push(techParts.join(", "));

                    finalPrompt = paragraphs.join(". ");
                }

                // --- 1. UPDATE TEXT BOX ---
                let outputStr = cleanAndFormat(finalPrompt); 
                updateOutput(outputStr); 
                
                // --- 2. NOTIFY USER (DO NOT GENERATE) ---
                showToast("Prompt Generated! Click 'VISUALIZE' to render.", "success");
            });
            
            // ==========================================
            //  14. VISUALIZE BUTTON (FINAL: SMART & LOGGED)
            // ==========================================
            safeListen('visualize-btn', 'click', async () => {
                dismissKeyboard(); 
                
                // --- 1. CAPTURE INPUT IMAGE (For Img2Img & Gallery) ---
                let inputImageB64 = null;
                const pasteArea = document.getElementById('paste-preview-area');
                const pasteImg = document.getElementById('paste-preview-img');
                
                if (pasteArea && !pasteArea.classList.contains('hidden') && pasteImg.src) {
                    try {
                        const inpResp = await fetch(pasteImg.src);
                        const inpBlob = await inpResp.blob();
                        inputImageB64 = await blobToBase64(inpBlob);
                        console.log("Visualizer: Input image captured for generation.");
                    } catch(e) { console.warn("Failed to capture input image:", e); }
                }

                const btn = document.getElementById('visualize-btn');
                let rawPrompt = document.getElementById('output-text').value;
                
                // Basic validation
                if(!rawPrompt || rawPrompt === "No prompt generated.") {
                     showToast("Please generate a prompt first.", "error");
                     return;
                }
                
                const originalText = btn.innerHTML; 
                const originalClasses = btn.className;
                
                // UI: "Working" State
                btn.disabled = true; 
                btn.className = originalClasses
                    .replace('from-indigo-600', 'from-yellow-600')
                    .replace('to-purple-600', 'to-orange-600')
                    .replace('hover:shadow-theme-500/60', '') 
                    + " animate-pulse cursor-wait border-t border-white/20";
                
                btn.innerHTML = `WORKING...`;
                
                const neg = getActiveNegativePrompt();
                const arSelect = document.getElementById('ar'); 
                const arValue = arSelect ? arSelect.value : "1:1";
                
                // Toggle visibility states
                safeClass('random-message', 'add', 'hidden'); 
                safeClass('visualizer-container', 'remove', 'hidden'); 
                safeClass('img-loading', 'remove', 'hidden'); 
                safeClass('generated-image', 'add', 'hidden'); 
                safeClass('img-actions', 'add', 'hidden');
                
                let serviceName = state.generator.toUpperCase(); 
                updateAppStatus('busy', `GENERATING (${serviceName})...`);
                
                let generatorResult = null; 
                let persistentImgUrl = null; 
                let blobForDisplay = null; 
                let tempBlobUrl = null;
                
                try {
                    // --- GENERATOR SELECTION ---
                    if (state.generator === 'gemini') {
                        generatorResult = await generateGemini(rawPrompt, arValue); 
                    }
                    else if (state.generator === 'cloudflare') {
                        generatorResult = await generateCloudflare(rawPrompt, arValue);
                    }
                    else if (state.generator === 'huggingface') {
                        generatorResult = await generateHuggingFace(rawPrompt, arValue);
                    }
                    else if (state.generator === 'freepik') {
                        generatorResult = await generateFreepik(rawPrompt, neg, arValue);
                    }	
					else if (state.generator === 'horde') {
							generatorResult = await generateHorde(rawPrompt, arValue);
						}
                    else if (state.generator === 'puter') {
                        // Puter Auth Check
                        if (!puter.auth.isSignedIn()) {
                            showToast("Connecting to Puter...", "info");
                            await puter.auth.signIn(); 
                        }
                        generatorResult = await PuterManager.generate(rawPrompt, arValue);
                    } 
                    else {
                        // --- POLLINATIONS (DEFAULT) ---
                        if(inputImageB64) showToast("Generating with Img2Img...", "info");
                        generatorResult = await generatePollination(rawPrompt, arValue, null, inputImageB64);
                    }

                    // --- RESULT HANDLING ---
                    if (!generatorResult) throw new Error("No image data returned.");
                    
                    if (typeof generatorResult === 'string' && generatorResult.startsWith('data:')) { 
                        persistentImgUrl = generatorResult; 
                        blobForDisplay = base64ToBlob(generatorResult, 'image/jpeg'); 
                    } 
                    else if (generatorResult instanceof Blob) { 
                        blobForDisplay = generatorResult; 
                        persistentImgUrl = await blobToBase64(generatorResult); 
                    } 
                    else { throw new Error("Invalid data type."); }

                    tempBlobUrl = URL.createObjectURL(blobForDisplay);
                    const imgTag = document.getElementById('generated-image');
                    imgTag.onload = null; imgTag.onerror = null; imgTag.src = tempBlobUrl;
                    
                    // Lightbox Listener
                    imgTag.onclick = () => {
                        openLightbox(persistentImgUrl, rawPrompt, serviceName);
                        if (typeof NavManager !== 'undefined') {
                            NavManager.bindLightboxButtons(persistentImgUrl, rawPrompt);
                        }
                    };

                    imgTag.onload = () => { 
                        safeClass('img-loading', 'add', 'hidden'); 
                        safeClass('generated-image', 'remove', 'hidden'); 
                        safeClass('img-actions', 'remove', 'hidden'); 
                        
                        // --- FORMATTED SERVICE NAME LOGIC ---
                        const provMap = {
                            'pollination': 'POLLI', 'gemini': 'GEMINI',
                            'cloudflare': 'C.FLARE', 'puter': 'PUTER',
                            'huggingface': 'H.FACE', 'freepik': 'FREEPIK'
                        };
                        let partProvider = provMap[state.generator] || state.generator.toUpperCase();

                        let partModel = "STD"; 
                        if (state.generator === 'pollination') {
                            partModel = (document.getElementById('poll-model-select')?.value || 'flux').toUpperCase();
                        } else if (state.generator === 'gemini') {
                            const m = document.getElementById('model-select')?.value || '';
                            partModel = m.includes('flash') ? 'FLASH' : 'PRO';
                        } else if (state.generator === 'cloudflare') {
                            const val = document.getElementById('cf-model-select')?.value || '';
                            const parts = val.split('/');
                            partModel = (parts[parts.length - 1] || 'SDXL').toUpperCase().replace(/-/g, ' ');
                        } else if (state.generator === 'freepik') {
                            partModel = (document.getElementById('freepik-model-select')?.value || 'FLUX').toUpperCase();
                        } else if (state.generator === 'puter') {
                            // --- NEW: Handle Puter Models ---
                            const val = document.getElementById('puter-model')?.value || '';
                            const parts = val.split('/');
                            // Extract just the model name (e.g. "FLUX.1-pro" from "black-forest-labs/FLUX.1-pro")
                            partModel = (parts[parts.length - 1] || 'FLUX').toUpperCase();
                        }

                        let partStyle = "";
                        if (typeof pasteImg !== 'undefined' && pasteImg && pasteImg.dataset.styleName) {
                            partStyle = pasteImg.dataset.styleName.replace(/[\u{1F600}-\u{1F6FF}]/gu, '').trim();
                        }

                        let finalServiceName = `${partProvider} > ${partModel}`;
                        if (partStyle) finalServiceName += ` > ${partStyle}`;

                        // SAVE TO GALLERY
                        if (typeof GalleryManager !== 'undefined') {
                            GalleryManager.saveImage(persistentImgUrl, rawPrompt, finalServiceName, inputImageB64, neg);
                        }
                        
                        if (typeof addToHistory === 'function') {
                            addToHistory(rawPrompt, finalServiceName); 
                        }
                        
                        updateAppStatus('idle'); 
                        btn.className = originalClasses; 
                        btn.innerHTML = originalText; 
                        btn.disabled = false; 
                        URL.revokeObjectURL(tempBlobUrl); 
                    };

                    imgTag.onerror = () => { 
                        safeClass('img-loading', 'add', 'hidden'); 
                        showToast("Image Load Failed", "error"); 
                        btn.className = originalClasses; btn.innerHTML = originalText; btn.disabled = false; 
                        if (tempBlobUrl) URL.revokeObjectURL(tempBlobUrl); 
                    };
                } catch (e) { 
                    showToast("Gen Failed: " + e.message, "error"); 
                    updateAppStatus('error'); 
                    safeClass('img-loading', 'add', 'hidden'); 
                    safeClass('visualizer-container', 'add', 'hidden'); 
                    setTimeout(() => updateAppStatus('idle'), 3000); 
                    btn.className = originalClasses; btn.innerHTML = originalText; btn.disabled = false; 
                    if (tempBlobUrl) URL.revokeObjectURL(tempBlobUrl); 
                }
            });
            // Setup Screen Gallery Listeners
			safeListen('setup-view-gallery-btn', 'click', async () => { await GalleryManager.loadGallery(); startSlideshow(0); });
			safeListen('setup-clear-gallery-btn', 'click', () => GalleryManager.clearAll());
            safeListen('copy-btn', 'click', () => { const el = document.getElementById('output-text'); if(el && el.value) { el.select(); navigator.clipboard.writeText(el.value).then(() => showToast("COPIED")); } else { showToast("NOTHING TO COPY", "error"); } });
            safeListen('lb-close-btn', 'click', () => { closeLightbox(); });

            const textInputs = ['api-key-input', 'cf-account-id', 'cf-api-token', 'cf-steps', 'cf-guidance', 'cf-seed', 'poll-seed', 'poll-api-key', 'poll-worker-url', 'negative-prompt', 'horde-api-key', 'horde-steps', 'horde-cfg'];
            // FIND THIS LINE and ADD 'scan-style-final'
			const changeInputs = ['model-select', 'text-model-select', 'scan-model-select', 'cf-model-select', 'poll-model-select', 'poll-enhance', 'poll-nologo', 'poll-safe', 'cf-text-model', 'cf-vision-model', 'puter-model', 'scan-style-final', 'horde-model-select'];
            textInputs.forEach(id => { const el = document.getElementById(id); if (el) el.addEventListener('input', savePrefs); });
            changeInputs.forEach(id => { const el = document.getElementById(id); if (el) el.addEventListener('change', savePrefs); });

            const speedSlider = document.getElementById('slide-speed');
            if (speedSlider) { speedSlider.addEventListener('input', (e) => { document.documentElement.style.setProperty('--slide-speed', e.target.value + 's'); }); }

            initSystem().then(() => {
                checkVizVisibility(); // Initial Check
            }).catch(err => console.error("Initialization failed:", err));
        });
        
        window.addEventListener('popstate', (event) => {
            // ============================
            // 1. MODAL CLOSING CHECK (Priority #1 - MOVED UP)
            // ============================
            // We check this FIRST so closing an image doesn't trigger the "Exit Setup?" warning.
            const lb = document.getElementById('lightbox-overlay');
            const ss = document.getElementById('slideshow-screen');
            const cat = document.getElementById('cat-overlay');

            // Lightbox Open? Close UI.
            if (lb && !lb.classList.contains('hidden')) {
                closeLightboxUI();
                return; // Stop. Do not switch tabs or check exit guard.
            }

            // Slideshow Open? Close UI.
            if (ss && !ss.classList.contains('hidden')) {
                if(typeof stopSlideshow === 'function') stopSlideshow(false); // false = don't go back again
                return;
            }
            
            // Catalogue Overlay Open? Close UI.
            if (cat && !cat.classList.contains('hidden')) {
                safeClass('cat-overlay', 'add', 'hidden');
                safeClass('app-header', 'remove', 'hidden');
                if (document.exitFullscreen) document.exitFullscreen().catch(e=>{});
                return;
            }

            // ============================
            // 2. EXIT GUARD CHECK (Priority #2)
            // ============================
            if (ExitGuard.isSetupOpen()) {
                // User tried to go BACK while on Setup.
                const confirmExit = confirm("Exit Setup? Unsaved changes may be lost.");
                
                if (!confirmExit) {
                    // User CANCELLED: We must undo the navigation.
                    // We push the 'setup' state back onto the stack to stay here.
                    history.pushState({ view: 'setup' }, document.title);
                    return; // Stop everything. UI does not change.
                }
                // User OK'd: Allow fall-through to normal navigation below.
            }

            // ============================
            // 3. NORMAL NAVIGATION (Priority #3)
            // ============================
            // If we get here, it's a real page change.
            const view = (event.state && event.state.view) ? event.state.view : 'home';
            
            // We call the visual switch logic directly here.
            switchTab(view); 
        });

        // --- NAV MANAGER (Fixed Badge Update) ---
			const NavManager = {
					state: { type: 'home', index: 0, items: [] },

					// 1. OPEN CATALOGUE (From Grid)
					openCatalogue(index) {
						if (!GalleryManager.catalogueCache) return;
						const { manifest } = GalleryManager.catalogueCache;
						this.state = { type: 'catalogue', index: index, items: manifest };
						GalleryManager.loadAndShowAtIndex(index);
					},

					// 2. OPEN GALLERY (From Grid) - THIS IS THE FIX
					// 2. OPEN GALLERY (From Grid) - FIXED
					openGallery(index) {
						// Ensure we have items to show
						if (!slideshowItems || !slideshowItems.length || !slideshowItems[index]) {
							console.warn("No gallery items found at index", index);
							return;
						}

						// Save state for browsing (Next/Prev buttons)
						this.state = { type: 'gallery', index: index, items: slideshowItems };
						
						const item = slideshowItems[index];
						
						// A. Convert Main Image Blob -> URL
						const upscaledUrl = URL.createObjectURL(item.blob);
						
						// B. Convert Original Image Blob -> URL (THE MISSING LINK)
						// If this exists in the DB (from a restore), we MUST create a URL for it
						// so the Lightbox knows to show the "Compare" button.
						let originalUrl = null;
						if (item.originalBlob) {
							originalUrl = URL.createObjectURL(item.originalBlob);
						}

						// ========================================================
						// ✅ THE FIX: MANUALLY INJECT FLAGS INTO ITEM OBJECT
						// The Lightbox UI checks 'item.compareEnabled', not just the arg.
						// We must explicitly set these properties on the object.
						// ========================================================
						item.originalImageUrl = originalUrl;
						item.compareEnabled = !!originalUrl; // Forces button to appear if URL exists
						// ========================================================

						// C. Pass EVERYTHING to Lightbox
						// Arg 1: Main Image
						// Arg 2: Prompt
						// Arg 3: Provider
						// Arg 4: Original Image URL (Triggers Compare Button)
						// Arg 5: Negative Prompt
						// Arg 6: Full Item Object (For Metadata HUD & Compare Logic)
						openLightbox(
							upscaledUrl, 
							item.prompt, 
							item.provider, 
							originalUrl, 
							item.negativePrompt, 
							item // Now contains the required 'compareEnabled' flag!
						);
						
						// D. Bind Next/Prev Buttons
						this.bindLightboxButtons(upscaledUrl, item.prompt);
					},

					// 3. BIND BUTTONS (Next/Prev Logic)
					bindLightboxButtons(currentUrl, currentPrompt) {
						const nextBtn = document.getElementById('lb-next');
						const prevBtn = document.getElementById('lb-prev');
						
						if (nextBtn) {
							nextBtn.onclick = (e) => {
								e.stopPropagation();
								this.navigate(1);
							};
						}
						
						if (prevBtn) {
							prevBtn.onclick = (e) => {
								e.stopPropagation();
								this.navigate(-1);
							};
						}
					},

					// 4. NAVIGATION LOGIC
					navigate(direction) {
						const newIndex = this.state.index + direction;
						
						// Boundary Checks
						if (newIndex < 0 || newIndex >= this.state.items.length) {
							// Optional: Loop around
							// newIndex = (newIndex < 0) ? this.state.items.length - 1 : 0;
							return; // Or just stop
						}

						// Determine if we are in Catalogue or Gallery mode
						if (this.state.type === 'catalogue') {
							GalleryManager.loadAndShowAtIndex(newIndex);
							this.state.index = newIndex;
						} 
						else if (this.state.type === 'gallery') {
							this.openGallery(newIndex); // Recursively call the fixed function
						}
					}
				};

					

        GalleryManager.loadAndShowAtIndex = async function(index) {
            if (!this.catalogueCache) return;
            const { zipData, manifest, rootPath } = this.catalogueCache; const item = manifest[index];
            const imgEl = document.getElementById('cat-img'); if(imgEl) imgEl.style.opacity = '0.5';
            try {
                const imgPath = rootPath + item.file; const imgFile = zipData.file(imgPath) || zipData.file(item.file);
                if (imgFile) {
                    const blob = await imgFile.async("blob"); const url = URL.createObjectURL(blob);
                    this.showCatalogueItem(url, item, blob); 
                    if(imgEl) setTimeout(() => imgEl.style.opacity = '1', 150);
                }
            } catch(e) { showToast("Error loading image", "error"); }
        };

        GalleryManager.renderCatalogueGrid = async function() {
            if (!this.catalogueCache) return;
            const { zipData, manifest, rootPath } = this.catalogueCache;
            const grid = document.getElementById('catalogue-grid'); grid.innerHTML = ''; const frag = document.createDocumentFragment();
            for (let i = 0; i < manifest.length; i++) {
                const item = manifest[i];
                const imgPath = rootPath + item.file; const imgFile = zipData.file(imgPath) || zipData.file(item.file);
                if (imgFile) {
                    const blob = await imgFile.async("blob"); const url = URL.createObjectURL(blob);
                    const div = document.createElement('div');
                    div.className = "relative aspect-square cursor-pointer group rounded-lg overflow-hidden bg-gray-800 border border-transparent hover:border-theme-400 transition-all";
                    div.innerHTML = `<img src="${url}" class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"><div class="absolute bottom-0 inset-x-0 bg-black/60 p-1 text-[8px] text-center font-bold text-gray-300 truncate">${item.provider || 'AI'}</div>`;
                    div.onclick = () => NavManager.openCatalogue(i);
                    frag.appendChild(div);
                }
            }
            grid.appendChild(frag);
        };
		// --- UNIFIED OVERLAY MANAGER (Distinct Modes) ---
            
            // 1. VIEW RAW (Read-Only Mode)
            safeListen('view-raw-btn', 'click', () => {
                if(!window.lastRawPrompt) { showToast("No saved prompt.", "error"); return; }
                
                const overlay = document.getElementById('retry-overlay');
                const area = document.getElementById('retry-text-input');
                const runBtn = document.getElementById('confirm-retry-btn');
                const title = overlay.querySelector('span'); // The Title Span
                
                if(area) {
                    area.value = window.lastRawPrompt;
                    area.readOnly = true; // Lock it
                    area.classList.add('opacity-50', 'cursor-default'); // Visual cue
                    area.classList.remove('focus:border-theme-500'); // Remove focus glow
                }
                
                if(runBtn) runBtn.classList.add('hidden'); // Hide the Run button
                if(title) title.innerText = "RAW PROMPT (READ ONLY)";
                
                safeClass('retry-overlay', 'remove', 'hidden');
            });

            // 2. RE-FIX (Edit Mode)
            safeListen('retry-fix-btn', 'click', () => {
                if(!window.lastRawPrompt) { showToast("No saved prompt.", "error"); return; }
                
                const overlay = document.getElementById('retry-overlay');
                const area = document.getElementById('retry-text-input');
                const runBtn = document.getElementById('confirm-retry-btn');
                const title = overlay.querySelector('span');
                
                if(area) {
                    area.value = window.lastRawPrompt;
                    area.readOnly = false; // Unlock it
                    area.classList.remove('opacity-50', 'cursor-default');
                    area.classList.add('focus:border-theme-500');
                }
                
                if(runBtn) runBtn.classList.remove('hidden'); // Show the Run button
                if(title) title.innerText = "EDIT & RETRY";
                
                safeClass('retry-overlay', 'remove', 'hidden');
            });

            // 3. CANCEL / CLOSE
            safeListen('cancel-retry-btn', 'click', () => {
                safeClass('retry-overlay', 'add', 'hidden');
            });

            // 4. CONFIRM RETRY (Run Logic)
            safeListen('confirm-retry-btn', 'click', () => {
                const textArea = document.getElementById('retry-text-input');
                const mainOut = document.getElementById('output-text');
                
                if(textArea && mainOut) {
                    mainOut.value = textArea.value; // Update main box
                    autoResize(mainOut);
                    safeClass('retry-overlay', 'add', 'hidden'); // Close
                    document.getElementById('enhance-btn').click(); // Trigger Magic Fix
                }
            });
			// --- PUTER MANAGER: Quota, Sync, Models, & Gen (FIXED v3) ---
					const PuterManager = {
						// 1. Check User & Quota (Run on Init)
						async checkStatus() {
							const bar = document.getElementById('puter-status-bar');
							const userLabel = document.getElementById('puter-username');
							const usageBox = document.getElementById('puter-usage-box');
							
							if (!bar || !userLabel) return;

							if (puter.auth.isSignedIn()) {
								try {
									// A. Basic User Info
									const user = await puter.auth.getUser();
									bar.classList.remove('hidden');
									userLabel.innerText = `USER: ${user.username.toUpperCase()}`;
									
									// B. Fetch Usage Data
									const usage = await puter.auth.getMonthlyUsage();
									PuterManager.renderUsage(usage);
									if(usageBox) usageBox.classList.remove('hidden');

								} catch (e) {
									console.warn("Puter Auth/Usage Check Failed", e);
								}
							} else {
								bar.classList.add('hidden');
								if(usageBox) usageBox.classList.add('hidden');
							}
						},

						// 2. Render Usage Statistics
						renderUsage(usage) {
							const detailsEl = document.getElementById('puter-usage-details');
							const totalEl = document.getElementById('puter-total-cost');
							if(!detailsEl || !totalEl) return;

							let totalMicroCents = 0;
							let html = '';

							// Helper: Convert microcents to USD ($1.00 = 100,000,000 microcents)
							const fmtMoney = (mc) => '$' + (mc / 100000000).toFixed(4);

							for (const [service, data] of Object.entries(usage)) {
								if(data && (data.cost > 0 || data.count > 0)) {
									totalMicroCents += (data.cost || 0);
									const label = service.replace(/_/g, ' ').toUpperCase();
									
									html += `
										<div class="flex justify-between items-center border-b border-gray-800/50 pb-0.5 mb-0.5 last:border-0">
											<span class="text-blue-300">${label}</span>
											<div class="flex gap-2">
												<span class="text-gray-500">${data.count || 0} calls</span>
												<span class="text-theme-400 font-bold">${fmtMoney(data.cost || 0)}</span>
											</div>
										</div>
									`;
								}
							}

							if(html === '') html = '<div class="text-center italic opacity-50 py-1">No usage data this month</div>';

							detailsEl.innerHTML = html;
							totalEl.innerText = fmtMoney(totalMicroCents);
						},

						// 3. Cloud History Sync
						async syncHistory() {
							if (!puter.auth.isSignedIn()) { await puter.auth.signIn(); }
							
							try {
								showToast("Syncing with Cloud...", "info");
								const localRaw = localStorage.getItem(HIST_KEY) || "[]";
								const localHist = JSON.parse(localRaw);
								let cloudHist = await puter.kv.get('prompt_history') || [];
								
								const merged = [...localHist];
								const existingTexts = new Set(localHist.map(i => i.text || i));
								
								cloudHist.forEach(item => {
									const txt = item.text || item;
									if (!existingTexts.has(txt)) {
										merged.push(item);
										existingTexts.add(txt);
									}
								});

								await puter.kv.set('prompt_history', merged);
								localStorage.setItem(HIST_KEY, JSON.stringify(merged));
								renderHistory();
								showToast("Cloud Sync Complete!", "success");
							} catch(e) {
								showToast("Sync Failed: " + e.message, "error");
							}
						},

						// 4. Text-to-Speech
						async readPrompt() {
							const text = document.getElementById('output-text').value;
							if(!text) return;
							showToast("Reading Prompt...", "info");
							try {
								const audio = await puter.ai.txt2speech(text, { model: 'eleven_turbo_v2_5' });
								audio.play();
							} catch(e) {
								console.error("Puter TTS Failed, using fallback", e);
								const u = new SpeechSynthesisUtterance(text);
								speechSynthesis.speak(u);
							}
						},

						// 5. Generator Adapter (FIXED v9: Hardcoded Flux Buckets)
						async generate(prompt, arValue) {
							console.group("🚀 PUTER MANAGER DEBUG (v9)");
							
							// 1. Auth Check
							if (!puter.auth.isSignedIn()) {
								await puter.auth.signIn({ attempt_temp_user_creation: true });
								this.checkStatus();
							}

							// 2. Get Model & Clean AR
							const modelSelect = document.getElementById('puter-model');
							const modelId = modelSelect ? modelSelect.value.trim() : 'black-forest-labs/FLUX.1-schnell';
							
							// Clean the AR string (e.g. "9:16 (Portrait)" -> "9:16")
							let cleanAR = arValue ? arValue.split(' ')[0].trim() : "1:1";
							
							// 3. FLUX/TOGETHER SPECIFIC RESOLUTIONS
							// These are the EXACT integer pairs Flux supports. 
							// We map the AR string to these numbers to avoid 500 errors or 1:1 defaults.
							const fluxBuckets = {
								"1:1":   [1024, 1024],
								"9:16":  [768, 1344], // Portrait
								"16:9":  [1344, 768], // Landscape
								"2:3":   [832, 1216],
								"3:2":   [1216, 832],
								"3:4":   [768, 1024],
								"4:3":   [1024, 768],
								"1:2":   [640, 1280],
								"2:1":   [1280, 640]
							};
							
							// Default to 1024 square if unknown
							const [w, h] = fluxBuckets[cleanAR] || [1024, 1024];

							console.log(`Target: ${modelId} | AR: ${cleanAR} | Sending: ${w}x${h}`);

							// 4. Construct Options
							let options = {
								model: modelId,
								prompt: prompt,
								disable_safety_checker: true,
							};

							// 5. Provider Logic
							const isGemini = modelId.includes('gemini') || modelId.includes('flash');
							const isOpenAI = modelId.includes('gpt') || modelId.includes('dall-e');

							if (isGemini) {
								console.warn("Gemini detected: Forces 1:1.");
								options.ratio = { w: 1024, h: 1024 }; 
							} 
							else if (isOpenAI) {
								options.size = `${w}x${h}`; // OpenAI likes string "WxH"
								options.quality = "standard";
							} 
							else {
								// FLUX / TOGETHER AI
								// We send explicit integers. This forces the resolution.
								options.width = w;
								options.height = h;
								
								// We ALSO send the aspect_ratio string as a fallback hint
								options.aspect_ratio = cleanAR;

								// Handle Negative Prompt
								const neg = getActiveNegativePrompt();
								if (neg) options.negative_prompt = neg;
							}

							updateAppStatus('busy', `PUTER GEN (${cleanAR})...`);

							try {
								const result = await puter.ai.txt2img(prompt, options);
								
								if (result && result.src) {
									console.log("✅ Image URL received");
									setTimeout(() => this.checkStatus(), 2000);
									console.groupEnd();
									return result.src;
								} else if (typeof result === 'string') {
									console.groupEnd();
									return result;
								}
								
								throw new Error("No image data returned from Puter.");

							} catch (e) {
								console.error("❌ Puter Failure:", e);
								console.groupEnd();
								updateAppStatus('error', 'Gen Failed');
								if(e.message && e.message.includes('400')) {
									localStorage.removeItem('puter.auth.token');
									alert("Session Expired. Please retry.");
								}
								throw e;
							}
						},
					};

					// Auto-run Status Check on Load
					document.addEventListener('DOMContentLoaded', () => {
						setTimeout(PuterManager.checkStatus, 1500);
					});
						
						// ==========================================
        // 18. GALLERY COLLAPSE MANAGER
        // ==========================================
        const GalleryToggle = {
            init() {
                // Load saved states (Default to 'collapsed' if no save found)
                // We check !== 'open' so that null/undefined defaults to true (collapsed)
                const mainCollapsed = localStorage.getItem('pb_gal_state_main') !== 'open';
                const setupCollapsed = localStorage.getItem('pb_gal_state_setup') !== 'open';
                
                this.apply('main', mainCollapsed);
                this.apply('setup', setupCollapsed);
            },
            
            toggle(id) {
                const content = document.getElementById(`gal-content-${id}`);
                if (!content) return;
                
                // If currently hidden, we are opening it.
                const isHidden = content.classList.contains('hidden');
                const newStateCollapsed = !isHidden; // If visible, we want to collapse
                
                this.apply(id, newStateCollapsed);
                
                // Save State
                localStorage.setItem(`pb_gal_state_${id}`, newStateCollapsed ? 'collapsed' : 'open');
            },
            
            apply(id, isCollapsed) {
                const content = document.getElementById(`gal-content-${id}`);
                const chevron = document.getElementById(`gal-chevron-${id}`);
                if(!content || !chevron) return;
                
                if (isCollapsed) {
                    content.classList.add('hidden');
                    chevron.classList.add('-rotate-90');
                } else {
                    content.classList.remove('hidden');
                    chevron.classList.remove('-rotate-90');
                }
            }
        };

		// ==========================================
        // 19. DEEP HARVESTER + RAW DATA EXPORT
        // ==========================================
        async function extractPNGMetadata(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const buffer = event.target.result;
                        const view = new DataView(buffer);
                        let chunks = {};
                        
                        // 1. EXTRACT ALL CHUNKS
                        if (view.getUint32(0) === 0x89504E47) { 
                            let offset = 8;
                            while (offset < view.byteLength) {
                                if (offset + 8 > view.byteLength) break;
                                const length = view.getUint32(offset);
                                let type = "";
                                for(let i=0; i<4; i++) type += String.fromCharCode(view.getUint8(offset+4+i));

                                if (type === 'tEXt' || type === 'iTXt' || type === 'zTXt') {
                                    try {
                                        const body = new Uint8Array(buffer, offset + 8, length);
                                        let key = "", val = "";
                                        let nullIdx = body.indexOf(0);
                                        
                                        if (nullIdx > -1) {
                                            key = new TextDecoder().decode(body.slice(0, nullIdx));
                                            
                                            if (type === 'tEXt') {
                                                val = new TextDecoder().decode(body.slice(nullIdx + 1));
                                            } else if (type === 'iTXt') {
                                                let ptr = nullIdx + 3; 
                                                while(ptr < body.length && body[ptr] !== 0) ptr++; ptr++; 
                                                while(ptr < body.length && body[ptr] !== 0) ptr++; ptr++; 
                                                val = new TextDecoder().decode(body.slice(ptr));
                                            } else if (type === 'zTXt') {
                                                try {
                                                    const compressed = body.slice(nullIdx + 2);
                                                    const ds = new DecompressionStream("deflate");
                                                    const blob = new Blob([compressed]);
                                                    const stream = blob.stream().pipeThrough(ds);
                                                    val = await new Response(stream).text();
                                                } catch(e) { console.warn("Decompress failed", e); }
                                            }
                                            if (key && val) chunks[key] = val;
                                        }
                                    } catch(e) { console.warn("Chunk Parse Error", e); }
                                }
                                offset += 12 + length;
                            }
                        }

                        // 2. PARSE LOGIC (With Raw Export)
                        
                        // A. A1111 Parameters
                        if (chunks["parameters"]) {
                            const res = parseA1111(chunks["parameters"]);
                            if (res) { 
                                res.source = "A1111 / CivitAI"; 
                                res.raw = chunks["parameters"]; // Export Raw
                                resolve(res); return; 
                            }
                        }
                        
                        // B. ComfyUI JSON
                        const comfyKey = chunks["prompt"] || chunks["workflow"];
                        if (comfyKey) {
                            const res = parseComfyDeep(comfyKey);
                            if (res) { 
                                res.source = "ComfyUI (Graph)"; 
                                res.raw = comfyKey; // Export Raw JSON
                                resolve(res); return; 
                            }
                        }

                        // C. Raw Scan (Fallback)
                        const rawText = new TextDecoder("utf-8", {fatal: false}).decode(new Uint8Array(buffer));
                        const match = rawText.match(/parameters\x00([^\x00]*)/);
                        if (match && match[1].length > 10) {
                            const res = parseA1111(match[1]);
                            if (res) { 
                                res.source = "Raw Scan (A1111)"; 
                                res.raw = match[1];
                                resolve(res); return; 
                            }
                        }

                        resolve({ error: "No recognizable metadata found." });

                    } catch (e) {
                        resolve({ error: "File Error: " + e.message });
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }
		// --- MAGIC PASTE: Import images from Clipboard (Ctrl+V) ---
				document.addEventListener('paste', (e) => {
					// 1. Get Clipboard Items
					const items = (e.clipboardData || e.originalEvent.clipboardData).items;
					
					for (const item of items) {
						if (item.type.indexOf('image') !== -1) {
							e.preventDefault();
							
							// 2. Extract Blob
							const blob = item.getAsFile();
							const url = URL.createObjectURL(blob);
							
							// 3. Display Image Immediately
							const img = document.getElementById('generated-image');
							if(img) {
								img.src = url;
								img.classList.remove('hidden');
								
								// Hide placeholders if they exist
								const placeholder = document.getElementById('placeholder-text');
								if(placeholder) placeholder.classList.add('hidden');
							}

							// 4. Update Status
							if(typeof updateAppStatus === 'function') {
								updateAppStatus('ready', 'IMPORTED FROM CLIPBOARD');
							}
							if(typeof showToast === 'function') {
								showToast("Image pasted successfully!", "success");
							}
							
							// 5. Optional: Add to History logic here if you have it
							// if(typeof addToHistory === 'function') addToHistory(url, "Imported Image");
							
							return; // Stop after finding the first image
						}
					}
				});

			// ==========================================
            //  IMG 2 IMG BUTTON (Load -> Scan -> Stop)
            // ==========================================
            safeListen('img2img-btn', 'click', async () => {
                dismissKeyboard();
                const btn = document.getElementById('img2img-btn');
                const fileInput = document.getElementById('img2img-upload');
                
                let inputImageB64 = null;
                let isNewImage = false;

                // 1. CHECK EXISTING PREVIEW
                const pasteArea = document.getElementById('paste-preview-area');
                const pasteImg = document.getElementById('paste-preview-img');

                if (pasteArea && !pasteArea.classList.contains('hidden') && pasteImg.src) {
                    try {
                        const inpResp = await fetch(pasteImg.src);
                        const inpBlob = await inpResp.blob();
                        inputImageB64 = await blobToBase64(inpBlob);
                    } catch(e) {}
                }

                // 2. CHECK CLIPBOARD IF EMPTY
                if (!inputImageB64) {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        for (const item of clipboardItems) {
                            const type = item.types.find(t => t.startsWith('image/'));
                            if (type) {
                                const blob = await item.getType(type);
                                inputImageB64 = await blobToBase64(blob);
                                showToast("Image pasted from clipboard!", "success");
                                
                                // Update UI
                                if (pasteImg && pasteArea) {
                                    pasteImg.src = inputImageB64;
                                    pasteArea.classList.remove('hidden');
                                    document.getElementById('result-area').classList.remove('hidden');
                                }
                                isNewImage = true;
                                break; 
                            }
                        }
                    } catch (err) { console.log("Clipboard empty/blocked"); }
                }

                // 3. FALLBACK TO UPLOAD
                if (!inputImageB64) {
                    showToast("Select an image...", "info");
                    if(fileInput) { fileInput.value = ''; fileInput.click(); }
                    return; 
                }

                // 4. AUTO-SCAN (If new)
                if (isNewImage) {
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = `SCANNING...`;
                    
                    try {
                        const newPrompt = await generateVisionDescription(inputImageB64);
                        if (newPrompt) {
                            const outBox = document.getElementById('output-text');
                            outBox.value = newPrompt;
                            outBox.dispatchEvent(new Event('input', { bubbles: true })); // Trigger Resize
                        }
                        showToast("Scan Complete. Ready to Visualize.", "success");
                    } catch(e) {
                        showToast("Scan failed, please verify prompt.", "warning");
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                }

                // 5. CRITICAL: UNHIDE VISUALIZE BUTTON & STOP
                // We do NOT generate here. We ensure the Visualize button is visible.
                const vizBtn = document.getElementById('visualize-btn');
                if(vizBtn) {
                    vizBtn.classList.remove('hidden');
                    vizBtn.style.display = 'inline-flex';
                    
                    // Optional: Scroll to it or highlight it
                    vizBtn.classList.add('animate-pulse');
                    setTimeout(() => vizBtn.classList.remove('animate-pulse'), 1000);
                }
            });

            // ==========================================
            //  B. IMG 2 IMG UPLOAD (Auto-Preview & Auto-Scan)
            // ==========================================
				safeListen('img2img-upload', 'change', async (e) => {
					const file = e.target.files[0];
					if (!file) return;

					// 1. Load Image to Preview Area
					const reader = new FileReader();
					reader.onload = async (evt) => {
						const base64Data = evt.target.result;

						// Show Preview elements
						const pasteArea = document.getElementById('paste-preview-area');
						const pasteImg = document.getElementById('paste-preview-img');
						const resArea = document.getElementById('result-area');
						const rndMsg = document.getElementById('random-message');

						if (pasteArea && pasteImg) {
							pasteImg.src = base64Data;
							pasteArea.classList.remove('hidden');
							if (resArea) resArea.classList.remove('hidden');
							if (rndMsg) rndMsg.classList.add('hidden');

							// --- ROBUST CLICK HANDLER ---
							pasteImg.onclick = async (clickEvent) => {
								// Prevent bubbling issues
								if(clickEvent) {
									clickEvent.preventDefault();
									clickEvent.stopPropagation();
								}

								const genImg = document.getElementById('generated-image');
								let validGenSrc = null;

								// 1. Check if a generated image effectively exists
								if (genImg && !genImg.classList.contains('hidden') && genImg.src && genImg.src !== window.location.href) {
									validGenSrc = genImg.src;
								}

								// 2. Decide Action
								if (validGenSrc) {
									try {
										// Attempt to stabilize the source (Fixes blob:null / Black Screen)
										// If it's a blob, we fetch it and convert to Base64.
										// This bypasses browser revocation issues in the comparison window.
										if (validGenSrc.startsWith('blob:')) {
											const response = await fetch(validGenSrc);
											const blob = await response.blob();
											validGenSrc = await new Promise((resolve) => {
												const r = new FileReader();
												r.onloadend = () => resolve(r.result);
												r.readAsDataURL(blob);
											});
										}

										// Success: Open Comparison
										openComparison(base64Data, validGenSrc, "INPUT SOURCE", "GENERATED RESULT");

									} catch (err) {
										console.warn("Comparison prep failed (revoked blob?), falling back to Lightbox.", err);
										// FAILSAFE: If conversion fails, show Input Lightbox
										openLightbox(base64Data, "Input Image Upload", "USER INPUT");
									}
								} else {
									// No generation exists: Show Input Lightbox
									openLightbox(base64Data, "Input Image Upload", "USER INPUT");
								}
							};
						}
						
						showToast("Image loaded. Ready for Img2Img.", "success");
					};
					reader.readAsDataURL(file);

					// Reset input to allow selecting the same file again
					e.target.value = '';
				});


            // ==========================================
            //  C. SHARED EXECUTION LOGIC
            // ==========================================
            async function executeImg2Img(inputImageB64, btn) {
                // 1. Auto-Switch to Pollinations
                if (state.generator !== 'pollination') {
                    showToast("Switching to POLLINATION for Img2Img", "success");
                    setProvider('pollination'); 
                }

                // 2. UI Loading State
                const originalText = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> PROCESSING...`;

                const promptText = document.getElementById('output-text').value || "Enhance this image";
                const negPrompt = document.getElementById('negative-prompt').value;
                const randomSeed = Math.floor(Math.random() * 1000000000);

                try {
                    // 3. Call Generator
                    const resultUrl = await generatePollination(promptText, negPrompt, randomSeed, inputImageB64);

                    if(resultUrl) {
                        const displayImg = document.getElementById('generated-image');
                        displayImg.src = resultUrl;
                        displayImg.classList.remove('hidden');
                        document.getElementById('img-loading').classList.add('hidden');
                        document.getElementById('visualizer-container').classList.remove('hidden');
                        addToHistory(promptText, "IMG2IMG");
                    }
                } catch (e) {
                    console.error(e);
                    showToast("Img2Img Failed: " + e.message, "error");
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                    updateAppStatus('idle');
                }
            }
        // --- PARSERS ---

        function parseA1111(text) {
            let pos = "", neg = "", set = "";
            const negIdx = text.indexOf("Negative prompt:");
            const stepIdx = text.indexOf("Steps: ");
            if (negIdx !== -1) {
                pos = text.substring(0, negIdx).trim();
                const end = stepIdx !== -1 ? stepIdx : text.length;
                neg = text.substring(negIdx + 16, end).trim();
            } else if (stepIdx !== -1) {
                pos = text.substring(0, stepIdx).trim();
            } else { pos = text.trim(); }
            if (stepIdx !== -1) set = text.substring(stepIdx).trim();
            if(!pos && !set) return null;
            return { positive: pos, negative: neg, settings: set };
        }

        function parseComfyDeep(jsonStr) {
            try {
                // Sanitize NaN/Infinity
                let safeJson = jsonStr
                    .replace(/:\s*NaN/g, ': null').replace(/:\s*Infinity/g, ': null').replace(/:\s*-Infinity/g, ': null')
                    .replace(/\[\s*NaN/g, '[null').replace(/,\s*NaN/g, ', null').replace(/NaN\s*\]/g, 'null]')
                    .replace(/\[\s*Infinity/g, '[null').replace(/,\s*Infinity/g, ', null').replace(/Infinity\s*\]/g, 'null]');

                const json = JSON.parse(safeJson);
                
                let candidates = [];
                let settings = [];
                
                function walk(obj) {
                    if (!obj) return;
                    if (typeof obj === 'string') {
                        // Filter junk
                        if (obj.length > 5 && !obj.includes(".safetensors") && !obj.includes(".pt") && !obj.includes("_name")) {
                            candidates.push(obj);
                        }
                        return;
                    }
                    if (typeof obj === 'object') {
                        for (let key in obj) {
                            if (key === 'seed') settings.push(`Seed:${obj[key]}`);
                            if (key === 'steps') settings.push(`Steps:${obj[key]}`);
                            if (key === 'sampler_name') settings.push(`Sampler:${obj[key]}`);
                            walk(obj[key]);
                        }
                    }
                }
                
                walk(json);

                let posArr = [];
                let negArr = [];

                candidates.forEach(txt => {
                    const lower = txt.toLowerCase();
                    const isNeg = lower.match(/bad|nsfw|watermark|blur|error|low res|text,/);
                    const score = scoreText(txt);
                    
                    if (isNeg) negArr.push({ text: txt, score: score });
                    else if (txt.includes(" ") || txt.includes(",")) posArr.push({ text: txt, score: score });
                });

                if (posArr.length === 0 && negArr.length === 0) return null;

                posArr.sort((a, b) => b.score - a.score);
                negArr.sort((a, b) => b.score - a.score);

                const bestPos = posArr.length > 0 ? posArr[0].text : "";
                const uniqueNegs = [...new Set(negArr.map(n => n.text))].join(", ");

                return {
                    positive: bestPos,
                    negative: uniqueNegs,
                    settings: [...new Set(settings)].join(", ") + " (ComfyUI)"
                };

            } catch (e) { console.warn("Comfy Deep Error", e); return null; }
        }

        function scoreText(text) {
            let score = 100;
            if (text.includes("__")) score -= 1000; 
            if (text.includes("{") || text.includes("}")) score -= 500;
            score += Math.min(text.length, 100); 
            return score;
        }
		// FIXED: Play Slideshow from Lightbox without Glitching
			safeListen('lb-play-slideshow', 'click', () => {
				// 1. Get current index before closing anything
				const startIndex = (typeof NavManager !== 'undefined' && NavManager.state.index !== -1) 
					? NavManager.state.index 
					: 0;

				// 2. MANUALLY FORCE CLOSE LIGHTBOX UI (Synchronous)
				// We skip history.back() here because startSlideshow() manages the history stack itself
				const lbOverlay = document.getElementById('lightbox-overlay');
				const lbImg = document.getElementById('lb-image');
				
				if (lbOverlay) {
					lbOverlay.classList.add('hidden');
					// IMPORTANT: Reset Immersive Mode classes if they were stuck
					if (lbImg) {
						lbImg.classList.remove('max-h-[100vh]', 'w-full', 'h-full', 'object-contain', 'scale-100');
						lbImg.classList.add('max-h-[80vh]', 'rounded-lg', 'shadow-2xl');
						lbImg.style.transform = 'scale(1)'; // Reset zoom
					}
				}

				// 3. Start Slideshow immediately
				if (typeof startSlideshow === 'function') {
					startSlideshow(startIndex);
				}
			});
			// ==========================================
            // 20. NAV DOCK INFO READER (With Raw View)
            // ==========================================
            safeListen('nav-png-info', 'click', () => {
                document.getElementById('png-info-input').click();
            });
			safeListen('close-grid-btn', 'click', () => history.back());
            safeListen('png-info-input', 'change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const btn = document.getElementById('nav-png-info');
                const iconDiv = btn.querySelector('div');
                const originalIcon = iconDiv.innerHTML;
                
                try {
                    iconDiv.innerHTML = `<svg class="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
                    btn.classList.add('animate-pulse');

                    const meta = await extractPNGMetadata(file);

                    if (meta && !meta.error) {
                        switchTab('home');
                        
                        // 1. Fill Main UI
                        const outBox = document.getElementById('output-text');
                        outBox.value = meta.positive || `[No Clean Prompt Found]\n(Check Raw Data)`;
                        autoResize(outBox);

                        if (meta.negative) {
                            const negBox = document.getElementById('negative-prompt');
                            if (negBox) {
                                negBox.value = meta.negative;
                                const details = negBox.closest('details');
                                if (details) details.open = true;
                            }
                        }

                        // 2. Fill & Show RAW DATA Box
                        const rawBox = document.getElementById('raw-metadata-box');
                        const rawContainer = document.getElementById('raw-data-container');
                        const rawSource = document.getElementById('raw-data-source');
                        
                        if (rawBox && meta.raw) {
                            // Beautify JSON if possible
                            try {
                                const parsed = JSON.parse(meta.raw);
                                rawBox.value = JSON.stringify(parsed, null, 2);
                            } catch (e) {
                                rawBox.value = meta.raw;
                            }
                            
                            rawSource.innerText = `SOURCE: ${meta.source || 'UNKNOWN'}`;
                            rawContainer.classList.remove('hidden'); // Show the box
                            rawContainer.open = true; // Auto-open it for user
                        }

                        showToast(`Loaded: ${meta.source}`, "success");
                        addToHistory(meta.positive || "PNG Info", "PNG_INFO");
                        outBox.dispatchEvent(new Event('input'));

                    } else {
                        showToast(meta.error || "No metadata found", "warning");
                    }

                } catch (err) {
                    console.error(err);
                    showToast("Read Error", "error");
                } finally {
                    iconDiv.innerHTML = originalIcon;
                    btn.classList.remove('animate-pulse');
                    e.target.value = '';
                }
            });
			
			// ==========================================
            //  MAGNIFIC UPSCALER LOGIC
            // ==========================================
            
            // 1. SIDEBAR BUTTON TRIGGER (File Input)
				safeListen('upscale-file-input', 'change', async (e) => {
					const file = e.target.files[0];
					if (!file) return;
					
					// A. Visual Feedback (Spinner on Sidebar Button)
					const btn = document.getElementById('nav-upscale');
					const originalContent = btn.innerHTML;
					const iconDiv = btn.querySelector('div');
					if(iconDiv) iconDiv.innerHTML = `<svg class="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
					
					// Reset file input
					const originalValue = e.target.value;
					e.target.value = '';

					try {
						const reader = new FileReader();
						reader.readAsDataURL(file);
						await new Promise(resolve => reader.onload = resolve);
						
						const base64Img = reader.result;
						const promptText = document.getElementById('output-text')?.value || "Uploaded Image";
						
						await performUpscale(base64Img, promptText);
					} finally {
						// Restore Sidebar Button
						btn.innerHTML = originalContent;
					}
				});

				// 2. LIGHTBOX BUTTON TRIGGER (Upscale Current View)
				safeListen('lb-upscale-trigger', 'click', async () => {
					const img = document.getElementById('lb-image');
					if (!img || !img.src) return;

					if (!confirm("Send this image to Magnific Upscaler? (Costs Credits)")) return;

					// A. Visual Feedback (Spinner on Lightbox Button)
					const btn = document.getElementById('lb-upscale-trigger');
					const originalContent = btn.innerHTML;
					const originalPointerEvents = btn.style.pointerEvents;
					
					btn.innerHTML = `<svg class="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> PROCESSING`;
					btn.style.pointerEvents = 'none'; // Prevent double click

					// Get prompt from current context
					let promptText = "Upscaled Image";
					if (typeof slideshowItems !== 'undefined' && NavManager.state.index !== -1) {
						promptText = slideshowItems[NavManager.state.index]?.prompt || promptText;
					} else {
						promptText = document.getElementById('output-text')?.value || promptText;
					}

					try {
						// Fetch raw image data from the src
						const response = await fetch(img.src);
						const blob = await response.blob();
						
						const reader = new FileReader();
						reader.readAsDataURL(blob);
						await new Promise(resolve => reader.onload = resolve);
						
						await performUpscale(reader.result, promptText);
					} catch(e) {
						showToast("Failed to prepare image", "error");
					} finally {
						// Restore Lightbox Button
						btn.innerHTML = originalContent;
						btn.style.pointerEvents = originalPointerEvents;
					}
				});
		// ==========================================
        //  FIXED LIGHTBOX DELETE (NavManager Compatible)
        // ==========================================

        // 1. Attach Listener
        safeListen('lb-delete-btn', 'click', deleteCurrentLightboxImage);

       async function deleteCurrentLightboxImage() {
            // Get state from your existing NavManager
            const currentIndex = NavManager.state.index;
            const items = slideshowItems; // Global array reference

            // Safety Checks
            if (currentIndex === -1 || !items || !items[currentIndex]) {
                showToast("Error: No image found", "error");
                return;
            }

            if (!confirm("Permanently delete this image?")) return;

            const itemToDelete = items[currentIndex];
            
            try {
                // A. Remove from Database
                if (itemToDelete.id) {
                    await deleteImageFromDB(itemToDelete.id);
                }

                // B. Remove from Global Array (Mutate in place)
                items.splice(currentIndex, 1);

                // C. Handle Empty Gallery
                if (items.length === 0) {
                    showToast("Gallery Empty", "success");
                    closeLightbox();
                    // Clear ALL strips
                    ['gallery-strip', 'setup-gallery-strip'].forEach(id => {
                        const el = document.getElementById(id);
                        if(el) el.innerHTML = '';
                    });
                    return;
                }

                // D. Calculate New Index
                let newIndex = currentIndex;
                if (newIndex >= items.length) {
                    newIndex = items.length - 1;
                }

                // E. Update Lightbox View (Immediate Visual Swap)
                const newItem = items[newIndex];
                const newUrl = URL.createObjectURL(newItem.blob);
                const lbImg = document.getElementById('lb-image');
                const lbBadge = document.getElementById('lb-provider-badge');
                
                if (lbImg) {
                    lbImg.style.opacity = '0.5';
                    setTimeout(() => {
                        lbImg.src = newUrl;
                        lbImg.style.opacity = '1';
                    }, 50);
                }
                
                if (lbBadge) {
                    lbBadge.innerText = (newItem.provider || 'UNKNOWN').toUpperCase();
                }

                // F. Sync Managers
                NavManager.state.index = newIndex;
                NavManager.bindLightboxButtons(newUrl, newItem.prompt);

                // G. *** THE FIX: WIPE & RE-RENDER FILMSTRIPS ***
                // We must clear innerHTML because renderGalleryBatch only appends.
                ['gallery-strip', 'setup-gallery-strip'].forEach(id => {
                    const el = document.getElementById(id);
                    if(el) el.innerHTML = ''; // <--- CLEAR THE PLACEHOLDER
                });

                galleryPage = 0; // Reset page count
                renderGalleryBatch(); // Draw fresh list

                showToast("Image Deleted", "success");

            } catch (err) {
                console.error(err);
                showToast("Delete Failed: " + (err.message || err), "error");
            }
        }

        // 3. Database Helper (Uses your App's DB Variables)
        function deleteImageFromDB(id) {
            return new Promise((resolve, reject) => {
                // Use global 'db' variable and 'STORE_NAME' constant from your index.html
                if (!db) { reject("Database not initialized"); return; }
                
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const req = store.delete(id);
                
                req.onsuccess = () => resolve(true);
                req.onerror = (e) => reject(e.target.error);
            });
        }
		// --- RESTORED DATA VARIABLES ---
        var genericList = ["-None-"];
        var aspectRatioList = ["1:1 (Square 1024x1024)","16:9 (Cinematic 1408x768)", "3:2 (Photo 35mm 1248x832)","4:3 (Classic TV 1280x896)","5:4 (Medium Format 1120x896)","1.85:1 (Cinema Standard 1352x728)","2:1 (Univisium 1440x720)","2.39:1 (Anamorphic 1568x656)","21:9 (Ultrawide 1536x640)","3:1 (Panorama 1728x576)","4:1 (Ultra Banner 2048x512)","9:16 (Story 768x1408)","2:3 (Tall Photo 832x1248)","3:4 (Portrait 896x1280)","4:5 (Social 896x1120)","3:5 (Vertical 768x1280)","1:1.85 (Tall Mobile 728x1352)","1:2 (Skyscraper 640x1536)","1:2.39 (Tall Anamorphic 656x1568)","1:4 (Ultra Tall 512x2048)"];
        
        // Define placeholders
        var maleSubjects=[...genericList], femaleSubjects=[...genericList], neutralSubjects=[...genericList];
        var maleGenderList=[...genericList], femaleGenderList=[...genericList], allGenderList=[...genericList];
        var lookalikeList=[...genericList], lookalikeListNSFW=[...genericList];
        var activityList=[...genericList], femaleActivityList=[...genericList], maleActivityList=[...genericList], nsfwActivityList=[...genericList];
        var expressionList=[...genericList], femaleExpressionList=[...genericList], maleExpressionList=[...genericList], nsfwExpressionList=[...genericList];
        var bodyTypeList=[...genericList], femaleBodyTypeList=[...genericList], maleBodyTypeList=[...genericList], nsfwBodyTypeList=[...genericList];
        var faceTypeList=[...genericList], hairStyleList=[...genericList], femaleHairStyleList=[...genericList], maleHairStyleList=[...genericList];
        var eyeColorList=[...genericList], breastTypeList=[...genericList], nsfwBreastList=[...genericList];
        var nippleTypeList=[...genericList], nippleShapeList=[...genericList];
        var vaginaTypeList=[...genericList], vaginaShapeList=[...genericList], pelvisList=[...genericList];
        var femalePelvisList=[...genericList], malePelvisList=[...genericList];
        var headJewelleryList=[...genericList], earJewelleryList=[...genericList], neckJewelleryList=[...genericList];
        var armJewelleryList=[...genericList], handJewelleryList=[...genericList];
        var maleUpperBody=[...genericList], femaleUpperBody=[...genericList], femaleUpperBodyNSFW=[...genericList];
        var maleLowerBody=[...genericList], femaleLowerBody=[...genericList], femaleLowerBodyNSFW=[...genericList];
        var maleFootwearList=[...genericList], femaleFootwearList=[...genericList];
        var subjectTypeList=[...genericList], styleList=[...genericList], effectList=[...genericList], nsfwEffectList=[...genericList];
        var backgrounds=[...genericList], shotList=[...genericList], subjectPositionList=[...genericList];
        var cameraLensList=[...genericList], lightingList=[...genericList], qualityList=[...genericList], handPositionList=[...genericList];
        
        // Define NSFW placeholders to prevent crashes in getActiveLists
        var nsfwSubjects=[], nsfwActivityList=[], nsfwExpressionList=[], nsfwBodyTypeList=[], nsfwBreastList=[];
        var lookalikeListNSFW=[], femaleUpperBodyNSFW=[], femaleLowerBodyNSFW=[], nsfwEffectList=[];
		// --- API ERROR INTERCEPTOR (Uses Horde Overlay) ---
function showApiErrorOverlay(errorData) {
    const win = document.getElementById('horde-log-window');
    const content = document.getElementById('horde-log-content');
    const status = document.getElementById('horde-status-text');
    const bar = document.getElementById('horde-progress-bar');
    const timer = document.getElementById('horde-timer');
    
    if(!win || !content) return;

    // 1. VISUALS: REPURPOSE UI TO "RED ALERT" MODE
    // Target the specific label inside the window to change text/color
    const titleLabel = win.querySelector('span.text-yellow-500, span.text-red-500');
    if(titleLabel) {
        titleLabel.className = "text-red-500 font-bold text-xs tracking-widest flex items-center gap-2";
        titleLabel.innerHTML = `<span class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span> API EXCEPTION`;
    }
    
    // 2. INTERPRET THE ERROR
    let friendlyMsg = "Unknown API Error occurred.";
    let rawDebug = JSON.stringify(errorData, null, 2);
    
    // Logic to parse the specific Pollinations Model Error
    if (rawDebug.includes("Invalid option") && rawDebug.includes("fieldErrors")) {
        try {
            // Extract the list of valid models from the error message string
            const validList = errorData.error.details.fieldErrors.model[0]
                .split('expected one of')[1]
                .replace(/["\\]/g, '') // Clean quotes
                .trim();
                
            friendlyMsg = `❌ MODEL MISMATCH\nThe API rejected your selected model.\n\n✅ VALID MODELS ARE:\n${validList.split('|').join(', ')}`;
        } catch(e) {
            friendlyMsg = "❌ MODEL CONFIGURATION ERROR\nThe API rejected the parameters sent.";
        }
    } else if (rawDebug.includes("Validation failed")) {
        friendlyMsg = "⚠️ DATA VALIDATION FAILED\nCheck your prompt text or settings.";
    }

			// 3. INJECT CONTENT LOG WINDOW
			content.innerHTML = `
				<div class="mb-3 p-2 bg-red-900/20 border border-red-500/30 rounded text-red-200 font-bold whitespace-pre-wrap leading-relaxed">${friendlyMsg}</div>
				<div class="text-[9px] text-gray-500 font-mono uppercase tracking-widest mb-1">RAW API RESPONSE:</div>
				<div class="text-[9px] text-gray-400 font-mono whitespace-pre-wrap border-l-2 border-gray-700 pl-2 select-text">${rawDebug}</div>
				
				<div class="mt-4 pt-2 border-t border-white/10 text-center">
					<button onclick="document.getElementById('horde-log-window').classList.add('hidden')" class="w-full py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg shadow-lg transition-all text-xs tracking-widest">
						ACKNOWLEDGE & CLOSE
					</button>
				</div>
			`;

			// 4. UPDATE STATUS BAR
			if(status) {
				status.innerText = "FATAL ERROR";
				status.className = "text-red-500 font-bold text-[10px]";
			}
			if(timer) timer.innerText = "ERR";
			if(bar) {
				bar.className = "bg-red-600 h-full w-full"; // Full Red Bar
				bar.style.width = "100%";
			}

			// 5. SHOW OVERLAY
			win.classList.remove('hidden');
		}
;

    </script>
	<script>
(function() {
    // 1. Cleanup: Remove any old broken buttons
    const oldBtn = document.getElementById('dev-reset-gallery');
    if(oldBtn) oldBtn.remove();

    // 2. Create the Button Programmatically (Guarantees Visibility)
    const btn = document.createElement('button');
    btn.id = "dev-reset-gallery";
    btn.innerText = "⚠️ RESET GALLERY";
    
    // Force High-Contrast & Top Layer Styles
    Object.assign(btn.style, {
        position: 'fixed',
        bottom: '20px',
        right: '20px',
        zIndex: '2147483647', // Max Z-Index
        padding: '12px 24px',
        background: 'red',
        color: 'white',
        fontWeight: '900',
        borderRadius: '8px',
        border: '3px solid white',
        boxShadow: '0 0 30px rgba(255,0,0,0.8)',
        cursor: 'pointer',
        fontFamily: 'monospace',
        fontSize: '14px',
        display: 'none' // Hidden by default
    });
    
    document.body.appendChild(btn);

    // 3. Activation Logic
    let isVisible = false;
    
    // SHORTCUT: Ctrl + Alt + R
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'g') {
            isVisible = true;
            btn.style.display = 'block';
            console.log("⚠️ DEV MODE ARMED");
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                isVisible = false;
                btn.style.display = 'none';
            }, 5000);
        }
    });

    // 4. Wipe Logic
    btn.onclick = async () => {
        const confirmPhrase = prompt("⚠️ FACTORY RESET ⚠️\n\nThis will permanently delete ALL images.\nType 'RESET' to confirm:");
        
        if (confirmPhrase === "RESET") {
            btn.innerText = "WIPING...";
            try {
                // Wipe IndexedDB
                const DB_NAME = 'PB_Gallery_DB';
                const req = indexedDB.deleteDatabase(DB_NAME);
                
                req.onsuccess = () => {
                    // Wipe LocalStorage
                    localStorage.clear();
                    alert("System Wiped. Reloading...");
                    location.reload();
                };
                
                req.onerror = (e) => {
                    alert("Database Locked. Close other tabs and try again.");
                    location.reload();
                };
            } catch(e) {
                localStorage.clear();
                location.reload();
            }
        } else {
            alert("Cancelled.");
        }
    };
    
    console.log("🔧 Dev Reset Tool Loaded. Press [Ctrl + Alt + R] to use.");
})();

</script>
</body>
</html>

